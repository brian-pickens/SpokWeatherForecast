/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app/spok-weather/app.spok-weather.main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@uirouter/angularjs/release/ui-router-angularjs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@uirouter/angularjs/release/ui-router-angularjs.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * State-based routing for AngularJS 1.x
 * This bundle requires the ui-router-core.js bundle from the @uirouter/core package.
 * @version v1.0.16
 * @link https://ui-router.github.io
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function (global, factory) {
     true ? factory(exports, __webpack_require__(/*! angular */ "angular"), __webpack_require__(/*! @uirouter/core */ "./node_modules/@uirouter/core/lib/index.js")) :
    undefined;
}(this, (function (exports,ng_from_import,core) { 'use strict';

    var ng_from_global = angular;
    var ng = ng_from_import && ng_from_import.module ? ng_from_import : ng_from_global;

    function getNg1ViewConfigFactory() {
        var templateFactory = null;
        return function (path, view) {
            templateFactory = templateFactory || core.services.$injector.get('$templateFactory');
            return [new Ng1ViewConfig(path, view, templateFactory)];
        };
    }
    var hasAnyKey = function (keys, obj) { return keys.reduce(function (acc, key) { return acc || core.isDefined(obj[key]); }, false); };
    /**
     * This is a [[StateBuilder.builder]] function for angular1 `views`.
     *
     * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
     * handles the `views` property with logic specific to @uirouter/angularjs (ng1).
     *
     * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object
     * and applies the state-level configuration to a view named `$default`.
     */
    function ng1ViewsBuilder(state) {
        // Do not process root state
        if (!state.parent)
            return {};
        var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);
        // Do not allow a state to have both state-level props and also a `views: {}` property.
        // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.
        // However, the `$default` approach should not be mixed with a separate `views: ` block.
        if (core.isDefined(state.views) && hasAnyKey(allViewKeys, state)) {
            throw new Error("State '" + state.name + "' has a 'views' object. " +
                "It cannot also have \"view properties\" at the state level.  " +
                "Move the following properties into a view (in the 'views' object): " +
                (" " + allViewKeys.filter(function (key) { return core.isDefined(state[key]); }).join(', ')));
        }
        var views = {}, viewsObject = state.views || { $default: core.pick(state, allViewKeys) };
        core.forEach(viewsObject, function (config, name) {
            // Account for views: { "": { template... } }
            name = name || '$default';
            // Account for views: { header: "headerComponent" }
            if (core.isString(config))
                config = { component: config };
            // Make a shallow copy of the config object
            config = core.extend({}, config);
            // Do not allow a view to mix props for component-style view with props for template/controller-style view
            if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {
                throw new Error("Cannot combine: " + compKeys.join('|') + " with: " + nonCompKeys.join('|') + " in stateview: '" + name + "@" + state.name + "'");
            }
            config.resolveAs = config.resolveAs || '$resolve';
            config.$type = 'ng1';
            config.$context = state;
            config.$name = name;
            var normalized = core.ViewService.normalizeUIViewTarget(config.$context, config.$name);
            config.$uiViewName = normalized.uiViewName;
            config.$uiViewContextAnchor = normalized.uiViewContextAnchor;
            views[name] = config;
        });
        return views;
    }
    var id = 0;
    var Ng1ViewConfig = /** @class */ (function () {
        function Ng1ViewConfig(path, viewDecl, factory) {
            var _this = this;
            this.path = path;
            this.viewDecl = viewDecl;
            this.factory = factory;
            this.$id = id++;
            this.loaded = false;
            this.getTemplate = function (uiView, context) {
                return _this.component
                    ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings)
                    : _this.template;
            };
        }
        Ng1ViewConfig.prototype.load = function () {
            var _this = this;
            var $q = core.services.$q;
            var context = new core.ResolveContext(this.path);
            var params = this.path.reduce(function (acc, node) { return core.extend(acc, node.paramValues); }, {});
            var promises = {
                template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),
                controller: $q.when(this.getController(context)),
            };
            return $q.all(promises).then(function (results) {
                core.trace.traceViewServiceEvent('Loaded', _this);
                _this.controller = results.controller;
                core.extend(_this, results.template); // Either { template: "tpl" } or { component: "cmpName" }
                return _this;
            });
        };
        /**
         * Gets the controller for a view configuration.
         *
         * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.
         */
        Ng1ViewConfig.prototype.getController = function (context) {
            var provider = this.viewDecl.controllerProvider;
            if (!core.isInjectable(provider))
                return this.viewDecl.controller;
            var deps = core.services.$injector.annotate(provider);
            var providerFn = core.isArray(provider) ? core.tail(provider) : provider;
            var resolvable = new core.Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        return Ng1ViewConfig;
    }());

    /** @module view */
    /**
     * Service which manages loading of templates from a ViewConfig.
     */
    var TemplateFactory = /** @class */ (function () {
        function TemplateFactory() {
            var _this = this;
            /** @hidden */ this._useHttp = ng.version.minor < 3;
            /** @hidden */ this.$get = [
                '$http',
                '$templateCache',
                '$injector',
                function ($http, $templateCache, $injector) {
                    _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');
                    _this.$http = $http;
                    _this.$templateCache = $templateCache;
                    return _this;
                },
            ];
        }
        /** @hidden */
        TemplateFactory.prototype.useHttpService = function (value) {
            this._useHttp = value;
        };
        /**
         * Creates a template from a configuration object.
         *
         * @param config Configuration object for which to load a template.
         * The following properties are search in the specified order, and the first one
         * that is defined is used to create the template:
         *
         * @param params  Parameters to pass to the template function.
         * @param context The resolve context associated with the template's view
         *
         * @return {string|object}  The template html as a string, or a promise for
         * that string,or `null` if no template is configured.
         */
        TemplateFactory.prototype.fromConfig = function (config, params, context) {
            var defaultTemplate = '<ui-view></ui-view>';
            var asTemplate = function (result) { return core.services.$q.when(result).then(function (str) { return ({ template: str }); }); };
            var asComponent = function (result) { return core.services.$q.when(result).then(function (str) { return ({ component: str }); }); };
            return core.isDefined(config.template)
                ? asTemplate(this.fromString(config.template, params))
                : core.isDefined(config.templateUrl)
                    ? asTemplate(this.fromUrl(config.templateUrl, params))
                    : core.isDefined(config.templateProvider)
                        ? asTemplate(this.fromProvider(config.templateProvider, params, context))
                        : core.isDefined(config.component)
                            ? asComponent(config.component)
                            : core.isDefined(config.componentProvider)
                                ? asComponent(this.fromComponentProvider(config.componentProvider, params, context))
                                : asTemplate(defaultTemplate);
        };
        /**
         * Creates a template from a string or a function returning a string.
         *
         * @param template html template as a string or function that returns an html template as a string.
         * @param params Parameters to pass to the template function.
         *
         * @return {string|object} The template html as a string, or a promise for that
         * string.
         */
        TemplateFactory.prototype.fromString = function (template, params) {
            return core.isFunction(template) ? template(params) : template;
        };
        /**
         * Loads a template from the a URL via `$http` and `$templateCache`.
         *
         * @param {string|Function} url url of the template to load, or a function
         * that returns a url.
         * @param {Object} params Parameters to pass to the url function.
         * @return {string|Promise.<string>} The template html as a string, or a promise
         * for that string.
         */
        TemplateFactory.prototype.fromUrl = function (url, params) {
            if (core.isFunction(url))
                url = url(params);
            if (url == null)
                return null;
            if (this._useHttp) {
                return this.$http
                    .get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })
                    .then(function (response) {
                    return response.data;
                });
            }
            return this.$templateRequest(url);
        };
        /**
         * Creates a template by invoking an injectable provider function.
         *
         * @param provider Function to invoke via `locals`
         * @param {Function} injectFn a function used to invoke the template provider
         * @return {string|Promise.<string>} The template html as a string, or a promise
         * for that string.
         */
        TemplateFactory.prototype.fromProvider = function (provider, params, context) {
            var deps = core.services.$injector.annotate(provider);
            var providerFn = core.isArray(provider) ? core.tail(provider) : provider;
            var resolvable = new core.Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        /**
         * Creates a component's template by invoking an injectable provider function.
         *
         * @param provider Function to invoke via `locals`
         * @param {Function} injectFn a function used to invoke the template provider
         * @return {string} The template html as a string: "<component-name input1='::$resolve.foo'></component-name>".
         */
        TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {
            var deps = core.services.$injector.annotate(provider);
            var providerFn = core.isArray(provider) ? core.tail(provider) : provider;
            var resolvable = new core.Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        /**
         * Creates a template from a component's name
         *
         * This implements route-to-component.
         * It works by retrieving the component (directive) metadata from the injector.
         * It analyses the component's bindings, then constructs a template that instantiates the component.
         * The template wires input and output bindings to resolves or from the parent component.
         *
         * @param uiView {object} The parent ui-view (for binding outputs to callbacks)
         * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)
         * @param component {string} Component's name in camel case.
         * @param bindings An object defining the component's bindings: {foo: '<'}
         * @return {string} The template as a string: "<component-name input1='::$resolve.foo'></component-name>".
         */
        TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {
            bindings = bindings || {};
            // Bind once prefix
            var prefix = ng.version.minor >= 3 ? '::' : '';
            // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`
            var kebob = function (camelCase) {
                var kebobed = core.kebobString(camelCase);
                return /^(x|data)-/.exec(kebobed) ? "x-" + kebobed : kebobed;
            };
            var attributeTpl = function (input) {
                var name = input.name, type = input.type;
                var attrName = kebob(name);
                // If the ui-view has an attribute which matches a binding on the routed component
                // then pass that attribute through to the routed component template.
                // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`
                if (uiView.attr(attrName) && !bindings[name])
                    return attrName + "='" + uiView.attr(attrName) + "'";
                var resolveName = bindings[name] || name;
                // Pre-evaluate the expression for "@" bindings by enclosing in {{ }}
                // some-attr="{{ ::$resolve.someResolveName }}"
                if (type === '@')
                    return attrName + "='{{" + prefix + "$resolve." + resolveName + "}}'";
                // Wire "&" callbacks to resolves that return a callback function
                // Get the result of the resolve (should be a function) and annotate it to get its arguments.
                // some-attr="$resolve.someResolveResultName(foo, bar)"
                if (type === '&') {
                    var res = context.getResolvable(resolveName);
                    var fn = res && res.data;
                    var args = (fn && core.services.$injector.annotate(fn)) || [];
                    // account for array style injection, i.e., ['foo', function(foo) {}]
                    var arrayIdxStr = core.isArray(fn) ? "[" + (fn.length - 1) + "]" : '';
                    return attrName + "='$resolve." + resolveName + arrayIdxStr + "(" + args.join(',') + ")'";
                }
                // some-attr="::$resolve.someResolveName"
                return attrName + "='" + prefix + "$resolve." + resolveName + "'";
            };
            var attrs = getComponentBindings(component)
                .map(attributeTpl)
                .join(' ');
            var kebobName = kebob(component);
            return "<" + kebobName + " " + attrs + "></" + kebobName + ">";
        };
        return TemplateFactory;
    }());
    // Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')
    function getComponentBindings(name) {
        var cmpDefs = core.services.$injector.get(name + 'Directive'); // could be multiple
        if (!cmpDefs || !cmpDefs.length)
            throw new Error("Unable to find component named '" + name + "'");
        return cmpDefs.map(getBindings).reduce(core.unnestR, []);
    }
    // Given a directive definition, find its object input attributes
    // Use different properties, depending on the type of directive (component, bindToController, normal)
    var getBindings = function (def) {
        if (core.isObject(def.bindToController))
            return scopeBindings(def.bindToController);
        return scopeBindings(def.scope);
    };
    // for ng 1.2 style, process the scope: { input: "=foo" }
    // for ng 1.3 through ng 1.5, process the component's bindToController: { input: "=foo" } object
    var scopeBindings = function (bindingsObj) {
        return Object.keys(bindingsObj || {})
            // [ 'input', [ '=foo', '=', 'foo' ] ]
            .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })
            // skip malformed values
            .filter(function (tuple) { return core.isDefined(tuple) && core.isArray(tuple[1]); })
            // { name: ('foo' || 'input'), type: '=' }
            .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); });
    };

    /** @module ng1 */ /** for typedoc */
    /**
     * The Angular 1 `StateProvider`
     *
     * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely
     * on state.
     *
     * A state corresponds to a "place" in the application in terms of the overall UI and
     * navigation. A state describes (via the controller / template / view properties) what
     * the UI looks like and does at that place.
     *
     * States often have things in common, and the primary way of factoring out these
     * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
     * nested states.
     *
     * The `$stateProvider` provides interfaces to declare these states for your app.
     */
    var StateProvider = /** @class */ (function () {
        function StateProvider(stateRegistry, stateService) {
            this.stateRegistry = stateRegistry;
            this.stateService = stateService;
            core.createProxyFunctions(core.val(StateProvider.prototype), this, core.val(this));
        }
        /**
         * Decorates states when they are registered
         *
         * Allows you to extend (carefully) or override (at your own peril) the
         * `stateBuilder` object used internally by [[StateRegistry]].
         * This can be used to add custom functionality to ui-router,
         * for example inferring templateUrl based on the state name.
         *
         * When passing only a name, it returns the current (original or decorated) builder
         * function that matches `name`.
         *
         * The builder functions that can be decorated are listed below. Though not all
         * necessarily have a good use case for decoration, that is up to you to decide.
         *
         * In addition, users can attach custom decorators, which will generate new
         * properties within the state's internal definition. There is currently no clear
         * use-case for this beyond accessing internal states (i.e. $state.$current),
         * however, expect this to become increasingly relevant as we introduce additional
         * meta-programming features.
         *
         * **Warning**: Decorators should not be interdependent because the order of
         * execution of the builder functions in non-deterministic. Builder functions
         * should only be dependent on the state definition object and super function.
         *
         *
         * Existing builder functions and current return values:
         *
         * - **parent** `{object}` - returns the parent state object.
         * - **data** `{object}` - returns state data, including any inherited data that is not
         *   overridden by own values (if any).
         * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
         *   or `null`.
         * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is
         *   navigable).
         * - **params** `{object}` - returns an array of state params that are ensured to
         *   be a super-set of parent's params.
         * - **views** `{object}` - returns a views object where each key is an absolute view
         *   name (i.e. "viewName@stateName") and each value is the config object
         *   (template, controller) for the view. Even when you don't use the views object
         *   explicitly on a state config, one is still created for you internally.
         *   So by decorating this builder function you have access to decorating template
         *   and controller properties.
         * - **ownParams** `{object}` - returns an array of params that belong to the state,
         *   not including any params defined by ancestor states.
         * - **path** `{string}` - returns the full path from the root down to this state.
         *   Needed for state activation.
         * - **includes** `{object}` - returns an object that includes every state that
         *   would pass a `$state.includes()` test.
         *
         * #### Example:
         * Override the internal 'views' builder with a function that takes the state
         * definition, and a reference to the internal function being overridden:
         * ```js
         * $stateProvider.decorator('views', function (state, parent) {
         *   let result = {},
         *       views = parent(state);
         *
         *   angular.forEach(views, function (config, name) {
         *     let autoName = (state.name + '.' + name).replace('.', '/');
         *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
         *     result[name] = config;
         *   });
         *   return result;
         * });
         *
         * $stateProvider.state('home', {
         *   views: {
         *     'contact.list': { controller: 'ListController' },
         *     'contact.item': { controller: 'ItemController' }
         *   }
         * });
         * ```
         *
         *
         * ```js
         * // Auto-populates list and item views with /partials/home/contact/list.html,
         * // and /partials/home/contact/item.html, respectively.
         * $state.go('home');
         * ```
         *
         * @param {string} name The name of the builder function to decorate.
         * @param {object} func A function that is responsible for decorating the original
         * builder function. The function receives two parameters:
         *
         *   - `{object}` - state - The state config object.
         *   - `{object}` - super - The original builder function.
         *
         * @return {object} $stateProvider - $stateProvider instance
         */
        StateProvider.prototype.decorator = function (name, func) {
            return this.stateRegistry.decorator(name, func) || this;
        };
        StateProvider.prototype.state = function (name, definition) {
            if (core.isObject(name)) {
                definition = name;
            }
            else {
                definition.name = name;
            }
            this.stateRegistry.register(definition);
            return this;
        };
        /**
         * Registers an invalid state handler
         *
         * This is a passthrough to [[StateService.onInvalid]] for ng1.
         */
        StateProvider.prototype.onInvalid = function (callback) {
            return this.stateService.onInvalid(callback);
        };
        return StateProvider;
    }());

    /** @module ng1 */ /** */
    /**
     * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,
     * `onRetain` callback hooks on a [[Ng1StateDeclaration]].
     *
     * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
     * ensures that those hooks are injectable for @uirouter/angularjs (ng1).
     */
    var getStateHookBuilder = function (hookName) {
        return function stateHookBuilder(stateObject, parentFn) {
            var hook = stateObject[hookName];
            var pathname = hookName === 'onExit' ? 'from' : 'to';
            function decoratedNg1Hook(trans, state) {
                var resolveContext = new core.ResolveContext(trans.treeChanges(pathname));
                var subContext = resolveContext.subContext(state.$$state());
                var locals = core.extend(getLocals(subContext), { $state$: state, $transition$: trans });
                return core.services.$injector.invoke(hook, this, locals);
            }
            return hook ? decoratedNg1Hook : undefined;
        };
    };

    /**
     * @internalapi
     * @module ng1
     */ /** */
    /**
     * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service
     */
    var Ng1LocationServices = /** @class */ (function () {
        function Ng1LocationServices($locationProvider) {
            // .onChange() registry
            this._urlListeners = [];
            this.$locationProvider = $locationProvider;
            var _lp = core.val($locationProvider);
            core.createProxyFunctions(_lp, this, _lp, ['hashPrefix']);
        }
        /**
         * Applys ng1-specific path parameter encoding
         *
         * The Angular 1 `$location` service is a bit weird.
         * It doesn't allow slashes to be encoded/decoded bi-directionally.
         *
         * See the writeup at https://github.com/angular-ui/ui-router/issues/2598
         *
         * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F
         *
         * @param router
         */
        Ng1LocationServices.monkeyPatchPathParameterType = function (router) {
            var pathType = router.urlMatcherFactory.type('path');
            pathType.encode = function (x) {
                return x != null ? x.toString().replace(/(~|\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : x;
            };
            pathType.decode = function (x) {
                return x != null ? x.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : x;
            };
        };
        Ng1LocationServices.prototype.dispose = function () { };
        Ng1LocationServices.prototype.onChange = function (callback) {
            var _this = this;
            this._urlListeners.push(callback);
            return function () { return core.removeFrom(_this._urlListeners)(callback); };
        };
        Ng1LocationServices.prototype.html5Mode = function () {
            var html5Mode = this.$locationProvider.html5Mode();
            html5Mode = core.isObject(html5Mode) ? html5Mode.enabled : html5Mode;
            return html5Mode && this.$sniffer.history;
        };
        Ng1LocationServices.prototype.url = function (newUrl, replace, state) {
            if (replace === void 0) { replace = false; }
            if (core.isDefined(newUrl))
                this.$location.url(newUrl);
            if (replace)
                this.$location.replace();
            if (state)
                this.$location.state(state);
            return this.$location.url();
        };
        Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser) {
            var _this = this;
            this.$location = $location;
            this.$sniffer = $sniffer;
            // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange
            $rootScope.$on('$locationChangeSuccess', function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });
            var _loc = core.val($location);
            var _browser = core.val($browser);
            // Bind these LocationService functions to $location
            core.createProxyFunctions(_loc, this, _loc, ['replace', 'path', 'search', 'hash']);
            // Bind these LocationConfig functions to $location
            core.createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);
            // Bind these LocationConfig functions to $browser
            core.createProxyFunctions(_browser, this, _browser, ['baseHref']);
        };
        return Ng1LocationServices;
    }());

    /** @module url */ /** */
    /**
     * Manages rules for client-side URL
     *
     * ### Deprecation warning:
     * This class is now considered to be an internal API
     * Use the [[UrlService]] instead.
     * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].
     *
     * This class manages the router rules for what to do when the URL changes.
     *
     * This provider remains for backwards compatibility.
     *
     * @deprecated
     */
    var UrlRouterProvider = /** @class */ (function () {
        /** @hidden */
        function UrlRouterProvider(router) {
            this._router = router;
            this._urlRouter = router.urlRouter;
        }
        UrlRouterProvider.injectableHandler = function (router, handler) {
            return function (match) { return core.services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params }); };
        };
        /** @hidden */
        UrlRouterProvider.prototype.$get = function () {
            var urlRouter = this._urlRouter;
            urlRouter.update(true);
            if (!urlRouter.interceptDeferred)
                urlRouter.listen();
            return urlRouter;
        };
        /**
         * Registers a url handler function.
         *
         * Registers a low level url handler (a `rule`).
         * A rule detects specific URL patterns and returns a redirect, or performs some action.
         *
         * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // Here's an example of how you might allow case insensitive urls
         *   $urlRouterProvider.rule(function ($injector, $location) {
         *     var path = $location.path(),
         *         normalized = path.toLowerCase();
         *
         *     if (path !== normalized) {
         *       return normalized;
         *     }
         *   });
         * });
         * ```
         *
         * @param ruleFn
         * Handler function that takes `$injector` and `$location` services as arguments.
         * You can use them to detect a url and return a different url as a string.
         *
         * @return [[UrlRouterProvider]] (`this`)
         */
        UrlRouterProvider.prototype.rule = function (ruleFn) {
            var _this = this;
            if (!core.isFunction(ruleFn))
                throw new Error("'rule' must be a function");
            var match = function () { return ruleFn(core.services.$injector, _this._router.locationService); };
            var rule = new core.BaseUrlRule(match, core.identity);
            this._urlRouter.rule(rule);
            return this;
        };
        /**
         * Defines the path or behavior to use when no url can be matched.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // if the path doesn't match any of the urls you configured
         *   // otherwise will take care of routing the user to the
         *   // specified url
         *   $urlRouterProvider.otherwise('/index');
         *
         *   // Example of using function rule as param
         *   $urlRouterProvider.otherwise(function ($injector, $location) {
         *     return '/a/valid/url';
         *   });
         * });
         * ```
         *
         * @param rule
         * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.
         * The function version is passed two params: `$injector` and `$location` services, and should return a url string.
         *
         * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
         */
        UrlRouterProvider.prototype.otherwise = function (rule) {
            var _this = this;
            var urlRouter = this._urlRouter;
            if (core.isString(rule)) {
                urlRouter.otherwise(rule);
            }
            else if (core.isFunction(rule)) {
                urlRouter.otherwise(function () { return rule(core.services.$injector, _this._router.locationService); });
            }
            else {
                throw new Error("'rule' must be a string or function");
            }
            return this;
        };
        /**
         * Registers a handler for a given url matching.
         *
         * If the handler is a string, it is
         * treated as a redirect, and is interpolated according to the syntax of match
         * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
         *
         * If the handler is a function, it is injectable.
         * It gets invoked if `$location` matches.
         * You have the option of inject the match object as `$match`.
         *
         * The handler can return
         *
         * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
         *   will continue trying to find another one that matches.
         * - **string** which is treated as a redirect and passed to `$location.url()`
         * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
         *     if ($state.$current.navigable !== state ||
         *         !equalForKeys($match, $stateParams) {
         *      $state.transitionTo(state, $match, false);
         *     }
         *   });
         * });
         * ```
         *
         * @param what A pattern string to match, compiled as a [[UrlMatcher]].
         * @param handler The path (or function that returns a path) that you want to redirect your user to.
         * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]
         *
         * Note: the handler may also invoke arbitrary code, such as `$state.go()`
         */
        UrlRouterProvider.prototype.when = function (what, handler) {
            if (core.isArray(handler) || core.isFunction(handler)) {
                handler = UrlRouterProvider.injectableHandler(this._router, handler);
            }
            this._urlRouter.when(what, handler);
            return this;
        };
        /**
         * Disables monitoring of the URL.
         *
         * Call this method before UI-Router has bootstrapped.
         * It will stop UI-Router from performing the initial url sync.
         *
         * This can be useful to perform some asynchronous initialization before the router starts.
         * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // Prevent $urlRouter from automatically intercepting URL changes;
         *   $urlRouterProvider.deferIntercept();
         * })
         *
         * app.run(function (MyService, $urlRouter, $http) {
         *   $http.get("/stuff").then(function(resp) {
         *     MyService.doStuff(resp.data);
         *     $urlRouter.listen();
         *     $urlRouter.sync();
         *   });
         * });
         * ```
         *
         * @param defer Indicates whether to defer location change interception.
         *        Passing no parameter is equivalent to `true`.
         */
        UrlRouterProvider.prototype.deferIntercept = function (defer) {
            this._urlRouter.deferIntercept(defer);
        };
        return UrlRouterProvider;
    }());

    /**
     * # Angular 1 types
     *
     * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.
     * The customizations to the core types for Angular UI-Router are documented here.
     *
     * The optional [[$resolve]] service is also documented here.
     *
     * @module ng1
     * @preferred
     */
    ng.module('ui.router.angular1', []);
    var mod_init = ng.module('ui.router.init', []);
    var mod_util = ng.module('ui.router.util', ['ng', 'ui.router.init']);
    var mod_rtr = ng.module('ui.router.router', ['ui.router.util']);
    var mod_state = ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);
    var mod_main = ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);
    var mod_cmpt = ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line
    var router = null;
    $uiRouterProvider.$inject = ['$locationProvider'];
    /** This angular 1 provider instantiates a Router and exposes its services via the angular injector */
    function $uiRouterProvider($locationProvider) {
        // Create a new instance of the Router when the $uiRouterProvider is initialized
        router = this.router = new core.UIRouter();
        router.stateProvider = new StateProvider(router.stateRegistry, router.stateService);
        // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties
        router.stateRegistry.decorator('views', ng1ViewsBuilder);
        router.stateRegistry.decorator('onExit', getStateHookBuilder('onExit'));
        router.stateRegistry.decorator('onRetain', getStateHookBuilder('onRetain'));
        router.stateRegistry.decorator('onEnter', getStateHookBuilder('onEnter'));
        router.viewService._pluginapi._viewConfigFactory('ng1', getNg1ViewConfigFactory());
        var ng1LocationService = (router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider));
        Ng1LocationServices.monkeyPatchPathParameterType(router);
        // backwards compat: also expose router instance as $uiRouterProvider.router
        router['router'] = router;
        router['$get'] = $get;
        $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];
        function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {
            ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);
            delete router['router'];
            delete router['$get'];
            return router;
        }
        return router;
    }
    var getProviderFor = function (serviceName) { return [
        '$uiRouterProvider',
        function ($urp) {
            var service = $urp.router[serviceName];
            service['$get'] = function () { return service; };
            return service;
        },
    ]; };
    // This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)
    runBlock.$inject = ['$injector', '$q', '$uiRouter'];
    function runBlock($injector, $q, $uiRouter) {
        core.services.$injector = $injector;
        core.services.$q = $q;
        // The $injector is now available.
        // Find any resolvables that had dependency annotation deferred
        $uiRouter.stateRegistry
            .get()
            .map(function (x) { return x.$$state().resolvables; })
            .reduce(core.unnestR, [])
            .filter(function (x) { return x.deps === 'deferred'; })
            .forEach(function (resolvable) { return (resolvable.deps = $injector.annotate(resolvable.resolveFn, $injector.strictDi)); });
    }
    // $urlRouter service and $urlRouterProvider
    var getUrlRouterProvider = function (uiRouter) { return (uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter)); };
    // $state service and $stateProvider
    // $urlRouter service and $urlRouterProvider
    var getStateProvider = function () { return core.extend(router.stateProvider, { $get: function () { return router.stateService; } }); };
    watchDigests.$inject = ['$rootScope'];
    function watchDigests($rootScope) {
        $rootScope.$watch(function () {
            core.trace.approximateDigests++;
        });
    }
    mod_init.provider('$uiRouter', $uiRouterProvider);
    mod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);
    mod_util.provider('$urlService', getProviderFor('urlService'));
    mod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);
    mod_util.provider('$templateFactory', function () { return new TemplateFactory(); });
    mod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));
    mod_state.provider('$uiRouterGlobals', getProviderFor('globals'));
    mod_state.provider('$transitions', getProviderFor('transitionService'));
    mod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);
    mod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);
    mod_main.factory('$view', function () { return router.viewService; });
    mod_main.service('$trace', function () { return core.trace; });
    mod_main.run(watchDigests);
    mod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);
    mod_state.run(['$state', function ($state) { }]);
    mod_rtr.run(['$urlRouter', function ($urlRouter) { }]);
    mod_init.run(runBlock);
    /** @hidden TODO: find a place to move this */
    var getLocals = function (ctx) {
        var tokens = ctx.getTokens().filter(core.isString);
        var tuples = tokens.map(function (key) {
            var resolvable = ctx.getResolvable(key);
            var waitPolicy = ctx.getPolicy(resolvable).async;
            return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];
        });
        return tuples.reduce(core.applyPairs, {});
    };

    /**
     * The current (or pending) State Parameters
     *
     * An injectable global **Service Object** which holds the state parameters for the latest **SUCCESSFUL** transition.
     *
     * The values are not updated until *after* a `Transition` successfully completes.
     *
     * **Also:** an injectable **Per-Transition Object** object which holds the pending state parameters for the pending `Transition` currently running.
     *
     * ### Deprecation warning:
     *
     * The value injected for `$stateParams` is different depending on where it is injected.
     *
     * - When injected into an angular service, the object injected is the global **Service Object** with the parameter values for the latest successful `Transition`.
     * - When injected into transition hooks, resolves, or view controllers, the object is the **Per-Transition Object** with the parameter values for the running `Transition`.
     *
     * Because of these confusing details, this service is deprecated.
     *
     * ### Instead of using the global `$stateParams` service object,
     * inject [[$uiRouterGlobals]] and use [[UIRouterGlobals.params]]
     *
     * ```js
     * MyService.$inject = ['$uiRouterGlobals'];
     * function MyService($uiRouterGlobals) {
     *   return {
     *     paramValues: function () {
     *       return $uiRouterGlobals.params;
     *     }
     *   }
     * }
     * ```
     *
     * ### Instead of using the per-transition `$stateParams` object,
     * inject the current `Transition` (as [[$transition$]]) and use [[Transition.params]]
     *
     * ```js
     * MyController.$inject = ['$transition$'];
     * function MyController($transition$) {
     *   var username = $transition$.params().username;
     *   // .. do something with username
     * }
     * ```
     *
     * ---
     *
     * This object can be injected into other services.
     *
     * #### Deprecated Example:
     * ```js
     * SomeService.$inject = ['$http', '$stateParams'];
     * function SomeService($http, $stateParams) {
     *   return {
     *     getUser: function() {
     *       return $http.get('/api/users/' + $stateParams.username);
     *     }
     *   }
     * };
     * angular.service('SomeService', SomeService);
     * ```
     * @deprecated
     */

    /**
     * # Angular 1 Directives
     *
     * These are the directives included in UI-Router for Angular 1.
     * These directives are used in templates to create viewports and link/navigate to states.
     *
     * @ng1api
     * @preferred
     * @module directives
     */ /** for typedoc */
    /** @hidden */
    function parseStateRef(ref) {
        var parsed;
        var paramsOnly = ref.match(/^\s*({[^}]*})\s*$/);
        if (paramsOnly)
            ref = '(' + paramsOnly[1] + ')';
        parsed = ref.replace(/\n/g, ' ').match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);
        if (!parsed || parsed.length !== 4)
            throw new Error("Invalid state ref '" + ref + "'");
        return { state: parsed[1] || null, paramExpr: parsed[3] || null };
    }
    /** @hidden */
    function stateContext(el) {
        var $uiView = el.parent().inheritedData('$uiView');
        var path = core.parse('$cfg.path')($uiView);
        return path ? core.tail(path).state.name : undefined;
    }
    /** @hidden */
    function processedDef($state, $element, def) {
        var uiState = def.uiState || $state.current.name;
        var uiStateOpts = core.extend(defaultOpts($element, $state), def.uiStateOpts || {});
        var href = $state.href(uiState, def.uiStateParams, uiStateOpts);
        return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };
    }
    /** @hidden */
    function getTypeInfo(el) {
        // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
        var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
        var isForm = el[0].nodeName === 'FORM';
        return {
            attr: isForm ? 'action' : isSvg ? 'xlink:href' : 'href',
            isAnchor: el.prop('tagName').toUpperCase() === 'A',
            clickable: !isForm,
        };
    }
    /** @hidden */
    function clickHook(el, $state, $timeout, type, getDef) {
        return function (e) {
            var button = e.which || e.button, target = getDef();
            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
                // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
                var transition_1 = $timeout(function () {
                    $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);
                });
                e.preventDefault();
                // if the state has no URL, ignore one preventDefault from the <a> directive.
                var ignorePreventDefaultCount_1 = type.isAnchor && !target.href ? 1 : 0;
                e.preventDefault = function () {
                    if (ignorePreventDefaultCount_1-- <= 0)
                        $timeout.cancel(transition_1);
                };
            }
        };
    }
    /** @hidden */
    function defaultOpts(el, $state) {
        return {
            relative: stateContext(el) || $state.$current,
            inherit: true,
            source: 'sref',
        };
    }
    /** @hidden */
    function bindEvents(element, scope, hookFn, uiStateOpts) {
        var events;
        if (uiStateOpts) {
            events = uiStateOpts.events;
        }
        if (!core.isArray(events)) {
            events = ['click'];
        }
        var on = element.on ? 'on' : 'bind';
        for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
            var event_1 = events_1[_i];
            element[on](event_1, hookFn);
        }
        scope.$on('$destroy', function () {
            var off = element.off ? 'off' : 'unbind';
            for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {
                var event_2 = events_2[_i];
                element[off](event_2, hookFn);
            }
        });
    }
    /**
     * `ui-sref`: A directive for linking to a state
     *
     * A directive which links to a state (and optionally, parameters).
     * When clicked, this directive activates the linked state with the supplied parameter values.
     *
     * ### Linked State
     * The attribute value of the `ui-sref` is the name of the state to link to.
     *
     * #### Example:
     * This will activate the `home` state when the link is clicked.
     * ```html
     * <a ui-sref="home">Home</a>
     * ```
     *
     * ### Relative Links
     * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).
     * You just need to be aware that the path is relative to the state that *created* the link.
     * This allows a state to create a relative `ui-sref` which always targets the same destination.
     *
     * #### Example:
     * Both these links are relative to the parent state, even when a child state is currently active.
     * ```html
     * <a ui-sref=".child1">child 1 state</a>
     * <a ui-sref=".child2">child 2 state</a>
     * ```
     *
     * This link activates the parent state.
     * ```html
     * <a ui-sref="^">Return</a>
     * ```
     *
     * ### hrefs
     * If the linked state has a URL, the directive will automatically generate and
     * update the `href` attribute (using the [[StateService.href]]  method).
     *
     * #### Example:
     * Assuming the `users` state has a url of `/users/`
     * ```html
     * <a ui-sref="users" href="/users/">Users</a>
     * ```
     *
     * ### Parameter Values
     * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.
     * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.
     * The content inside the parentheses is an expression, evaluated to the parameter values.
     *
     * #### Example:
     * This example renders a list of links to users.
     * The state's `userId` parameter value comes from each user's `user.id` property.
     * ```html
     * <li ng-repeat="user in users">
     *   <a ui-sref="users.detail({ userId: user.id })">{{ user.displayName }}</a>
     * </li>
     * ```
     *
     * Note:
     * The parameter values expression is `$watch`ed for updates.
     *
     * ### Transition Options
     * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.
     * Options are restricted to `location`, `inherit`, and `reload`.
     *
     * #### Example:
     * ```html
     * <a ui-sref="home" ui-sref-opts="{ reload: true }">Home</a>
     * ```
     *
     * ### Other DOM Events
     *
     * You can also customize which DOM events to respond to (instead of `click`) by
     * providing an `events` array in the `ui-sref-opts` attribute.
     *
     * #### Example:
     * ```html
     * <input type="text" ui-sref="contacts" ui-sref-opts="{ events: ['change', 'blur'] }">
     * ```
     *
     * ### Highlighting the active link
     * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.
     *
     * ### Examples
     * If you have the following template:
     *
     * ```html
     * <a ui-sref="home">Home</a>
     * <a ui-sref="about">About</a>
     * <a ui-sref="{page: 2}">Next page</a>
     *
     * <ul>
     *     <li ng-repeat="contact in contacts">
     *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
     *     </li>
     * </ul>
     * ```
     *
     * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:
     *
     * ```html
     * <a href="#/home" ui-sref="home">Home</a>
     * <a href="#/about" ui-sref="about">About</a>
     * <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
     *
     * <ul>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
     *     </li>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
     *     </li>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
     *     </li>
     * </ul>
     *
     * <a href="#/home" ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
     * ```
     *
     * ### Notes
     *
     * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.
     * #### Example:
     * Sets the `lang` parameter to `en` and remains on the same state.
     *
     * ```html
     * <a ui-sref="{ lang: 'en' }">English</a>
     * ```
     *
     * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.
     *
     * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).
     * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.
     */
    var uiSrefDirective;
    uiSrefDirective = [
        '$uiRouter',
        '$timeout',
        function $StateRefDirective($uiRouter, $timeout) {
            var $state = $uiRouter.stateService;
            return {
                restrict: 'A',
                require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
                link: function (scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var unlinkInfoFn = null;
                    var hookFn;
                    var rawDef = {};
                    var getDef = function () { return processedDef($state, element, rawDef); };
                    var ref = parseStateRef(attrs.uiSref);
                    rawDef.uiState = ref.state;
                    rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};
                    function update() {
                        var def = getDef();
                        if (unlinkInfoFn)
                            unlinkInfoFn();
                        if (active)
                            unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                        if (def.href != null)
                            attrs.$set(type.attr, def.href);
                    }
                    if (ref.paramExpr) {
                        scope.$watch(ref.paramExpr, function (val) {
                            rawDef.uiStateParams = core.extend({}, val);
                            update();
                        }, true);
                        rawDef.uiStateParams = core.extend({}, scope.$eval(ref.paramExpr));
                    }
                    update();
                    scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));
                    scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));
                    if (!type.clickable)
                        return;
                    hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
                },
            };
        },
    ];
    /**
     * `ui-state`: A fully dynamic directive for linking to a state
     *
     * A directive which links to a state (and optionally, parameters).
     * When clicked, this directive activates the linked state with the supplied parameter values.
     *
     * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**
     *
     * A directive which links to a state (and optionally, parameters).
     * When clicked, this directive activates the linked state with the supplied parameter values.
     *
     * ### Linked State
     * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.
     * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**
     *
     * #### Example:
     * Create a list of links.
     * ```html
     * <li ng-repeat="link in navlinks">
     *   <a ui-state="link.state">{{ link.displayName }}</a>
     * </li>
     * ```
     *
     * ### Relative Links
     * If the expression evaluates to a relative path, it is processed like [[uiSref]].
     * You just need to be aware that the path is relative to the state that *created* the link.
     * This allows a state to create relative `ui-state` which always targets the same destination.
     *
     * ### hrefs
     * If the linked state has a URL, the directive will automatically generate and
     * update the `href` attribute (using the [[StateService.href]]  method).
     *
     * ### Parameter Values
     * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.
     * Param values should be provided using the `ui-state-params` attribute.
     * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.
     *
     * #### Example:
     * This example renders a list of links with param values.
     * The state's `userId` parameter value comes from each user's `user.id` property.
     * ```html
     * <li ng-repeat="link in navlinks">
     *   <a ui-state="link.state" ui-state-params="link.params">{{ link.displayName }}</a>
     * </li>
     * ```
     *
     * ### Transition Options
     * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.
     * Options are restricted to `location`, `inherit`, and `reload`.
     * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.
     *
     * #### Example:
     * ```html
     * <a ui-state="returnto.state" ui-state-opts="{ reload: true }">Home</a>
     * ```
     *
     * ### Other DOM Events
     *
     * You can also customize which DOM events to respond to (instead of `click`) by
     * providing an `events` array in the `ui-state-opts` attribute.
     *
     * #### Example:
     * ```html
     * <input type="text" ui-state="contacts" ui-state-opts="{ events: ['change', 'blur'] }">
     * ```
     *
     * ### Highlighting the active link
     * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.
     *
     * ### Notes
     *
     * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.
     *   However, it might be simpler to use [[uiSref]] parameter-only links.
     *
     * #### Example:
     * Sets the `lang` parameter to `en` and remains on the same state.
     *
     * ```html
     * <a ui-state="" ui-state-params="{ lang: 'en' }">English</a>
     * ```
     *
     * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.
     * ```
     */
    var uiStateDirective;
    uiStateDirective = [
        '$uiRouter',
        '$timeout',
        function $StateRefDynamicDirective($uiRouter, $timeout) {
            var $state = $uiRouter.stateService;
            return {
                restrict: 'A',
                require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
                link: function (scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var unlinkInfoFn = null;
                    var hookFn;
                    var rawDef = {};
                    var getDef = function () { return processedDef($state, element, rawDef); };
                    var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];
                    var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return ((acc[attr] = core.noop), acc); }, {});
                    function update() {
                        var def = getDef();
                        if (unlinkInfoFn)
                            unlinkInfoFn();
                        if (active)
                            unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                        if (def.href != null)
                            attrs.$set(type.attr, def.href);
                    }
                    inputAttrs.forEach(function (field) {
                        rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;
                        attrs.$observe(field, function (expr) {
                            watchDeregFns[field]();
                            watchDeregFns[field] = scope.$watch(expr, function (newval) {
                                rawDef[field] = newval;
                                update();
                            }, true);
                        });
                    });
                    update();
                    scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));
                    scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));
                    if (!type.clickable)
                        return;
                    hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
                },
            };
        },
    ];
    /**
     * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active
     *
     * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the
     * related directive's state is active (and remove them when it is inactive).
     *
     * The primary use-case is to highlight the active link in navigation menus,
     * distinguishing it from the inactive menu items.
     *
     * ### Linking to a `ui-sref` or `ui-state`
     * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.
     * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.
     *
     * ### Matching
     *
     * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.
     * This is a "fuzzy match" which uses [[StateService.includes]].
     *
     * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).
     * This is an "exact match" which uses [[StateService.is]].
     *
     * ### Parameter values
     * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.
     * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.
     *
     * #### Example:
     * ```html
     * <li ng-repeat="user in users" ui-sref-active="active">
     *   <a ui-sref="user.details({ userId: user.id })">{{ user.lastName }}</a>
     * </li>
     * ```
     *
     * ### Examples
     *
     * Given the following template:
     * #### Example:
     * ```html
     * <ul>
     *   <li ui-sref-active="active" class="item">
     *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
     *   </li>
     * </ul>
     * ```
     *
     * When the app state is `app.user` (or any child state),
     * and contains the state parameter "user" with value "bilbobaggins",
     * the resulting HTML will appear as (note the 'active' class):
     *
     * ```html
     * <ul>
     *   <li ui-sref-active="active" class="item active">
     *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
     *   </li>
     * </ul>
     * ```
     *
     * ### Glob mode
     *
     * It is possible to pass `ui-sref-active` an expression that evaluates to an object.
     * The objects keys represent active class names and values represent the respective state names/globs.
     * `ui-sref-active` will match if the current active state **includes** any of
     * the specified state names/globs, even the abstract ones.
     *
     * #### Example:
     * Given the following template, with "admin" being an abstract state:
     * ```html
     * <div ui-sref-active="{'active': 'admin.**'}">
     *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
     * </div>
     * ```
     *
     * Arrays are also supported as values in the `ngClass`-like interface.
     * This allows multiple states to add `active` class.
     *
     * #### Example:
     * Given the following template, with "admin.roles" being the current state, the class will be added too:
     * ```html
     * <div ui-sref-active="{'active': ['owner.**', 'admin.**']}">
     *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
     * </div>
     * ```
     *
     * When the current state is "admin.roles" the "active" class will be applied to both the `<div>` and `<a>` elements.
     * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.
     *
     * ### Notes:
     *
     * - The class name is interpolated **once** during the directives link time (any further changes to the
     * interpolated value are ignored).
     *
     * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`
     */
    var uiSrefActiveDirective;
    uiSrefActiveDirective = [
        '$state',
        '$stateParams',
        '$interpolate',
        '$uiRouter',
        function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {
            return {
                restrict: 'A',
                controller: [
                    '$scope',
                    '$element',
                    '$attrs',
                    function ($scope, $element, $attrs) {
                        var states = [];
                        var activeEqClass;
                        var uiSrefActive;
                        // There probably isn't much point in $observing this
                        // uiSrefActive and uiSrefActiveEq share the same directive object with some
                        // slight difference in logic routing
                        activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
                        try {
                            uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                        }
                        catch (e) {
                            // Do nothing. uiSrefActive is not a valid expression.
                            // Fall back to using $interpolate below
                        }
                        uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
                        setStatesFromDefinitionObject(uiSrefActive);
                        // Allow uiSref to communicate with uiSrefActive[Equals]
                        this.$$addStateInfo = function (newState, newParams) {
                            // we already got an explicit state provided by ui-sref-active, so we
                            // shadow the one that comes from ui-sref
                            if (core.isObject(uiSrefActive) && states.length > 0) {
                                return;
                            }
                            var deregister = addState(newState, newParams, uiSrefActive);
                            update();
                            return deregister;
                        };
                        function updateAfterTransition(trans) {
                            trans.promise.then(update, core.noop);
                        }
                        $scope.$on('$destroy', setupEventListeners());
                        if ($uiRouter.globals.transition) {
                            updateAfterTransition($uiRouter.globals.transition);
                        }
                        function setupEventListeners() {
                            var deregisterStatesChangedListener = $uiRouter.stateRegistry.onStatesChanged(handleStatesChanged);
                            var deregisterOnStartListener = $uiRouter.transitionService.onStart({}, updateAfterTransition);
                            var deregisterStateChangeSuccessListener = $scope.$on('$stateChangeSuccess', update);
                            return function cleanUp() {
                                deregisterStatesChangedListener();
                                deregisterOnStartListener();
                                deregisterStateChangeSuccessListener();
                            };
                        }
                        function handleStatesChanged() {
                            setStatesFromDefinitionObject(uiSrefActive);
                        }
                        function setStatesFromDefinitionObject(statesDefinition) {
                            if (core.isObject(statesDefinition)) {
                                states = [];
                                core.forEach(statesDefinition, function (stateOrName, activeClass) {
                                    // Helper function to abstract adding state.
                                    var addStateForClass = function (stateOrName, activeClass) {
                                        var ref = parseStateRef(stateOrName);
                                        addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                                    };
                                    if (core.isString(stateOrName)) {
                                        // If state is string, just add it.
                                        addStateForClass(stateOrName, activeClass);
                                    }
                                    else if (core.isArray(stateOrName)) {
                                        // If state is an array, iterate over it and add each array item individually.
                                        core.forEach(stateOrName, function (stateOrName) {
                                            addStateForClass(stateOrName, activeClass);
                                        });
                                    }
                                });
                            }
                        }
                        function addState(stateName, stateParams, activeClass) {
                            var state = $state.get(stateName, stateContext($element));
                            var stateInfo = {
                                state: state || { name: stateName },
                                params: stateParams,
                                activeClass: activeClass,
                            };
                            states.push(stateInfo);
                            return function removeState() {
                                core.removeFrom(states)(stateInfo);
                            };
                        }
                        // Update route state
                        function update() {
                            var splitClasses = function (str) { return str.split(/\s/).filter(core.identity); };
                            var getClasses = function (stateList) {
                                return stateList
                                    .map(function (x) { return x.activeClass; })
                                    .map(splitClasses)
                                    .reduce(core.unnestR, []);
                            };
                            var allClasses = getClasses(states)
                                .concat(splitClasses(activeEqClass))
                                .reduce(core.uniqR, []);
                            var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));
                            var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;
                            var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];
                            var addClasses = fuzzyClasses.concat(exactClasses).reduce(core.uniqR, []);
                            var removeClasses = allClasses.filter(function (cls) { return !core.inArray(addClasses, cls); });
                            $scope.$evalAsync(function () {
                                addClasses.forEach(function (className) { return $element.addClass(className); });
                                removeClasses.forEach(function (className) { return $element.removeClass(className); });
                            });
                        }
                        update();
                    },
                ],
            };
        },
    ];
    ng
        .module('ui.router.state')
        .directive('uiSref', uiSrefDirective)
        .directive('uiSrefActive', uiSrefActiveDirective)
        .directive('uiSrefActiveEq', uiSrefActiveDirective)
        .directive('uiState', uiStateDirective);

    /** @module ng1 */ /** for typedoc */
    /**
     * `isState` Filter: truthy if the current state is the parameter
     *
     * Translates to [[StateService.is]] `$state.is("stateName")`.
     *
     * #### Example:
     * ```html
     * <div ng-if="'stateName' | isState">show if state is 'stateName'</div>
     * ```
     */
    $IsStateFilter.$inject = ['$state'];
    function $IsStateFilter($state) {
        var isFilter = function (state, params, options) {
            return $state.is(state, params, options);
        };
        isFilter.$stateful = true;
        return isFilter;
    }
    /**
     * `includedByState` Filter: truthy if the current state includes the parameter
     *
     * Translates to [[StateService.includes]]` $state.is("fullOrPartialStateName")`.
     *
     * #### Example:
     * ```html
     * <div ng-if="'fullOrPartialStateName' | includedByState">show if state includes 'fullOrPartialStateName'</div>
     * ```
     */
    $IncludedByStateFilter.$inject = ['$state'];
    function $IncludedByStateFilter($state) {
        var includesFilter = function (state, params, options) {
            return $state.includes(state, params, options);
        };
        includesFilter.$stateful = true;
        return includesFilter;
    }
    ng
        .module('ui.router.state')
        .filter('isState', $IsStateFilter)
        .filter('includedByState', $IncludedByStateFilter);

    /**
     * `ui-view`: A viewport directive which is filled in by a view from the active state.
     *
     * ### Attributes
     *
     * - `name`: (Optional) A view name.
     *   The name should be unique amongst the other views in the same state.
     *   You can have views of the same name that live in different states.
     *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).
     *
     * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.
     *   Uses [[$uiViewScroll]] to do the scrolling.
     *
     * - `onload`: Expression to evaluate whenever the view updates.
     *
     * #### Example:
     * A view can be unnamed or named.
     * ```html
     * <!-- Unnamed -->
     * <div ui-view></div>
     *
     * <!-- Named -->
     * <div ui-view="viewName"></div>
     *
     * <!-- Named (different style) -->
     * <ui-view name="viewName"></ui-view>
     * ```
     *
     * You can only have one unnamed view within any template (or root html). If you are only using a
     * single view and it is unnamed then you can populate it like so:
     *
     * ```html
     * <div ui-view></div>
     * $stateProvider.state("home", {
     *   template: "<h1>HELLO!</h1>"
     * })
     * ```
     *
     * The above is a convenient shortcut equivalent to specifying your view explicitly with the
     * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:
     *
     * ```js
     * $stateProvider.state("home", {
     *   views: {
     *     "": {
     *       template: "<h1>HELLO!</h1>"
     *     }
     *   }
     * })
     * ```
     *
     * But typically you'll only use the views property if you name your view or have more than one view
     * in the same template. There's not really a compelling reason to name a view if its the only one,
     * but you could if you wanted, like so:
     *
     * ```html
     * <div ui-view="main"></div>
     * ```
     *
     * ```js
     * $stateProvider.state("home", {
     *   views: {
     *     "main": {
     *       template: "<h1>HELLO!</h1>"
     *     }
     *   }
     * })
     * ```
     *
     * Really though, you'll use views to set up multiple views:
     *
     * ```html
     * <div ui-view></div>
     * <div ui-view="chart"></div>
     * <div ui-view="data"></div>
     * ```
     *
     * ```js
     * $stateProvider.state("home", {
     *   views: {
     *     "": {
     *       template: "<h1>HELLO!</h1>"
     *     },
     *     "chart": {
     *       template: "<chart_thing/>"
     *     },
     *     "data": {
     *       template: "<data_thing/>"
     *     }
     *   }
     * })
     * ```
     *
     * #### Examples for `autoscroll`:
     * ```html
     * <!-- If autoscroll present with no expression,
     *      then scroll ui-view into view -->
     * <ui-view autoscroll/>
     *
     * <!-- If autoscroll present with valid expression,
     *      then scroll ui-view into view if expression evaluates to true -->
     * <ui-view autoscroll='true'/>
     * <ui-view autoscroll='false'/>
     * <ui-view autoscroll='scopeVariable'/>
     * ```
     *
     * Resolve data:
     *
     * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this
     * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.
     *
     * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the
     * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which
     * depends on `$resolve` data.
     *
     * #### Example:
     * ```js
     * $stateProvider.state('home', {
     *   template: '<my-component user="$resolve.user"></my-component>',
     *   resolve: {
     *     user: function(UserService) { return UserService.fetchUser(); }
     *   }
     * });
     * ```
     */
    var uiView;
    uiView = [
        '$view',
        '$animate',
        '$uiViewScroll',
        '$interpolate',
        '$q',
        function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {
            function getRenderer(attrs, scope) {
                return {
                    enter: function (element, target, cb) {
                        if (ng.version.minor > 2) {
                            $animate.enter(element, null, target).then(cb);
                        }
                        else {
                            $animate.enter(element, null, target, cb);
                        }
                    },
                    leave: function (element, cb) {
                        if (ng.version.minor > 2) {
                            $animate.leave(element).then(cb);
                        }
                        else {
                            $animate.leave(element, cb);
                        }
                    },
                };
            }
            function configsEqual(config1, config2) {
                return config1 === config2;
            }
            var rootData = {
                $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },
                $uiView: {},
            };
            var directive = {
                count: 0,
                restrict: 'ECA',
                terminal: true,
                priority: 400,
                transclude: 'element',
                compile: function (tElement, tAttrs, $transclude) {
                    return function (scope, $element, attrs) {
                        var onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';
                        var previousEl, currentEl, currentScope, viewConfig, unregister;
                        var activeUIView = {
                            $type: 'ng1',
                            id: directive.count++,
                            name: name,
                            fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + '.' + name : name,
                            config: null,
                            configUpdated: configUpdatedCallback,
                            get creationContext() {
                                // The context in which this ui-view "tag" was created
                                var fromParentTagConfig = core.parse('$cfg.viewDecl.$context')(inherited);
                                // Allow <ui-view name="foo"><ui-view name="bar"></ui-view></ui-view>
                                // See https://github.com/angular-ui/ui-router/issues/3355
                                var fromParentTag = core.parse('$uiView.creationContext')(inherited);
                                return fromParentTagConfig || fromParentTag;
                            },
                        };
                        core.trace.traceUIViewEvent('Linking', activeUIView);
                        function configUpdatedCallback(config) {
                            if (config && !(config instanceof Ng1ViewConfig))
                                return;
                            if (configsEqual(viewConfig, config))
                                return;
                            core.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);
                            viewConfig = config;
                            updateView(config);
                        }
                        $element.data('$uiView', { $uiView: activeUIView });
                        updateView();
                        unregister = $view.registerUIView(activeUIView);
                        scope.$on('$destroy', function () {
                            core.trace.traceUIViewEvent('Destroying/Unregistering', activeUIView);
                            unregister();
                        });
                        function cleanupLastView() {
                            if (previousEl) {
                                core.trace.traceUIViewEvent('Removing (previous) el', previousEl.data('$uiView'));
                                previousEl.remove();
                                previousEl = null;
                            }
                            if (currentScope) {
                                core.trace.traceUIViewEvent('Destroying scope', activeUIView);
                                currentScope.$destroy();
                                currentScope = null;
                            }
                            if (currentEl) {
                                var _viewData_1 = currentEl.data('$uiViewAnim');
                                core.trace.traceUIViewEvent('Animate out', _viewData_1);
                                renderer.leave(currentEl, function () {
                                    _viewData_1.$$animLeave.resolve();
                                    previousEl = null;
                                });
                                previousEl = currentEl;
                                currentEl = null;
                            }
                        }
                        function updateView(config) {
                            var newScope = scope.$new();
                            var animEnter = $q.defer(), animLeave = $q.defer();
                            var $uiViewData = {
                                $cfg: config,
                                $uiView: activeUIView,
                            };
                            var $uiViewAnim = {
                                $animEnter: animEnter.promise,
                                $animLeave: animLeave.promise,
                                $$animLeave: animLeave,
                            };
                            /**
                             * @ngdoc event
                             * @name ui.router.state.directive:ui-view#$viewContentLoading
                             * @eventOf ui.router.state.directive:ui-view
                             * @eventType emits on ui-view directive scope
                             * @description
                             *
                             * Fired once the view **begins loading**, *before* the DOM is rendered.
                             *
                             * @param {Object} event Event object.
                             * @param {string} viewName Name of the view.
                             */
                            newScope.$emit('$viewContentLoading', name);
                            var cloned = $transclude(newScope, function (clone) {
                                clone.data('$uiViewAnim', $uiViewAnim);
                                clone.data('$uiView', $uiViewData);
                                renderer.enter(clone, $element, function onUIViewEnter() {
                                    animEnter.resolve();
                                    if (currentScope)
                                        currentScope.$emit('$viewContentAnimationEnded');
                                    if ((core.isDefined(autoScrollExp) && !autoScrollExp) || scope.$eval(autoScrollExp)) {
                                        $uiViewScroll(clone);
                                    }
                                });
                                cleanupLastView();
                            });
                            currentEl = cloned;
                            currentScope = newScope;
                            /**
                             * @ngdoc event
                             * @name ui.router.state.directive:ui-view#$viewContentLoaded
                             * @eventOf ui.router.state.directive:ui-view
                             * @eventType emits on ui-view directive scope
                             * @description           *
                             * Fired once the view is **loaded**, *after* the DOM is rendered.
                             *
                             * @param {Object} event Event object.
                             */
                            currentScope.$emit('$viewContentLoaded', config || viewConfig);
                            currentScope.$eval(onloadExp);
                        }
                    };
                },
            };
            return directive;
        },
    ];
    $ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];
    /** @hidden */
    function $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {
        var getControllerAs = core.parse('viewDecl.controllerAs');
        var getResolveAs = core.parse('viewDecl.resolveAs');
        return {
            restrict: 'ECA',
            priority: -400,
            compile: function (tElement) {
                var initial = tElement.html();
                tElement.empty();
                return function (scope, $element) {
                    var data = $element.data('$uiView');
                    if (!data) {
                        $element.html(initial);
                        $compile($element.contents())(scope);
                        return;
                    }
                    var cfg = data.$cfg || { viewDecl: {}, getTemplate: core.noop };
                    var resolveCtx = cfg.path && new core.ResolveContext(cfg.path);
                    $element.html(cfg.getTemplate($element, resolveCtx) || initial);
                    core.trace.traceUIViewFill(data.$uiView, $element.html());
                    var link = $compile($element.contents());
                    var controller = cfg.controller;
                    var controllerAs = getControllerAs(cfg);
                    var resolveAs = getResolveAs(cfg);
                    var locals = resolveCtx && getLocals(resolveCtx);
                    scope[resolveAs] = locals;
                    if (controller) {
                        var controllerInstance = $controller(controller, core.extend({}, locals, { $scope: scope, $element: $element }));
                        if (controllerAs) {
                            scope[controllerAs] = controllerInstance;
                            scope[controllerAs][resolveAs] = locals;
                        }
                        // TODO: Use $view service as a central point for registering component-level hooks
                        // Then, when a component is created, tell the $view service, so it can invoke hooks
                        // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });
                        // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));
                        $element.data('$ngControllerController', controllerInstance);
                        $element.children().data('$ngControllerController', controllerInstance);
                        registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);
                    }
                    // Wait for the component to appear in the DOM
                    if (core.isString(cfg.viewDecl.component)) {
                        var cmp_1 = cfg.viewDecl.component;
                        var kebobName = core.kebobString(cmp_1);
                        var tagRegexp_1 = new RegExp("^(x-|data-)?" + kebobName + "$", 'i');
                        var getComponentController = function () {
                            var directiveEl = [].slice
                                .call($element[0].children)
                                .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });
                            return directiveEl && ng.element(directiveEl).data("$" + cmp_1 + "Controller");
                        };
                        var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {
                            if (!ctrlInstance)
                                return;
                            registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);
                            deregisterWatch_1();
                        });
                    }
                    link(scope);
                };
            },
        };
    }
    /** @hidden */
    var hasComponentImpl = typeof ng.module('ui.router')['component'] === 'function';
    /** @hidden incrementing id */
    var _uiCanExitId = 0;
    /** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */
    function registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {
        // Call $onInit() ASAP
        if (core.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {
            controllerInstance.$onInit();
        }
        var viewState = core.tail(cfg.path).state.self;
        var hookOptions = { bind: controllerInstance };
        // Add component-level hook for onUiParamsChanged
        if (core.isFunction(controllerInstance.uiOnParamsChanged)) {
            var resolveContext = new core.ResolveContext(cfg.path);
            var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;
            // Fire callback on any successful transition
            var paramsUpdated = function ($transition$) {
                // Exit early if the $transition$ is the same as the view was created within.
                // Exit early if the $transition$ will exit the state the view is for.
                if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)
                    return;
                var toParams = $transition$.params('to');
                var fromParams = $transition$.params('from');
                var getNodeSchema = function (node) { return node.paramSchema; };
                var toSchema = $transition$
                    .treeChanges('to')
                    .map(getNodeSchema)
                    .reduce(core.unnestR, []);
                var fromSchema = $transition$
                    .treeChanges('from')
                    .map(getNodeSchema)
                    .reduce(core.unnestR, []);
                // Find the to params that have different values than the from params
                var changedToParams = toSchema.filter(function (param) {
                    var idx = fromSchema.indexOf(param);
                    return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);
                });
                // Only trigger callback if a to param has changed or is new
                if (changedToParams.length) {
                    var changedKeys_1 = changedToParams.map(function (x) { return x.id; });
                    // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.
                    var newValues = core.filter(toParams, function (val, key) { return changedKeys_1.indexOf(key) !== -1; });
                    controllerInstance.uiOnParamsChanged(newValues, $transition$);
                }
            };
            $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));
        }
        // Add component-level hook for uiCanExit
        if (core.isFunction(controllerInstance.uiCanExit)) {
            var id_1 = _uiCanExitId++;
            var cacheProp_1 = '_uiCanExitIds';
            // Returns true if a redirect transition already answered truthy
            var prevTruthyAnswer_1 = function (trans) {
                return !!trans && ((trans[cacheProp_1] && trans[cacheProp_1][id_1] === true) || prevTruthyAnswer_1(trans.redirectedFrom()));
            };
            // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition
            var wrappedHook = function (trans) {
                var promise;
                var ids = (trans[cacheProp_1] = trans[cacheProp_1] || {});
                if (!prevTruthyAnswer_1(trans)) {
                    promise = $q.when(controllerInstance.uiCanExit(trans));
                    promise.then(function (val) { return (ids[id_1] = val !== false); });
                }
                return promise;
            };
            var criteria = { exiting: viewState.name };
            $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));
        }
    }
    ng.module('ui.router.state').directive('uiView', uiView);
    ng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

    /** @module ng1 */ /** */
    /** @hidden */
    function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function () {
            useAnchorScroll = true;
        };
        this.$get = [
            '$anchorScroll',
            '$timeout',
            function ($anchorScroll, $timeout) {
                if (useAnchorScroll) {
                    return $anchorScroll;
                }
                return function ($element) {
                    return $timeout(function () {
                        $element[0].scrollIntoView();
                    }, 0, false);
                };
            },
        ];
    }
    ng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

    /**
     * Main entry point for angular 1.x build
     * @module ng1
     */ /** */
    var index = 'ui.router';

    Object.keys(core).forEach(function (key) { exports[key] = core[key]; });
    exports.core = core;
    exports.default = index;
    exports.watchDigests = watchDigests;
    exports.getLocals = getLocals;
    exports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;
    exports.ng1ViewsBuilder = ng1ViewsBuilder;
    exports.Ng1ViewConfig = Ng1ViewConfig;
    exports.StateProvider = StateProvider;
    exports.UrlRouterProvider = UrlRouterProvider;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ui-router-angularjs.js.map


/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/common.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/common.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Random utility functions used in the UI-Router code
 *
 * These functions are exported, but are subject to change without notice.
 *
 * @preferred
 * @module common
 */
/** for typedoc */
var predicates_1 = __webpack_require__(/*! ./predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var hof_1 = __webpack_require__(/*! ./hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var coreservices_1 = __webpack_require__(/*! ./coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
exports.root = (typeof self === 'object' && self.self === self && self) ||
    (typeof global === 'object' && global.global === global && global) ||
    this;
var angular = exports.root.angular || {};
exports.fromJson = angular.fromJson || JSON.parse.bind(JSON);
exports.toJson = angular.toJson || JSON.stringify.bind(JSON);
exports.forEach = angular.forEach || _forEach;
exports.extend = Object.assign || _extend;
exports.equals = angular.equals || _equals;
function identity(x) {
    return x;
}
exports.identity = identity;
function noop() { }
exports.noop = noop;
/**
 * Builds proxy functions on the `to` object which pass through to the `from` object.
 *
 * For each key in `fnNames`, creates a proxy function on the `to` object.
 * The proxy function calls the real function on the `from` object.
 *
 *
 * #### Example:
 * This example creates an new class instance whose functions are prebound to the new'd object.
 * ```js
 * class Foo {
 *   constructor(data) {
 *     // Binds all functions from Foo.prototype to 'this',
 *     // then copies them to 'this'
 *     bindFunctions(Foo.prototype, this, this);
 *     this.data = data;
 *   }
 *
 *   log() {
 *     console.log(this.data);
 *   }
 * }
 *
 * let myFoo = new Foo([1,2,3]);
 * var logit = myFoo.log;
 * logit(); // logs [1, 2, 3] from the myFoo 'this' instance
 * ```
 *
 * #### Example:
 * This example creates a bound version of a service function, and copies it to another object
 * ```
 *
 * var SomeService = {
 *   this.data = [3, 4, 5];
 *   this.log = function() {
 *     console.log(this.data);
 *   }
 * }
 *
 * // Constructor fn
 * function OtherThing() {
 *   // Binds all functions from SomeService to SomeService,
 *   // then copies them to 'this'
 *   bindFunctions(SomeService, this, SomeService);
 * }
 *
 * let myOtherThing = new OtherThing();
 * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'
 * ```
 *
 * @param source A function that returns the source object which contains the original functions to be bound
 * @param target A function that returns the target object which will receive the bound functions
 * @param bind A function that returns the object which the functions will be bound to
 * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)
 * @param latebind If true, the binding of the function is delayed until the first time it's invoked
 */
function createProxyFunctions(source, target, bind, fnNames, latebind) {
    if (latebind === void 0) { latebind = false; }
    var bindFunction = function (fnName) { return source()[fnName].bind(bind()); };
    var makeLateRebindFn = function (fnName) {
        return function lateRebindFunction() {
            target[fnName] = bindFunction(fnName);
            return target[fnName].apply(null, arguments);
        };
    };
    fnNames = fnNames || Object.keys(source());
    return fnNames.reduce(function (acc, name) {
        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);
        return acc;
    }, target);
}
exports.createProxyFunctions = createProxyFunctions;
/**
 * prototypal inheritance helper.
 * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it
 */
exports.inherit = function (parent, extra) { return exports.extend(Object.create(parent), extra); };
/** Given an array, returns true if the object is found in the array, (using indexOf) */
exports.inArray = hof_1.curry(_inArray);
function _inArray(array, obj) {
    return array.indexOf(obj) !== -1;
}
exports._inArray = _inArray;
/**
 * Given an array, and an item, if the item is found in the array, it removes it (in-place).
 * The same array is returned
 */
exports.removeFrom = hof_1.curry(_removeFrom);
function _removeFrom(array, obj) {
    var idx = array.indexOf(obj);
    if (idx >= 0)
        array.splice(idx, 1);
    return array;
}
exports._removeFrom = _removeFrom;
/** pushes a values to an array and returns the value */
exports.pushTo = hof_1.curry(_pushTo);
function _pushTo(arr, val) {
    return arr.push(val), val;
}
exports._pushTo = _pushTo;
/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */
exports.deregAll = function (functions) {
    return functions.slice().forEach(function (fn) {
        typeof fn === 'function' && fn();
        exports.removeFrom(functions, fn);
    });
};
/**
 * Applies a set of defaults to an options object.  The options object is filtered
 * to only those properties of the objects in the defaultsList.
 * Earlier objects in the defaultsList take precedence when applying defaults.
 */
function defaults(opts) {
    var defaultsList = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        defaultsList[_i - 1] = arguments[_i];
    }
    var _defaultsList = defaultsList.concat({}).reverse();
    var defaultVals = exports.extend.apply(null, _defaultsList);
    return exports.extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));
}
exports.defaults = defaults;
/** Reduce function that merges each element of the list into a single object, using extend */
exports.mergeR = function (memo, item) { return exports.extend(memo, item); };
/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
    var path = [];
    // tslint:disable-next-line:forin
    for (var n in first.path) {
        if (first.path[n] !== second.path[n])
            break;
        path.push(first.path[n]);
    }
    return path;
}
exports.ancestors = ancestors;
/**
 * Return a copy of the object only containing the whitelisted properties.
 *
 * #### Example:
 * ```
 * var foo = { a: 1, b: 2, c: 3 };
 * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }
 * ```
 * @param obj the source object
 * @param propNames an Array of strings, which are the whitelisted property names
 */
function pick(obj, propNames) {
    var objCopy = {};
    for (var _prop in obj) {
        if (propNames.indexOf(_prop) !== -1) {
            objCopy[_prop] = obj[_prop];
        }
    }
    return objCopy;
}
exports.pick = pick;
/**
 * Return a copy of the object omitting the blacklisted properties.
 *
 * @example
 * ```
 *
 * var foo = { a: 1, b: 2, c: 3 };
 * var ab = omit(foo, ['a', 'b']); // { c: 3 }
 * ```
 * @param obj the source object
 * @param propNames an Array of strings, which are the blacklisted property names
 */
function omit(obj, propNames) {
    return Object.keys(obj)
        .filter(hof_1.not(exports.inArray(propNames)))
        .reduce(function (acc, key) { return ((acc[key] = obj[key]), acc); }, {});
}
exports.omit = omit;
/**
 * Maps an array, or object to a property (by name)
 */
function pluck(collection, propName) {
    return map(collection, hof_1.prop(propName));
}
exports.pluck = pluck;
/** Filters an Array or an Object's properties based on a predicate */
function filter(collection, callback) {
    var arr = predicates_1.isArray(collection), result = arr ? [] : {};
    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return (result[key] = x); };
    exports.forEach(collection, function (item, i) {
        if (callback(item, i))
            accept(item, i);
    });
    return result;
}
exports.filter = filter;
/** Finds an object from an array, or a property of an object, that matches a predicate */
function find(collection, callback) {
    var result;
    exports.forEach(collection, function (item, i) {
        if (result)
            return;
        if (callback(item, i))
            result = item;
    });
    return result;
}
exports.find = find;
/** Given an object, returns a new object, where each property is transformed by the callback function */
exports.mapObj = map;
/** Maps an array or object properties using a callback function */
function map(collection, callback, target) {
    target = target || (predicates_1.isArray(collection) ? [] : {});
    exports.forEach(collection, function (item, i) { return (target[i] = callback(item, i)); });
    return target;
}
exports.map = map;
/**
 * Given an object, return its enumerable property values
 *
 * @example
 * ```
 *
 * let foo = { a: 1, b: 2, c: 3 }
 * let vals = values(foo); // [ 1, 2, 3 ]
 * ```
 */
exports.values = function (obj) { return Object.keys(obj).map(function (key) { return obj[key]; }); };
/**
 * Reduce function that returns true if all of the values are truthy.
 *
 * @example
 * ```
 *
 * let vals = [ 1, true, {}, "hello world"];
 * vals.reduce(allTrueR, true); // true
 *
 * vals.push(0);
 * vals.reduce(allTrueR, true); // false
 * ```
 */
exports.allTrueR = function (memo, elem) { return memo && elem; };
/**
 * Reduce function that returns true if any of the values are truthy.
 *
 *  * @example
 * ```
 *
 * let vals = [ 0, null, undefined ];
 * vals.reduce(anyTrueR, true); // false
 *
 * vals.push("hello world");
 * vals.reduce(anyTrueR, true); // true
 * ```
 */
exports.anyTrueR = function (memo, elem) { return memo || elem; };
/**
 * Reduce function which un-nests a single level of arrays
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * input.reduce(unnestR, []) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
 * ```
 */
exports.unnestR = function (memo, elem) { return memo.concat(elem); };
/**
 * Reduce function which recursively un-nests all arrays
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * input.reduce(unnestR, []) // [ "a", "b", "c", "d", "double, "nested" ]
 * ```
 */
exports.flattenR = function (memo, elem) {
    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);
};
/**
 * Reduce function that pushes an object to an array, then returns the array.
 * Mostly just for [[flattenR]] and [[uniqR]]
 */
function pushR(arr, obj) {
    arr.push(obj);
    return arr;
}
exports.pushR = pushR;
/** Reduce function that filters out duplicates */
exports.uniqR = function (acc, token) { return (exports.inArray(acc, token) ? acc : pushR(acc, token)); };
/**
 * Return a new array with a single level of arrays unnested.
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * unnest(input) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
 * ```
 */
exports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };
/**
 * Return a completely flattened version of an array.
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * flatten(input) // [ "a", "b", "c", "d", "double, "nested" ]
 * ```
 */
exports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };
/**
 * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.
 * @example
 * ```
 *
 * let isNumber = (obj) => typeof(obj) === 'number';
 * let allNumbers = [ 1, 2, 3, 4, 5 ];
 * allNumbers.filter(assertPredicate(isNumber)); //OK
 *
 * let oneString = [ 1, 2, 3, 4, "5" ];
 * oneString.filter(assertPredicate(isNumber, "Not all numbers")); // throws Error(""Not all numbers"");
 * ```
 */
exports.assertPredicate = assertFn;
/**
 * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.
 * @example
 * ```
 *
 * var data = { foo: 1, bar: 2 };
 *
 * let keys = [ 'foo', 'bar' ]
 * let values = keys.map(assertMap(key => data[key], "Key not found"));
 * // values is [1, 2]
 *
 * let keys = [ 'foo', 'bar', 'baz' ]
 * let values = keys.map(assertMap(key => data[key], "Key not found"));
 * // throws Error("Key not found")
 * ```
 */
exports.assertMap = assertFn;
function assertFn(predicateOrMap, errMsg) {
    if (errMsg === void 0) { errMsg = 'assert failure'; }
    return function (obj) {
        var result = predicateOrMap(obj);
        if (!result) {
            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);
        }
        return result;
    };
}
exports.assertFn = assertFn;
/**
 * Like _.pairs: Given an object, returns an array of key/value pairs
 *
 * @example
 * ```
 *
 * pairs({ foo: "FOO", bar: "BAR }) // [ [ "foo", "FOO" ], [ "bar": "BAR" ] ]
 * ```
 */
exports.pairs = function (obj) { return Object.keys(obj).map(function (key) { return [key, obj[key]]; }); };
/**
 * Given two or more parallel arrays, returns an array of tuples where
 * each tuple is composed of [ a[i], b[i], ... z[i] ]
 *
 * @example
 * ```
 *
 * let foo = [ 0, 2, 4, 6 ];
 * let bar = [ 1, 3, 5, 7 ];
 * let baz = [ 10, 30, 50, 70 ];
 * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]
 * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]
 * ```
 */
function arrayTuples() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 0)
        return [];
    var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53 − 1 aka Number.MAX_SAFE_INTEGER
    var result = [];
    var _loop_1 = function (i) {
        // This is a hot function
        // Unroll when there are 1-4 arguments
        switch (args.length) {
            case 1:
                result.push([args[0][i]]);
                break;
            case 2:
                result.push([args[0][i], args[1][i]]);
                break;
            case 3:
                result.push([args[0][i], args[1][i], args[2][i]]);
                break;
            case 4:
                result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);
                break;
            default:
                result.push(args.map(function (array) { return array[i]; }));
                break;
        }
    };
    for (var i = 0; i < maxArrayLen; i++) {
        _loop_1(i);
    }
    return result;
}
exports.arrayTuples = arrayTuples;
/**
 * Reduce function which builds an object from an array of [key, value] pairs.
 *
 * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.
 *
 * Each keyValueTuple should be an array with values [ key: string, value: any ]
 *
 * @example
 * ```
 *
 * var pairs = [ ["fookey", "fooval"], ["barkey", "barval"] ]
 *
 * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})
 * // pairsToObj == { fookey: "fooval", barkey: "barval" }
 *
 * // Or, more simply:
 * var pairsToObj = pairs.reduce(applyPairs, {})
 * // pairsToObj == { fookey: "fooval", barkey: "barval" }
 * ```
 */
function applyPairs(memo, keyValTuple) {
    var key, value;
    if (predicates_1.isArray(keyValTuple))
        key = keyValTuple[0], value = keyValTuple[1];
    if (!predicates_1.isString(key))
        throw new Error('invalid parameters to applyPairs');
    memo[key] = value;
    return memo;
}
exports.applyPairs = applyPairs;
/** Get the last element of an array */
function tail(arr) {
    return (arr.length && arr[arr.length - 1]) || undefined;
}
exports.tail = tail;
/**
 * shallow copy from src to dest
 */
function copy(src, dest) {
    if (dest)
        Object.keys(dest).forEach(function (key) { return delete dest[key]; });
    if (!dest)
        dest = {};
    return exports.extend(dest, src);
}
exports.copy = copy;
/** Naive forEach implementation works with Objects or Arrays */
function _forEach(obj, cb, _this) {
    if (predicates_1.isArray(obj))
        return obj.forEach(cb, _this);
    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });
}
function _extend(toObj) {
    for (var i = 1; i < arguments.length; i++) {
        var obj = arguments[i];
        if (!obj)
            continue;
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; j++) {
            toObj[keys[j]] = obj[keys[j]];
        }
    }
    return toObj;
}
exports._extend = _extend;
function _equals(o1, o2) {
    if (o1 === o2)
        return true;
    if (o1 === null || o2 === null)
        return false;
    if (o1 !== o1 && o2 !== o2)
        return true; // NaN === NaN
    var t1 = typeof o1, t2 = typeof o2;
    if (t1 !== t2 || t1 !== 'object')
        return false;
    var tup = [o1, o2];
    if (hof_1.all(predicates_1.isArray)(tup))
        return _arraysEq(o1, o2);
    if (hof_1.all(predicates_1.isDate)(tup))
        return o1.getTime() === o2.getTime();
    if (hof_1.all(predicates_1.isRegExp)(tup))
        return o1.toString() === o2.toString();
    if (hof_1.all(predicates_1.isFunction)(tup))
        return true; // meh
    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];
    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))
        return false;
    var keys = {};
    // tslint:disable-next-line:forin
    for (var key in o1) {
        if (!_equals(o1[key], o2[key]))
            return false;
        keys[key] = true;
    }
    for (var key in o2) {
        if (!keys[key])
            return false;
    }
    return true;
}
function _arraysEq(a1, a2) {
    if (a1.length !== a2.length)
        return false;
    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);
}
// issue #2676
exports.silenceUncaughtInPromise = function (promise) { return promise.catch(function (e) { return 0; }) && promise; };
exports.silentRejection = function (error) { return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error)); };
//# sourceMappingURL=common.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/coreservices.js":
/*!****************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/coreservices.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.notImplemented = function (fnname) { return function () {
    throw new Error(fnname + "(): No coreservices implementation for UI-Router is loaded.");
}; };
var services = {
    $q: undefined,
    $injector: undefined,
};
exports.services = services;
//# sourceMappingURL=coreservices.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/glob.js":
/*!********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/glob.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module core
 */
/**
 * Matches state names using glob-like pattern strings.
 *
 * Globs can be used in specific APIs including:
 *
 * - [[StateService.is]]
 * - [[StateService.includes]]
 * - The first argument to Hook Registration functions like [[TransitionService.onStart]]
 *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]
 *
 * A `Glob` string is a pattern which matches state names.
 * Nested state names are split into segments (separated by a dot) when processing.
 * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']
 *
 * Globs work according to the following rules:
 *
 * ### Exact match:
 *
 * The glob `'A.B'` matches the state named exactly `'A.B'`.
 *
 * | Glob        |Matches states named|Does not match state named|
 * |:------------|:--------------------|:---------------------|
 * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |
 * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |
 * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|
 *
 * ### Single star (`*`)
 *
 * A single star (`*`) is a wildcard that matches exactly one segment.
 *
 * | Glob        |Matches states named  |Does not match state named |
 * |:------------|:---------------------|:--------------------------|
 * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |
 * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |
 * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|
 *
 * ### Double star (`**`)
 *
 * A double star (`'**'`) is a wildcard that matches *zero or more segments*
 *
 * | Glob        |Matches states named                           |Does not match state named         |
 * |:------------|:----------------------------------------------|:----------------------------------|
 * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |
 * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |
 * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |
 * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |
 *
 */
var Glob = /** @class */ (function () {
    function Glob(text) {
        this.text = text;
        this.glob = text.split('.');
        var regexpString = this.text
            .split('.')
            .map(function (seg) {
            if (seg === '**')
                return '(?:|(?:\\.[^.]*)*)';
            if (seg === '*')
                return '\\.[^.]*';
            return '\\.' + seg;
        })
            .join('');
        this.regexp = new RegExp('^' + regexpString + '$');
    }
    /** Returns true if the string has glob-like characters in it */
    Glob.is = function (text) {
        return !!/[!,*]+/.exec(text);
    };
    /** Returns a glob from the string, or null if the string isn't Glob-like */
    Glob.fromString = function (text) {
        return Glob.is(text) ? new Glob(text) : null;
    };
    Glob.prototype.matches = function (name) {
        return this.regexp.test('.' + name);
    };
    return Glob;
}());
exports.Glob = Glob;
//# sourceMappingURL=glob.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/hof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/hof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Higher order functions
 *
 * These utility functions are exported, but are subject to change without notice.
 *
 * @module common_hof
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.
 *
 * Given a function with N parameters, returns a new function that supports partial application.
 * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,
 * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to
 * accept more parameters until all N parameters have been supplied.
 *
 *
 * This contrived example uses a partially applied function as an predicate, which returns true
 * if an object is found in both arrays.
 * @example
 * ```
 * // returns true if an object is in both of the two arrays
 * function inBoth(array1, array2, object) {
 *   return array1.indexOf(object) !== -1 &&
 *          array2.indexOf(object) !== 1;
 * }
 * let obj1, obj2, obj3, obj4, obj5, obj6, obj7
 * let foos = [obj1, obj3]
 * let bars = [obj3, obj4, obj5]
 *
 * // A curried "copy" of inBoth
 * let curriedInBoth = curry(inBoth);
 * // Partially apply both the array1 and array2
 * let inFoosAndBars = curriedInBoth(foos, bars);
 *
 * // Supply the final argument; since all arguments are
 * // supplied, the original inBoth function is then called.
 * let obj1InBoth = inFoosAndBars(obj1); // false
 *
 * // Use the inFoosAndBars as a predicate.
 * // Filter, on each iteration, supplies the final argument
 * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];
 * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]
 *
 * ```
 *
 * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function
 *
 * @param fn
 * @returns {*|function(): (*|any)}
 */
function curry(fn) {
    var initial_args = [].slice.apply(arguments, [1]);
    var func_args_length = fn.length;
    function curried(args) {
        if (args.length >= func_args_length)
            return fn.apply(null, args);
        return function () {
            return curried(args.concat([].slice.apply(arguments)));
        };
    }
    return curried(initial_args);
}
exports.curry = curry;
/**
 * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left
 * given: f(x), g(x), h(x)
 * let composed = compose(f,g,h)
 * then, composed is: f(g(h(x)))
 */
function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function () {
        var i = start, result = args[start].apply(this, arguments);
        while (i--)
            result = args[i].call(this, result);
        return result;
    };
}
exports.compose = compose;
/**
 * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right
 * given: f(x), g(x), h(x)
 * let piped = pipe(f,g,h);
 * then, piped is: h(g(f(x)))
 */
function pipe() {
    var funcs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        funcs[_i] = arguments[_i];
    }
    return compose.apply(null, [].slice.call(arguments).reverse());
}
exports.pipe = pipe;
/**
 * Given a property name, returns a function that returns that property from an object
 * let obj = { foo: 1, name: "blarg" };
 * let getName = prop("name");
 * getName(obj) === "blarg"
 */
exports.prop = function (name) { return function (obj) { return obj && obj[name]; }; };
/**
 * Given a property name and a value, returns a function that returns a boolean based on whether
 * the passed object has a property that matches the value
 * let obj = { foo: 1, name: "blarg" };
 * let getName = propEq("name", "blarg");
 * getName(obj) === true
 */
exports.propEq = curry(function (name, _val, obj) { return obj && obj[name] === _val; });
/**
 * Given a dotted property name, returns a function that returns a nested property from an object, or undefined
 * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };
 * let getName = prop("nestedObj.name");
 * getName(obj) === "blarg"
 * let propNotFound = prop("this.property.doesnt.exist");
 * propNotFound(obj) === undefined
 */
exports.parse = function (name) { return pipe.apply(null, name.split('.').map(exports.prop)); };
/**
 * Given a function that returns a truthy or falsey value, returns a
 * function that returns the opposite (falsey or truthy) value given the same inputs
 */
exports.not = function (fn) { return function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return !fn.apply(null, args);
}; };
/**
 * Given two functions that return truthy or falsey values, returns a function that returns truthy
 * if both functions return truthy for the given arguments
 */
function and(fn1, fn2) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return fn1.apply(null, args) && fn2.apply(null, args);
    };
}
exports.and = and;
/**
 * Given two functions that return truthy or falsey values, returns a function that returns truthy
 * if at least one of the functions returns truthy for the given arguments
 */
function or(fn1, fn2) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return fn1.apply(null, args) || fn2.apply(null, args);
    };
}
exports.or = or;
/**
 * Check if all the elements of an array match a predicate function
 *
 * @param fn1 a predicate function `fn1`
 * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array
 */
exports.all = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); }; };
// tslint:disable-next-line:variable-name
exports.any = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); }; };
/** Given a class, returns a Predicate function that returns true if the object is of that class */
exports.is = function (ctor) { return function (obj) {
    return (obj != null && obj.constructor === ctor) || obj instanceof ctor;
}; };
/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */
exports.eq = function (value) { return function (other) { return value === other; }; };
/** Given a value, returns a function which returns the value */
exports.val = function (v) { return function () { return v; }; };
function invoke(fnName, args) {
    return function (obj) { return obj[fnName].apply(obj, args); };
}
exports.invoke = invoke;
/**
 * Sorta like Pattern Matching (a functional programming conditional construct)
 *
 * See http://c2.com/cgi/wiki?PatternMatching
 *
 * This is a conditional construct which allows a series of predicates and output functions
 * to be checked and then applied.  Each predicate receives the input.  If the predicate
 * returns truthy, then its matching output function (mapping function) is provided with
 * the input and, then the result is returned.
 *
 * Each combination (2-tuple) of predicate + output function should be placed in an array
 * of size 2: [ predicate, mapFn ]
 *
 * These 2-tuples should be put in an outer array.
 *
 * @example
 * ```
 *
 * // Here's a 2-tuple where the first element is the isString predicate
 * // and the second element is a function that returns a description of the input
 * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];
 *
 * // Second tuple: predicate "isNumber", mapfn returns a description
 * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];
 *
 * let third = [ (input) => input === null,  (input) => `Oh, null...` ];
 *
 * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];
 *
 * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);
 *
 * console.log(descriptionOf(undefined)); // 'notdefined'
 * console.log(descriptionOf(55)); // '(55) That's a number!'
 * console.log(descriptionOf("foo")); // 'Here's your string foo'
 * ```
 *
 * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,
 * with a Predicate and a mapping/output function
 * @returns {function(any): *}
 */
function pattern(struct) {
    return function (x) {
        for (var i = 0; i < struct.length; i++) {
            if (struct[i][0](x))
                return struct[i][1](x);
        }
    };
}
exports.pattern = pattern;
//# sourceMappingURL=hof.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module common */ /** for typedoc */
__export(__webpack_require__(/*! ./common */ "./node_modules/@uirouter/core/lib/common/common.js"));
__export(__webpack_require__(/*! ./coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js"));
__export(__webpack_require__(/*! ./glob */ "./node_modules/@uirouter/core/lib/common/glob.js"));
__export(__webpack_require__(/*! ./hof */ "./node_modules/@uirouter/core/lib/common/hof.js"));
__export(__webpack_require__(/*! ./predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js"));
__export(__webpack_require__(/*! ./queue */ "./node_modules/@uirouter/core/lib/common/queue.js"));
__export(__webpack_require__(/*! ./strings */ "./node_modules/@uirouter/core/lib/common/strings.js"));
__export(__webpack_require__(/*! ./trace */ "./node_modules/@uirouter/core/lib/common/trace.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/predicates.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/predicates.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** Predicates
 *
 * These predicates return true/false based on the input.
 * Although these functions are exported, they are subject to change without notice.
 *
 * @module common_predicates
 */
/** */
var hof_1 = __webpack_require__(/*! ./hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var stateObject_1 = __webpack_require__(/*! ../state/stateObject */ "./node_modules/@uirouter/core/lib/state/stateObject.js");
var toStr = Object.prototype.toString;
var tis = function (t) { return function (x) { return typeof x === t; }; };
exports.isUndefined = tis('undefined');
exports.isDefined = hof_1.not(exports.isUndefined);
exports.isNull = function (o) { return o === null; };
exports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);
exports.isFunction = tis('function');
exports.isNumber = tis('number');
exports.isString = tis('string');
exports.isObject = function (x) { return x !== null && typeof x === 'object'; };
exports.isArray = Array.isArray;
exports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });
exports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });
exports.isState = stateObject_1.StateObject.isState;
/**
 * Predicate which checks if a value is injectable
 *
 * A value is "injectable" if it is a function, or if it is an ng1 array-notation-style array
 * where all the elements in the array are Strings, except the last one, which is a Function
 */
function isInjectable(val) {
    if (exports.isArray(val) && val.length) {
        var head = val.slice(0, -1), tail = val.slice(-1);
        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);
    }
    return exports.isFunction(val);
}
exports.isInjectable = isInjectable;
/**
 * Predicate which checks if a value looks like a Promise
 *
 * It is probably a Promise if it's an object, and it has a `then` property which is a Function
 */
exports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));
//# sourceMappingURL=predicates.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/queue.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/queue.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module common */
var common_1 = __webpack_require__(/*! ./common */ "./node_modules/@uirouter/core/lib/common/common.js");
var Queue = /** @class */ (function () {
    function Queue(_items, _limit) {
        if (_items === void 0) { _items = []; }
        if (_limit === void 0) { _limit = null; }
        this._items = _items;
        this._limit = _limit;
        this._evictListeners = [];
        this.onEvict = common_1.pushTo(this._evictListeners);
    }
    Queue.prototype.enqueue = function (item) {
        var items = this._items;
        items.push(item);
        if (this._limit && items.length > this._limit)
            this.evict();
        return item;
    };
    Queue.prototype.evict = function () {
        var item = this._items.shift();
        this._evictListeners.forEach(function (fn) { return fn(item); });
        return item;
    };
    Queue.prototype.dequeue = function () {
        if (this.size())
            return this._items.splice(0, 1)[0];
    };
    Queue.prototype.clear = function () {
        var current = this._items;
        this._items = [];
        return current;
    };
    Queue.prototype.size = function () {
        return this._items.length;
    };
    Queue.prototype.remove = function (item) {
        var idx = this._items.indexOf(item);
        return idx > -1 && this._items.splice(idx, 1)[0];
    };
    Queue.prototype.peekTail = function () {
        return this._items[this._items.length - 1];
    };
    Queue.prototype.peekHead = function () {
        if (this.size())
            return this._items[0];
    };
    return Queue;
}());
exports.Queue = Queue;
//# sourceMappingURL=queue.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/strings.js":
/*!***********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/strings.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Functions that manipulate strings
 *
 * Although these functions are exported, they are subject to change without notice.
 *
 * @module common_strings
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var predicates_1 = __webpack_require__(/*! ./predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var rejectFactory_1 = __webpack_require__(/*! ../transition/rejectFactory */ "./node_modules/@uirouter/core/lib/transition/rejectFactory.js");
var common_1 = __webpack_require__(/*! ./common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ./hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var transition_1 = __webpack_require__(/*! ../transition/transition */ "./node_modules/@uirouter/core/lib/transition/transition.js");
var resolvable_1 = __webpack_require__(/*! ../resolve/resolvable */ "./node_modules/@uirouter/core/lib/resolve/resolvable.js");
/**
 * Returns a string shortened to a maximum length
 *
 * If the string is already less than the `max` length, return the string.
 * Else return the string, shortened to `max - 3` and append three dots ("...").
 *
 * @param max the maximum length of the string to return
 * @param str the input string
 */
function maxLength(max, str) {
    if (str.length <= max)
        return str;
    return str.substr(0, max - 3) + '...';
}
exports.maxLength = maxLength;
/**
 * Returns a string, with spaces added to the end, up to a desired str length
 *
 * If the string is already longer than the desired length, return the string.
 * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.
 *
 * @param length the desired length of the string to return
 * @param str the input string
 */
function padString(length, str) {
    while (str.length < length)
        str += ' ';
    return str;
}
exports.padString = padString;
function kebobString(camelCase) {
    return camelCase
        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char
        .replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); }); // replace rest
}
exports.kebobString = kebobString;
function _toJson(obj) {
    return JSON.stringify(obj);
}
function _fromJson(json) {
    return predicates_1.isString(json) ? JSON.parse(json) : json;
}
function promiseToString(p) {
    return "Promise(" + JSON.stringify(p) + ")";
}
function functionToString(fn) {
    var fnStr = fnToString(fn);
    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);
    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;
    var fnName = fn['name'] || '';
    if (fnName && toStr.match(/function \(/)) {
        return 'function ' + fnName + toStr.substr(9);
    }
    return toStr;
}
exports.functionToString = functionToString;
function fnToString(fn) {
    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;
    return (_fn && _fn.toString()) || 'undefined';
}
exports.fnToString = fnToString;
var stringifyPatternFn = null;
var stringifyPattern = function (value) {
    var isRejection = rejectFactory_1.Rejection.isRejectionPromise;
    stringifyPatternFn =
        stringifyPatternFn ||
            hof_1.pattern([
                [hof_1.not(predicates_1.isDefined), hof_1.val('undefined')],
                [predicates_1.isNull, hof_1.val('null')],
                [predicates_1.isPromise, hof_1.val('[Promise]')],
                [isRejection, function (x) { return x._transitionRejection.toString(); }],
                [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke('toString')],
                [hof_1.is(transition_1.Transition), hof_1.invoke('toString')],
                [hof_1.is(resolvable_1.Resolvable), hof_1.invoke('toString')],
                [predicates_1.isInjectable, functionToString],
                [hof_1.val(true), common_1.identity],
            ]);
    return stringifyPatternFn(value);
};
function stringify(o) {
    var seen = [];
    function format(value) {
        if (predicates_1.isObject(value)) {
            if (seen.indexOf(value) !== -1)
                return '[circular ref]';
            seen.push(value);
        }
        return stringifyPattern(value);
    }
    return JSON.stringify(o, function (key, value) { return format(value); }).replace(/\\"/g, '"');
}
exports.stringify = stringify;
/** Returns a function that splits a string on a character or substring */
exports.beforeAfterSubstr = function (char) { return function (str) {
    if (!str)
        return ['', ''];
    var idx = str.indexOf(char);
    if (idx === -1)
        return [str, ''];
    return [str.substr(0, idx), str.substr(idx + 1)];
}; };
exports.hostRegex = new RegExp('^(?:[a-z]+:)?//[^/]+/');
exports.stripLastPathElement = function (str) { return str.replace(/\/[^/]*$/, ''); };
exports.splitHash = exports.beforeAfterSubstr('#');
exports.splitQuery = exports.beforeAfterSubstr('?');
exports.splitEqual = exports.beforeAfterSubstr('=');
exports.trimHashVal = function (str) { return (str ? str.replace(/^#/, '') : ''); };
/**
 * Splits on a delimiter, but returns the delimiters in the array
 *
 * #### Example:
 * ```js
 * var splitOnSlashes = splitOnDelim('/');
 * splitOnSlashes("/foo"); // ["/", "foo"]
 * splitOnSlashes("/foo/"); // ["/", "foo", "/"]
 * ```
 */
function splitOnDelim(delim) {
    var re = new RegExp('(' + delim + ')', 'g');
    return function (str) { return str.split(re).filter(common_1.identity); };
}
exports.splitOnDelim = splitOnDelim;
/**
 * Reduce fn that joins neighboring strings
 *
 * Given an array of strings, returns a new array
 * where all neighboring strings have been joined.
 *
 * #### Example:
 * ```js
 * let arr = ["foo", "bar", 1, "baz", "", "qux" ];
 * arr.reduce(joinNeighborsR, []) // ["foobar", 1, "bazqux" ]
 * ```
 */
function joinNeighborsR(acc, x) {
    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))
        return acc.slice(0, -1).concat(common_1.tail(acc) + x);
    return common_1.pushR(acc, x);
}
exports.joinNeighborsR = joinNeighborsR;
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/common/trace.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/common/trace.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * # Transition tracing (debug)
 *
 * Enable transition tracing to print transition information to the console,
 * in order to help debug your application.
 * Tracing logs detailed information about each Transition to your console.
 *
 * To enable tracing, import the [[Trace]] singleton and enable one or more categories.
 *
 * ### ES6
 * ```js
 * import {trace} from "@uirouter/core";
 * trace.enable(1, 5); // TRANSITION and VIEWCONFIG
 * ```
 *
 * ### CJS
 * ```js
 * let trace = require("@uirouter/core").trace;
 * trace.enable("TRANSITION", "VIEWCONFIG");
 * ```
 *
 * ### Globals
 * ```js
 * let trace = window["@uirouter/core"].trace;
 * trace.enable(); // Trace everything (very verbose)
 * ```
 *
 * ### Angular 1:
 * ```js
 * app.run($trace => $trace.enable());
 * ```
 *
 * @coreapi
 * @module trace
 */
/* tslint:disable:no-console */
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var strings_1 = __webpack_require__(/*! ./strings */ "./node_modules/@uirouter/core/lib/common/strings.js");
/** @hidden */
function uiViewString(uiview) {
    if (!uiview)
        return 'ui-view (defunct)';
    var state = uiview.creationContext ? uiview.creationContext.name || '(root)' : '(none)';
    return "[ui-view#" + uiview.id + " " + uiview.$type + ":" + uiview.fqn + " (" + uiview.name + "@" + state + ")]";
}
/** @hidden */
var viewConfigString = function (viewConfig) {
    var view = viewConfig.viewDecl;
    var state = view.$context.name || '(root)';
    return "[View#" + viewConfig.$id + " from '" + state + "' state]: target ui-view: '" + view.$uiViewName + "@" + view.$uiViewContextAnchor + "'";
};
/** @hidden */
function normalizedCat(input) {
    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];
}
/** @hidden */
var consoleLog = Function.prototype.bind.call(console.log, console);
/** @hidden */
var consoletable = predicates_1.isFunction(console.table) ? console.table.bind(console) : consoleLog.bind(console);
/**
 * Trace categories Enum
 *
 * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]
 *
 * `trace.enable(Category.TRANSITION)`
 *
 * These can also be provided using a matching string, or position ordinal
 *
 * `trace.enable("TRANSITION")`
 *
 * `trace.enable(1)`
 */
var Category;
(function (Category) {
    Category[Category["RESOLVE"] = 0] = "RESOLVE";
    Category[Category["TRANSITION"] = 1] = "TRANSITION";
    Category[Category["HOOK"] = 2] = "HOOK";
    Category[Category["UIVIEW"] = 3] = "UIVIEW";
    Category[Category["VIEWCONFIG"] = 4] = "VIEWCONFIG";
})(Category = exports.Category || (exports.Category = {}));
/** @hidden */
var _tid = hof_1.parse('$id');
/** @hidden */
var _rid = hof_1.parse('router.$id');
/** @hidden */
var transLbl = function (trans) { return "Transition #" + _tid(trans) + "-" + _rid(trans); };
/**
 * Prints UI-Router Transition trace information to the console.
 */
var Trace = /** @class */ (function () {
    /** @hidden */
    function Trace() {
        /** @hidden */
        this._enabled = {};
        this.approximateDigests = 0;
    }
    /** @hidden */
    Trace.prototype._set = function (enabled, categories) {
        var _this = this;
        if (!categories.length) {
            categories = Object.keys(Category)
                .map(function (k) { return parseInt(k, 10); })
                .filter(function (k) { return !isNaN(k); })
                .map(function (key) { return Category[key]; });
        }
        categories.map(normalizedCat).forEach(function (category) { return (_this._enabled[category] = enabled); });
    };
    Trace.prototype.enable = function () {
        var categories = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            categories[_i] = arguments[_i];
        }
        this._set(true, categories);
    };
    Trace.prototype.disable = function () {
        var categories = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            categories[_i] = arguments[_i];
        }
        this._set(false, categories);
    };
    /**
     * Retrieves the enabled stateus of a [[Category]]
     *
     * ```js
     * trace.enabled("VIEWCONFIG"); // true or false
     * ```
     *
     * @returns boolean true if the category is enabled
     */
    Trace.prototype.enabled = function (category) {
        return !!this._enabled[normalizedCat(category)];
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceTransitionStart = function (trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": Started  -> " + strings_1.stringify(trans));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceTransitionIgnored = function (trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": Ignored  <> " + strings_1.stringify(trans));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceHookInvocation = function (step, trans, options) {
        if (!this.enabled(Category.HOOK))
            return;
        var event = hof_1.parse('traceData.hookType')(options) || 'internal', context = hof_1.parse('traceData.context.state.name')(options) || hof_1.parse('traceData.context')(options) || 'unknown', name = strings_1.functionToString(step.registeredHook.callback);
        console.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + strings_1.maxLength(200, name));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {
        if (!this.enabled(Category.HOOK))
            return;
        console.log(transLbl(trans) + ":   <- Hook returned: " + strings_1.maxLength(200, strings_1.stringify(hookResult)));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceResolvePath = function (path, when, trans) {
        if (!this.enabled(Category.RESOLVE))
            return;
        console.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")");
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {
        if (!this.enabled(Category.RESOLVE))
            return;
        console.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + strings_1.maxLength(200, strings_1.stringify(resolvable.data)));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceError = function (reason, trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": <- Rejected " + strings_1.stringify(trans) + ", reason: " + reason);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceSuccess = function (finalState, trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": <- Success  " + strings_1.stringify(trans) + ", final state: " + finalState.name);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {
        if (extra === void 0) { extra = ''; }
        if (!this.enabled(Category.UIVIEW))
            return;
        console.log("ui-view: " + strings_1.padString(30, event) + " " + uiViewString(viewData) + extra);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {
        if (!this.enabled(Category.UIVIEW))
            return;
        this.traceUIViewEvent('Updating', viewData, " with ViewConfig from context='" + context + "'");
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceUIViewFill = function (viewData, html) {
        if (!this.enabled(Category.UIVIEW))
            return;
        this.traceUIViewEvent('Fill', viewData, " with: " + strings_1.maxLength(200, html));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceViewSync = function (pairs) {
        if (!this.enabled(Category.VIEWCONFIG))
            return;
        var uivheader = 'uiview component fqn';
        var cfgheader = 'view config state (view name)';
        var mapping = pairs
            .map(function (_a) {
            var uiView = _a.uiView, viewConfig = _a.viewConfig;
            var uiv = uiView && uiView.fqn;
            var cfg = viewConfig && viewConfig.viewDecl.$context.name + ": (" + viewConfig.viewDecl.$name + ")";
            return _b = {}, _b[uivheader] = uiv, _b[cfgheader] = cfg, _b;
            var _b;
        })
            .sort(function (a, b) { return (a[uivheader] || '').localeCompare(b[uivheader] || ''); });
        consoletable(mapping);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {
        if (!this.enabled(Category.VIEWCONFIG))
            return;
        console.log("VIEWCONFIG: " + event + " " + viewConfigString(viewConfig));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {
        if (!this.enabled(Category.VIEWCONFIG))
            return;
        console.log("VIEWCONFIG: " + event + " " + uiViewString(viewData));
    };
    return Trace;
}());
exports.Trace = Trace;
/**
 * The [[Trace]] singleton
 *
 * #### Example:
 * ```js
 * import {trace} from "@uirouter/core";
 * trace.enable(1, 5);
 * ```
 */
var trace = new Trace();
exports.trace = trace;
//# sourceMappingURL=trace.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/globals.js":
/*!****************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/globals.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module core
 */ /** */
var stateParams_1 = __webpack_require__(/*! ./params/stateParams */ "./node_modules/@uirouter/core/lib/params/stateParams.js");
var queue_1 = __webpack_require__(/*! ./common/queue */ "./node_modules/@uirouter/core/lib/common/queue.js");
/**
 * Global router state
 *
 * This is where we hold the global mutable state such as current state, current
 * params, current transition, etc.
 */
var UIRouterGlobals = /** @class */ (function () {
    function UIRouterGlobals() {
        /**
         * Current parameter values
         *
         * The parameter values from the latest successful transition
         */
        this.params = new stateParams_1.StateParams();
        /** @internalapi */
        this.lastStartedTransitionId = -1;
        /** @internalapi */
        this.transitionHistory = new queue_1.Queue([], 1);
        /** @internalapi */
        this.successfulTransitions = new queue_1.Queue([], 1);
    }
    UIRouterGlobals.prototype.dispose = function () {
        this.transitionHistory.clear();
        this.successfulTransitions.clear();
        this.transition = null;
    };
    return UIRouterGlobals;
}());
exports.UIRouterGlobals = UIRouterGlobals;
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/coreResolvables.js":
/*!******************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/coreResolvables.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */ /** */
var transition_1 = __webpack_require__(/*! ../transition/transition */ "./node_modules/@uirouter/core/lib/transition/transition.js");
var router_1 = __webpack_require__(/*! ../router */ "./node_modules/@uirouter/core/lib/router.js");
var resolve_1 = __webpack_require__(/*! ../resolve */ "./node_modules/@uirouter/core/lib/resolve/index.js");
var common_1 = __webpack_require__(/*! ../common */ "./node_modules/@uirouter/core/lib/common/index.js");
function addCoreResolvables(trans) {
    trans.addResolvable(resolve_1.Resolvable.fromData(router_1.UIRouter, trans.router), '');
    trans.addResolvable(resolve_1.Resolvable.fromData(transition_1.Transition, trans), '');
    trans.addResolvable(resolve_1.Resolvable.fromData('$transition$', trans), '');
    trans.addResolvable(resolve_1.Resolvable.fromData('$stateParams', trans.params()), '');
    trans.entering().forEach(function (state) {
        trans.addResolvable(resolve_1.Resolvable.fromData('$state$', state), state);
    });
}
exports.registerAddCoreResolvables = function (transitionService) {
    return transitionService.onCreate({}, addCoreResolvables);
};
var TRANSITION_TOKENS = ['$transition$', transition_1.Transition];
var isTransition = common_1.inArray(TRANSITION_TOKENS);
// References to Transition in the treeChanges pathnodes makes all
// previous Transitions reachable in memory, causing a memory leak
// This function removes resolves for '$transition$' and `Transition` from the treeChanges.
// Do not use this on current transitions, only on old ones.
exports.treeChangesCleanup = function (trans) {
    var nodes = common_1.values(trans.treeChanges())
        .reduce(common_1.unnestR, [])
        .reduce(common_1.uniqR, []);
    // If the resolvable is a Transition, return a new resolvable with null data
    var replaceTransitionWithNull = function (r) {
        return isTransition(r.token) ? resolve_1.Resolvable.fromData(r.token, null) : r;
    };
    nodes.forEach(function (node) {
        node.resolvables = node.resolvables.map(replaceTransitionWithNull);
    });
};
//# sourceMappingURL=coreResolvables.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/ignoredTransition.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/ignoredTransition.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module hooks */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var trace_1 = __webpack_require__(/*! ../common/trace */ "./node_modules/@uirouter/core/lib/common/trace.js");
var rejectFactory_1 = __webpack_require__(/*! ../transition/rejectFactory */ "./node_modules/@uirouter/core/lib/transition/rejectFactory.js");
/**
 * A [[TransitionHookFn]] that skips a transition if it should be ignored
 *
 * This hook is invoked at the end of the onBefore phase.
 *
 * If the transition should be ignored (because no parameter or states changed)
 * then the transition is ignored and not processed.
 */
function ignoredHook(trans) {
    var ignoredReason = trans._ignoredReason();
    if (!ignoredReason)
        return;
    trace_1.trace.traceTransitionIgnored(trans);
    var pending = trans.router.globals.transition;
    // The user clicked a link going back to the *current state* ('A')
    // However, there is also a pending transition in flight (to 'B')
    // Abort the transition to 'B' because the user now wants to be back at 'A'.
    if (ignoredReason === 'SameAsCurrent' && pending) {
        pending.abort();
    }
    return rejectFactory_1.Rejection.ignored().toPromise();
}
exports.registerIgnoredTransitionHook = function (transitionService) {
    return transitionService.onBefore({}, ignoredHook, { priority: -9999 });
};
//# sourceMappingURL=ignoredTransition.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/invalidTransition.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/invalidTransition.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module hooks */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A [[TransitionHookFn]] that rejects the Transition if it is invalid
 *
 * This hook is invoked at the end of the onBefore phase.
 * If the transition is invalid (for example, param values do not validate)
 * then the transition is rejected.
 */
function invalidTransitionHook(trans) {
    if (!trans.valid()) {
        throw new Error(trans.error().toString());
    }
}
exports.registerInvalidTransitionHook = function (transitionService) {
    return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });
};
//# sourceMappingURL=invalidTransition.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/lazyLoad.js":
/*!***********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/lazyLoad.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
/**
 * A [[TransitionHookFn]] that performs lazy loading
 *
 * When entering a state "abc" which has a `lazyLoad` function defined:
 * - Invoke the `lazyLoad` function (unless it is already in process)
 *   - Flag the hook function as "in process"
 *   - The function should return a promise (that resolves when lazy loading is complete)
 * - Wait for the promise to settle
 *   - If the promise resolves to a [[LazyLoadResult]], then register those states
 *   - Flag the hook function as "not in process"
 * - If the hook was successful
 *   - Remove the `lazyLoad` function from the state declaration
 * - If all the hooks were successful
 *   - Retry the transition (by returning a TargetState)
 *
 * ```
 * .state('abc', {
 *   component: 'fooComponent',
 *   lazyLoad: () => System.import('./fooComponent')
 *   });
 * ```
 *
 * See [[StateDeclaration.lazyLoad]]
 */
var lazyLoadHook = function (transition) {
    var router = transition.router;
    function retryTransition() {
        if (transition.originalTransition().options().source !== 'url') {
            // The original transition was not triggered via url sync
            // The lazy state should be loaded now, so re-try the original transition
            var orig = transition.targetState();
            return router.stateService.target(orig.identifier(), orig.params(), orig.options());
        }
        // The original transition was triggered via url sync
        // Run the URL rules and find the best match
        var $url = router.urlService;
        var result = $url.match($url.parts());
        var rule = result && result.rule;
        // If the best match is a state, redirect the transition (instead
        // of calling sync() which supersedes the current transition)
        if (rule && rule.type === 'STATE') {
            var state = rule.state;
            var params = result.match;
            return router.stateService.target(state, params, transition.options());
        }
        // No matching state found, so let .sync() choose the best non-state match/otherwise
        router.urlService.sync();
    }
    var promises = transition
        .entering()
        .filter(function (state) { return !!state.$$state().lazyLoad; })
        .map(function (state) { return lazyLoadState(transition, state); });
    return coreservices_1.services.$q.all(promises).then(retryTransition);
};
exports.registerLazyLoadHook = function (transitionService) {
    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);
};
/**
 * Invokes a state's lazy load function
 *
 * @param transition a Transition context
 * @param state the state to lazy load
 * @returns A promise for the lazy load result
 */
function lazyLoadState(transition, state) {
    var lazyLoadFn = state.$$state().lazyLoad;
    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked
    var promise = lazyLoadFn['_promise'];
    if (!promise) {
        var success = function (result) {
            delete state.lazyLoad;
            delete state.$$state().lazyLoad;
            delete lazyLoadFn['_promise'];
            return result;
        };
        var error = function (err) {
            delete lazyLoadFn['_promise'];
            return coreservices_1.services.$q.reject(err);
        };
        promise = lazyLoadFn['_promise'] = coreservices_1.services.$q
            .when(lazyLoadFn(transition, state))
            .then(updateStateRegistry)
            .then(success, error);
    }
    /** Register any lazy loaded state definitions */
    function updateStateRegistry(result) {
        if (result && Array.isArray(result.states)) {
            result.states.forEach(function (_state) { return transition.router.stateRegistry.register(_state); });
        }
        return result;
    }
    return promise;
}
exports.lazyLoadState = lazyLoadState;
//# sourceMappingURL=lazyLoad.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/onEnterExitRetain.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/onEnterExitRetain.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A factory which creates an onEnter, onExit or onRetain transition hook function
 *
 * The returned function invokes the (for instance) state.onEnter hook when the
 * state is being entered.
 *
 * @hidden
 */
function makeEnterExitRetainHook(hookName) {
    return function (transition, state) {
        var _state = state.$$state();
        var hookFn = _state[hookName];
        return hookFn(transition, state);
    };
}
/**
 * The [[TransitionStateHookFn]] for onExit
 *
 * When the state is being exited, the state's .onExit function is invoked.
 *
 * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`
 *
 * See: [[IHookRegistry.onExit]]
 */
var onExitHook = makeEnterExitRetainHook('onExit');
exports.registerOnExitHook = function (transitionService) {
    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);
};
/**
 * The [[TransitionStateHookFn]] for onRetain
 *
 * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.
 *
 * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`
 *
 * See: [[IHookRegistry.onRetain]]
 */
var onRetainHook = makeEnterExitRetainHook('onRetain');
exports.registerOnRetainHook = function (transitionService) {
    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);
};
/**
 * The [[TransitionStateHookFn]] for onEnter
 *
 * When the state is being entered, the state's .onEnter function is invoked.
 *
 * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`
 *
 * See: [[IHookRegistry.onEnter]]
 */
var onEnterHook = makeEnterExitRetainHook('onEnter');
exports.registerOnEnterHook = function (transitionService) {
    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);
};
//# sourceMappingURL=onEnterExitRetain.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/redirectTo.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/redirectTo.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */ /** */
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
var targetState_1 = __webpack_require__(/*! ../state/targetState */ "./node_modules/@uirouter/core/lib/state/targetState.js");
/**
 * A [[TransitionHookFn]] that redirects to a different state or params
 *
 * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`
 *
 * See [[StateDeclaration.redirectTo]]
 */
var redirectToHook = function (trans) {
    var redirect = trans.to().redirectTo;
    if (!redirect)
        return;
    var $state = trans.router.stateService;
    function handleResult(result) {
        if (!result)
            return;
        if (result instanceof targetState_1.TargetState)
            return result;
        if (predicates_1.isString(result))
            return $state.target(result, trans.params(), trans.options());
        if (result['state'] || result['params'])
            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());
    }
    if (predicates_1.isFunction(redirect)) {
        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);
    }
    return handleResult(redirect);
};
exports.registerRedirectToHook = function (transitionService) {
    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);
};
//# sourceMappingURL=redirectTo.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/resolve.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */
/** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var resolveContext_1 = __webpack_require__(/*! ../resolve/resolveContext */ "./node_modules/@uirouter/core/lib/resolve/resolveContext.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
exports.RESOLVE_HOOK_PRIORITY = 1000;
/**
 * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path
 *
 * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`
 *
 * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.
 *
 * See [[StateDeclaration.resolve]]
 */
var eagerResolvePath = function (trans) {
    return new resolveContext_1.ResolveContext(trans.treeChanges().to).resolvePath('EAGER', trans).then(common_1.noop);
};
exports.registerEagerResolvePath = function (transitionService) {
    return transitionService.onStart({}, eagerResolvePath, { priority: exports.RESOLVE_HOOK_PRIORITY });
};
/**
 * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path
 *
 * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`
 *
 * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.
 *
 * See [[StateDeclaration.resolve]]
 */
var lazyResolveState = function (trans, state) {
    return new resolveContext_1.ResolveContext(trans.treeChanges().to)
        .subContext(state.$$state())
        .resolvePath('LAZY', trans)
        .then(common_1.noop);
};
exports.registerLazyResolveState = function (transitionService) {
    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: exports.RESOLVE_HOOK_PRIORITY });
};
/**
 * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.
 *
 * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`
 *
 * After all entering states have been entered, this hook resolves any remaining Resolvables.
 * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].
 *
 * See [[StateDeclaration.resolve]]
 */
var resolveRemaining = function (trans) {
    return new resolveContext_1.ResolveContext(trans.treeChanges().to).resolvePath('LAZY', trans).then(common_1.noop);
};
exports.registerResolveRemaining = function (transitionService) {
    return transitionService.onFinish({}, resolveRemaining, { priority: exports.RESOLVE_HOOK_PRIORITY });
};
//# sourceMappingURL=resolve.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/updateGlobals.js":
/*!****************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/updateGlobals.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
/**
 * A [[TransitionHookFn]] which updates global UI-Router state
 *
 * Registered using `transitionService.onBefore({}, updateGlobalState);`
 *
 * Before a [[Transition]] starts, updates the global value of "the current transition" ([[Globals.transition]]).
 * After a successful [[Transition]], updates the global values of "the current state"
 * ([[Globals.current]] and [[Globals.$current]]) and "the current param values" ([[Globals.params]]).
 *
 * See also the deprecated properties:
 * [[StateService.transition]], [[StateService.current]], [[StateService.params]]
 */
var updateGlobalState = function (trans) {
    var globals = trans.router.globals;
    var transitionSuccessful = function () {
        globals.successfulTransitions.enqueue(trans);
        globals.$current = trans.$to();
        globals.current = globals.$current.self;
        common_1.copy(trans.params(), globals.params);
    };
    var clearCurrentTransition = function () {
        // Do not clear globals.transition if a different transition has started in the meantime
        if (globals.transition === trans)
            globals.transition = null;
    };
    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });
    trans.promise.then(clearCurrentTransition, clearCurrentTransition);
};
exports.registerUpdateGlobalState = function (transitionService) {
    return transitionService.onCreate({}, updateGlobalState);
};
//# sourceMappingURL=updateGlobals.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/url.js":
/*!******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/url.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A [[TransitionHookFn]] which updates the URL after a successful transition
 *
 * Registered using `transitionService.onSuccess({}, updateUrl);`
 */
var updateUrl = function (transition) {
    var options = transition.options();
    var $state = transition.router.stateService;
    var $urlRouter = transition.router.urlRouter;
    // Dont update the url in these situations:
    // The transition was triggered by a URL sync (options.source === 'url')
    // The user doesn't want the url to update (options.location === false)
    // The destination state, and all parents have no navigable url
    if (options.source !== 'url' && options.location && $state.$current.navigable) {
        var urlOptions = { replace: options.location === 'replace' };
        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);
    }
    $urlRouter.update(true);
};
exports.registerUpdateUrl = function (transitionService) {
    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });
};
//# sourceMappingURL=url.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/hooks/views.js":
/*!********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/hooks/views.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */ /** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
/**
 * A [[TransitionHookFn]] which waits for the views to load
 *
 * Registered using `transitionService.onStart({}, loadEnteringViews);`
 *
 * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.
 * In angular 1, this includes loading the templates.
 */
var loadEnteringViews = function (transition) {
    var $q = coreservices_1.services.$q;
    var enteringViews = transition.views('entering');
    if (!enteringViews.length)
        return;
    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);
};
exports.registerLoadEnteringViews = function (transitionService) {
    return transitionService.onFinish({}, loadEnteringViews);
};
/**
 * A [[TransitionHookFn]] which activates the new views when a transition is successful.
 *
 * Registered using `transitionService.onSuccess({}, activateViews);`
 *
 * After a transition is complete, this hook deactivates the old views from the previous state,
 * and activates the new views from the destination state.
 *
 * See [[ViewService]]
 */
var activateViews = function (transition) {
    var enteringViews = transition.views('entering');
    var exitingViews = transition.views('exiting');
    if (!enteringViews.length && !exitingViews.length)
        return;
    var $view = transition.router.viewService;
    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });
    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });
    $view.sync();
};
exports.registerActivateViews = function (transitionService) {
    return transitionService.onSuccess({}, activateViews);
};
//# sourceMappingURL=views.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module common
 */ /** */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./common/index */ "./node_modules/@uirouter/core/lib/common/index.js"));
__export(__webpack_require__(/*! ./params/index */ "./node_modules/@uirouter/core/lib/params/index.js"));
__export(__webpack_require__(/*! ./path/index */ "./node_modules/@uirouter/core/lib/path/index.js"));
__export(__webpack_require__(/*! ./resolve/index */ "./node_modules/@uirouter/core/lib/resolve/index.js"));
__export(__webpack_require__(/*! ./state/index */ "./node_modules/@uirouter/core/lib/state/index.js"));
__export(__webpack_require__(/*! ./transition/index */ "./node_modules/@uirouter/core/lib/transition/index.js"));
__export(__webpack_require__(/*! ./url/index */ "./node_modules/@uirouter/core/lib/url/index.js"));
__export(__webpack_require__(/*! ./view/index */ "./node_modules/@uirouter/core/lib/view/index.js"));
__export(__webpack_require__(/*! ./globals */ "./node_modules/@uirouter/core/lib/globals.js"));
__export(__webpack_require__(/*! ./router */ "./node_modules/@uirouter/core/lib/router.js"));
__export(__webpack_require__(/*! ./vanilla */ "./node_modules/@uirouter/core/lib/vanilla.js"));
__export(__webpack_require__(/*! ./interface */ "./node_modules/@uirouter/core/lib/interface.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/interface.js":
/*!******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/interface.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * # Core classes and interfaces
 *
 * The classes and interfaces that are core to ui-router and do not belong
 * to a more specific subsystem (such as resolve).
 *
 * @coreapi
 * @preferred
 * @module core
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
/** @internalapi */
var UIRouterPluginBase = /** @class */ (function () {
    function UIRouterPluginBase() {
    }
    UIRouterPluginBase.prototype.dispose = function (router) { };
    return UIRouterPluginBase;
}());
exports.UIRouterPluginBase = UIRouterPluginBase;
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/params/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/params/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./param */ "./node_modules/@uirouter/core/lib/params/param.js"));
__export(__webpack_require__(/*! ./paramTypes */ "./node_modules/@uirouter/core/lib/params/paramTypes.js"));
__export(__webpack_require__(/*! ./stateParams */ "./node_modules/@uirouter/core/lib/params/stateParams.js"));
__export(__webpack_require__(/*! ./paramType */ "./node_modules/@uirouter/core/lib/params/paramType.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/params/param.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/params/param.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */ /** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
var paramType_1 = __webpack_require__(/*! ./paramType */ "./node_modules/@uirouter/core/lib/params/paramType.js");
/** @hidden */
var hasOwn = Object.prototype.hasOwnProperty;
/** @hidden */
var isShorthand = function (cfg) {
    return ['value', 'type', 'squash', 'array', 'dynamic'].filter(hasOwn.bind(cfg || {})).length === 0;
};
/** @internalapi */
var DefType;
(function (DefType) {
    DefType[DefType["PATH"] = 0] = "PATH";
    DefType[DefType["SEARCH"] = 1] = "SEARCH";
    DefType[DefType["CONFIG"] = 2] = "CONFIG";
})(DefType = exports.DefType || (exports.DefType = {}));
/** @hidden */
function unwrapShorthand(cfg) {
    cfg = (isShorthand(cfg) && { value: cfg }) || cfg;
    getStaticDefaultValue['__cacheable'] = true;
    function getStaticDefaultValue() {
        return cfg.value;
    }
    return common_1.extend(cfg, {
        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,
    });
}
/** @hidden */
function getType(cfg, urlType, location, id, paramTypes) {
    if (cfg.type && urlType && urlType.name !== 'string')
        throw new Error("Param '" + id + "' has two type configurations.");
    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))
        return paramTypes.type(cfg.type);
    if (urlType)
        return urlType;
    if (!cfg.type) {
        var type = location === DefType.CONFIG
            ? 'any'
            : location === DefType.PATH ? 'path' : location === DefType.SEARCH ? 'query' : 'string';
        return paramTypes.type(type);
    }
    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);
}
/**
 * @internalapi
 * returns false, true, or the squash value to indicate the "default parameter url squash policy".
 */
function getSquashPolicy(config, isOptional, defaultPolicy) {
    var squash = config.squash;
    if (!isOptional || squash === false)
        return false;
    if (!predicates_1.isDefined(squash) || squash == null)
        return defaultPolicy;
    if (squash === true || predicates_1.isString(squash))
        return squash;
    throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
}
/** @internalapi */
function getReplace(config, arrayMode, isOptional, squash) {
    var defaultPolicy = [
        { from: '', to: isOptional || arrayMode ? undefined : '' },
        { from: null, to: isOptional || arrayMode ? undefined : '' },
    ];
    var replace = predicates_1.isArray(config.replace) ? config.replace : [];
    if (predicates_1.isString(squash))
        replace.push({ from: squash, to: undefined });
    var configuredKeys = common_1.map(replace, hof_1.prop('from'));
    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);
}
/** @internalapi */
var Param = /** @class */ (function () {
    function Param(id, type, config, location, urlMatcherFactory) {
        config = unwrapShorthand(config);
        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);
        var arrayMode = getArrayMode();
        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;
        var isOptional = config.value !== undefined || location === DefType.SEARCH;
        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;
        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;
        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());
        var replace = getReplace(config, arrayMode, isOptional, squash);
        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;
        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
        function getArrayMode() {
            var arrayDefaults = { array: location === DefType.SEARCH ? 'auto' : false };
            var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;
        }
        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config });
    }
    Param.values = function (params, values) {
        if (values === void 0) { values = {}; }
        var paramValues = {};
        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
            var param = params_1[_i];
            paramValues[param.id] = param.value(values[param.id]);
        }
        return paramValues;
    };
    /**
     * Finds [[Param]] objects which have different param values
     *
     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects
     *
     * @param params: The list of Param objects to filter
     * @param values1: The first set of parameter values
     * @param values2: the second set of parameter values
     *
     * @returns any Param objects whose values were different between values1 and values2
     */
    Param.changed = function (params, values1, values2) {
        if (values1 === void 0) { values1 = {}; }
        if (values2 === void 0) { values2 = {}; }
        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });
    };
    /**
     * Checks if two param value objects are equal (for a set of [[Param]] objects)
     *
     * @param params The list of [[Param]] objects to check
     * @param values1 The first set of param values
     * @param values2 The second set of param values
     *
     * @returns true if the param values in values1 and values2 are equal
     */
    Param.equals = function (params, values1, values2) {
        if (values1 === void 0) { values1 = {}; }
        if (values2 === void 0) { values2 = {}; }
        return Param.changed(params, values1, values2).length === 0;
    };
    /** Returns true if a the parameter values are valid, according to the Param definitions */
    Param.validates = function (params, values) {
        if (values === void 0) { values = {}; }
        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);
    };
    Param.prototype.isDefaultValue = function (value) {
        return this.isOptional && this.type.equals(this.value(), value);
    };
    /**
     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
     * default value, which may be the result of an injectable function.
     */
    Param.prototype.value = function (value) {
        var _this = this;
        /**
         * [Internal] Get the default value of a parameter, which may be an injectable function.
         */
        var getDefaultValue = function () {
            if (_this._defaultValueCache)
                return _this._defaultValueCache.defaultValue;
            if (!coreservices_1.services.$injector)
                throw new Error('Injectable functions cannot be called at configuration time');
            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))
                throw new Error("Default value (" + defaultValue + ") for parameter '" + _this.id + "' is not an instance of ParamType (" + _this.type.name + ")");
            if (_this.config.$$fn['__cacheable']) {
                _this._defaultValueCache = { defaultValue: defaultValue };
            }
            return defaultValue;
        };
        var replaceSpecialValues = function (val) {
            for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {
                var tuple = _a[_i];
                if (tuple.from === val)
                    return tuple.to;
            }
            return val;
        };
        value = replaceSpecialValues(value);
        return predicates_1.isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
    };
    Param.prototype.isSearch = function () {
        return this.location === DefType.SEARCH;
    };
    Param.prototype.validates = function (value) {
        // There was no parameter value, but the param is optional
        if ((predicates_1.isUndefined(value) || value === null) && this.isOptional)
            return true;
        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType
        var normalized = this.type.$normalize(value);
        if (!this.type.is(normalized))
            return false;
        // The value was of the correct type, but when encoded, did not match the ParamType's regexp
        var encoded = this.type.encode(normalized);
        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));
    };
    Param.prototype.toString = function () {
        return "{Param:" + this.id + " " + this.type + " squash: '" + this.squash + "' optional: " + this.isOptional + "}";
    };
    return Param;
}());
exports.Param = Param;
//# sourceMappingURL=param.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/params/paramType.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/params/paramType.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */
/** */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
/**
 * An internal class which implements [[ParamTypeDefinition]].
 *
 * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.
 * When a param type definition is registered, an instance of this class is created internally.
 *
 * This class has naive implementations for all the [[ParamTypeDefinition]] methods.
 *
 * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.
 *
 * #### Example:
 * ```js
 * var paramTypeDef = {
 *   decode: function(val) { return parseInt(val, 10); },
 *   encode: function(val) { return val && val.toString(); },
 *   equals: function(a, b) { return this.is(a) && a === b; },
 *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },
 *   pattern: /\d+/
 * }
 *
 * var paramType = new ParamType(paramTypeDef);
 * ```
 * @internalapi
 */
var ParamType = /** @class */ (function () {
    /**
     * @param def  A configuration object which contains the custom type definition.  The object's
     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.
     * @returns a new ParamType object
     */
    function ParamType(def) {
        /** @inheritdoc */
        this.pattern = /.*/;
        /** @inheritdoc */
        this.inherit = true;
        common_1.extend(this, def);
    }
    // consider these four methods to be "abstract methods" that should be overridden
    /** @inheritdoc */
    ParamType.prototype.is = function (val, key) {
        return true;
    };
    /** @inheritdoc */
    ParamType.prototype.encode = function (val, key) {
        return val;
    };
    /** @inheritdoc */
    ParamType.prototype.decode = function (val, key) {
        return val;
    };
    /** @inheritdoc */
    ParamType.prototype.equals = function (a, b) {
        // tslint:disable-next-line:triple-equals
        return a == b;
    };
    ParamType.prototype.$subPattern = function () {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    };
    ParamType.prototype.toString = function () {
        return "{ParamType:" + this.name + "}";
    };
    /** Given an encoded string, or a decoded object, returns a decoded object */
    ParamType.prototype.$normalize = function (val) {
        return this.is(val) ? val : this.decode(val);
    };
    /**
     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.
     * e.g.:
     * - urlmatcher pattern "/path?{queryParam[]:int}"
     * - url: "/path?queryParam=1&queryParam=2
     * - $stateParams.queryParam will be [1, 2]
     * if `mode` is "auto", then
     * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
     * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
     */
    ParamType.prototype.$asArray = function (mode, isSearch) {
        if (!mode)
            return this;
        if (mode === 'auto' && !isSearch)
            throw new Error("'auto' array mode is for query parameters only");
        return new ArrayType(this, mode);
    };
    return ParamType;
}());
exports.ParamType = ParamType;
/**
 * Wraps up a `ParamType` object to handle array values.
 * @internalapi
 */
function ArrayType(type, mode) {
    var _this = this;
    // Wrap non-array value as array
    function arrayWrap(val) {
        return predicates_1.isArray(val) ? val : predicates_1.isDefined(val) ? [val] : [];
    }
    // Unwrap array value for "auto" mode. Return undefined for empty array.
    function arrayUnwrap(val) {
        switch (val.length) {
            case 0:
                return undefined;
            case 1:
                return mode === 'auto' ? val[0] : val;
            default:
                return val;
        }
    }
    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
    function arrayHandler(callback, allTruthyMode) {
        return function handleArray(val) {
            if (predicates_1.isArray(val) && val.length === 0)
                return val;
            var arr = arrayWrap(val);
            var result = common_1.map(arr, callback);
            return allTruthyMode === true ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);
        };
    }
    // Wraps type (.equals) functions to operate on each value of an array
    function arrayEqualsHandler(callback) {
        return function handleArray(val1, val2) {
            var left = arrayWrap(val1), right = arrayWrap(val2);
            if (left.length !== right.length)
                return false;
            for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                    return false;
            }
            return true;
        };
    }
    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {
        var paramTypeFn = type[name].bind(type);
        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;
        _this[name] = wrapperFn(paramTypeFn);
    });
    common_1.extend(this, {
        dynamic: type.dynamic,
        name: type.name,
        pattern: type.pattern,
        inherit: type.inherit,
        is: arrayHandler(type.is.bind(type), true),
        $arrayMode: mode,
    });
}
//# sourceMappingURL=paramType.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/params/paramTypes.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/params/paramTypes.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */
/** */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
var paramType_1 = __webpack_require__(/*! ./paramType */ "./node_modules/@uirouter/core/lib/params/paramType.js");
/**
 * A registry for parameter types.
 *
 * This registry manages the built-in (and custom) parameter types.
 *
 * The built-in parameter types are:
 *
 * - [[string]]
 * - [[path]]
 * - [[query]]
 * - [[hash]]
 * - [[int]]
 * - [[bool]]
 * - [[date]]
 * - [[json]]
 * - [[any]]
 */
var ParamTypes = /** @class */ (function () {
    /** @internalapi */
    function ParamTypes() {
        /** @hidden */
        this.enqueue = true;
        /** @hidden */
        this.typeQueue = [];
        /** @internalapi */
        this.defaultTypes = common_1.pick(ParamTypes.prototype, [
            'hash',
            'string',
            'query',
            'path',
            'int',
            'bool',
            'date',
            'json',
            'any',
        ]);
        // Register default types. Store them in the prototype of this.types.
        var makeType = function (definition, name) { return new paramType_1.ParamType(common_1.extend({ name: name }, definition)); };
        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});
    }
    /** @internalapi */
    ParamTypes.prototype.dispose = function () {
        this.types = {};
    };
    /**
     * Registers a parameter type
     *
     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.
     */
    ParamTypes.prototype.type = function (name, definition, definitionFn) {
        if (!predicates_1.isDefined(definition))
            return this.types[name];
        if (this.types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));
        if (definitionFn) {
            this.typeQueue.push({ name: name, def: definitionFn });
            if (!this.enqueue)
                this._flushTypeQueue();
        }
        return this;
    };
    /** @internalapi */
    ParamTypes.prototype._flushTypeQueue = function () {
        while (this.typeQueue.length) {
            var type = this.typeQueue.shift();
            if (type.pattern)
                throw new Error("You cannot override a type's .pattern at runtime.");
            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));
        }
    };
    return ParamTypes;
}());
exports.ParamTypes = ParamTypes;
/** @hidden */
function initDefaultTypes() {
    var makeDefaultType = function (def) {
        var valToString = function (val) { return (val != null ? val.toString() : val); };
        var defaultTypeBase = {
            encode: valToString,
            decode: valToString,
            is: hof_1.is(String),
            pattern: /.*/,
            // tslint:disable-next-line:triple-equals
            equals: function (a, b) { return a == b; },
        };
        return common_1.extend({}, defaultTypeBase, def);
    };
    // Default Parameter Type Definitions
    common_1.extend(ParamTypes.prototype, {
        string: makeDefaultType({}),
        path: makeDefaultType({
            pattern: /[^/]*/,
        }),
        query: makeDefaultType({}),
        hash: makeDefaultType({
            inherit: false,
        }),
        int: makeDefaultType({
            decode: function (val) { return parseInt(val, 10); },
            is: function (val) {
                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;
            },
            pattern: /-?\d+/,
        }),
        bool: makeDefaultType({
            encode: function (val) { return (val && 1) || 0; },
            decode: function (val) { return parseInt(val, 10) !== 0; },
            is: hof_1.is(Boolean),
            pattern: /0|1/,
        }),
        date: makeDefaultType({
            encode: function (val) {
                return !this.is(val)
                    ? undefined
                    : [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join('-');
            },
            decode: function (val) {
                if (this.is(val))
                    return val;
                var match = this.capture.exec(val);
                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
            },
            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },
            equals: function (l, r) {
                return ['getFullYear', 'getMonth', 'getDate'].reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);
            },
            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,
        }),
        json: makeDefaultType({
            encode: common_1.toJson,
            decode: common_1.fromJson,
            is: hof_1.is(Object),
            equals: common_1.equals,
            pattern: /[^/]*/,
        }),
        // does not encode/decode
        any: makeDefaultType({
            encode: common_1.identity,
            decode: common_1.identity,
            is: function () { return true; },
            equals: common_1.equals,
        }),
    });
}
initDefaultTypes();
//# sourceMappingURL=paramTypes.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/params/stateParams.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/params/stateParams.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */
/** */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
/** @internalapi */
var StateParams = /** @class */ (function () {
    function StateParams(params) {
        if (params === void 0) { params = {}; }
        common_1.extend(this, params);
    }
    /**
     * Merges a set of parameters with all parameters inherited between the common parents of the
     * current state and a given destination state.
     *
     * @param {Object} newParams The set of parameters which will be composited with inherited params.
     * @param {Object} $current Internal definition of object representing the current state.
     * @param {Object} $to Internal definition of object representing state to transition to.
     */
    StateParams.prototype.$inherit = function (newParams, $current, $to) {
        var parentParams;
        var parents = common_1.ancestors($current, $to), inherited = {}, inheritList = [];
        for (var i in parents) {
            if (!parents[i] || !parents[i].params)
                continue;
            parentParams = Object.keys(parents[i].params);
            if (!parentParams.length)
                continue;
            for (var j in parentParams) {
                if (inheritList.indexOf(parentParams[j]) >= 0)
                    continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = this[parentParams[j]];
            }
        }
        return common_1.extend({}, inherited, newParams);
    };
    return StateParams;
}());
exports.StateParams = StateParams;
//# sourceMappingURL=stateParams.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/path/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/path/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module path */ /** for typedoc */
__export(__webpack_require__(/*! ./pathNode */ "./node_modules/@uirouter/core/lib/path/pathNode.js"));
__export(__webpack_require__(/*! ./pathUtils */ "./node_modules/@uirouter/core/lib/path/pathUtils.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/path/pathNode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/path/pathNode.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module path */ /** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var param_1 = __webpack_require__(/*! ../params/param */ "./node_modules/@uirouter/core/lib/params/param.js");
/**
 * @internalapi
 *
 * A node in a [[TreeChanges]] path
 *
 * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.
 * Each PathNode corresponds to a state being entered, exited, or retained.
 * The stateful information includes parameter values and resolve data.
 */
var PathNode = /** @class */ (function () {
    function PathNode(stateOrNode) {
        if (stateOrNode instanceof PathNode) {
            var node = stateOrNode;
            this.state = node.state;
            this.paramSchema = node.paramSchema.slice();
            this.paramValues = common_1.extend({}, node.paramValues);
            this.resolvables = node.resolvables.slice();
            this.views = node.views && node.views.slice();
        }
        else {
            var state = stateOrNode;
            this.state = state;
            this.paramSchema = state.parameters({ inherit: false });
            this.paramValues = {};
            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });
        }
    }
    PathNode.prototype.clone = function () {
        return new PathNode(this);
    };
    /** Sets [[paramValues]] for the node, from the values of an object hash */
    PathNode.prototype.applyRawParams = function (params) {
        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };
        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});
        return this;
    };
    /** Gets a specific [[Param]] metadata that belongs to the node */
    PathNode.prototype.parameter = function (name) {
        return common_1.find(this.paramSchema, hof_1.propEq('id', name));
    };
    /**
     * @returns true if the state and parameter values for another PathNode are
     * equal to the state and param values for this PathNode
     */
    PathNode.prototype.equals = function (node, paramsFn) {
        var diff = this.diff(node, paramsFn);
        return diff && diff.length === 0;
    };
    /**
     * Finds Params with different parameter values on another PathNode.
     *
     * Given another node (of the same state), finds the parameter values which differ.
     * Returns the [[Param]] (schema objects) whose parameter values differ.
     *
     * Given another node for a different state, returns `false`
     *
     * @param node The node to compare to
     * @param paramsFn A function that returns which parameters should be compared.
     * @returns The [[Param]]s which differ, or null if the two nodes are for different states
     */
    PathNode.prototype.diff = function (node, paramsFn) {
        if (this.state !== node.state)
            return false;
        var params = paramsFn ? paramsFn(this) : this.paramSchema;
        return param_1.Param.changed(params, this.paramValues, node.paramValues);
    };
    /**
     * Returns a clone of the PathNode
     * @deprecated use instance method `node.clone()`
     */
    PathNode.clone = function (node) { return node.clone(); };
    return PathNode;
}());
exports.PathNode = PathNode;
//# sourceMappingURL=pathNode.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/path/pathUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/path/pathUtils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module path */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var targetState_1 = __webpack_require__(/*! ../state/targetState */ "./node_modules/@uirouter/core/lib/state/targetState.js");
var pathNode_1 = __webpack_require__(/*! ./pathNode */ "./node_modules/@uirouter/core/lib/path/pathNode.js");
/**
 * This class contains functions which convert TargetStates, Nodes and paths from one type to another.
 */
var PathUtils = /** @class */ (function () {
    function PathUtils() {
    }
    /** Given a PathNode[], create an TargetState */
    PathUtils.makeTargetState = function (registry, path) {
        var state = common_1.tail(path).state;
        return new targetState_1.TargetState(registry, state, path.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}), {});
    };
    PathUtils.buildPath = function (targetState) {
        var toParams = targetState.params();
        return targetState.$state().path.map(function (state) { return new pathNode_1.PathNode(state).applyRawParams(toParams); });
    };
    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */
    PathUtils.buildToPath = function (fromPath, targetState) {
        var toPath = PathUtils.buildPath(targetState);
        if (targetState.options().inherit) {
            return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));
        }
        return toPath;
    };
    /**
     * Creates ViewConfig objects and adds to nodes.
     *
     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state
     */
    PathUtils.applyViewConfigs = function ($view, path, states) {
        // Only apply the viewConfigs to the nodes for the given states
        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {
            var viewDecls = common_1.values(node.state.views || {});
            var subPath = PathUtils.subPath(path, function (n) { return n === node; });
            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });
            node.views = viewConfigs.reduce(common_1.unnestR, []);
        });
    };
    /**
     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath
     *
     * For a parameter in a node to be inherited from the from path:
     * - The toPath's node must have a matching node in the fromPath (by state).
     * - The parameter name must not be found in the toKeys parameter array.
     *
     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some
     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,
     * it is not inherited from the fromPath.
     */
    PathUtils.inheritParams = function (fromPath, toPath, toKeys) {
        if (toKeys === void 0) { toKeys = []; }
        function nodeParamVals(path, state) {
            var node = common_1.find(path, hof_1.propEq('state', state));
            return common_1.extend({}, node && node.paramValues);
        }
        var noInherit = fromPath
            .map(function (node) { return node.paramSchema; })
            .reduce(common_1.unnestR, [])
            .filter(function (param) { return !param.inherit; })
            .map(hof_1.prop('id'));
        /**
         * Given an [[PathNode]] "toNode", return a new [[PathNode]] with param values inherited from the
         * matching node in fromPath.  Only inherit keys that aren't found in "toKeys" from the node in "fromPath""
         */
        function makeInheritedParamsNode(toNode) {
            // All param values for the node (may include default key/vals, when key was not found in toParams)
            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);
            // limited to only those keys found in toParams
            var incomingParamVals = common_1.pick(toParamVals, toKeys);
            toParamVals = common_1.omit(toParamVals, toKeys);
            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);
            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals
            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);
            return new pathNode_1.PathNode(toNode.state).applyRawParams(ownParamVals);
        }
        // The param keys specified by the incoming toParams
        return toPath.map(makeInheritedParamsNode);
    };
    /**
     * Computes the tree changes (entering, exiting) between a fromPath and toPath.
     */
    PathUtils.treeChanges = function (fromPath, toPath, reloadState) {
        var max = Math.min(fromPath.length, toPath.length);
        var keep = 0;
        var nodesMatch = function (node1, node2) { return node1.equals(node2, PathUtils.nonDynamicParams); };
        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {
            keep++;
        }
        /** Given a retained node, return a new node which uses the to node's param values */
        function applyToParams(retainedNode, idx) {
            var cloned = retainedNode.clone();
            cloned.paramValues = toPath[idx].paramValues;
            return cloned;
        }
        var from, retained, exiting, entering, to;
        from = fromPath;
        retained = from.slice(0, keep);
        exiting = from.slice(keep);
        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped
        var retainedWithToParams = retained.map(applyToParams);
        entering = toPath.slice(keep);
        to = retainedWithToParams.concat(entering);
        return { from: from, to: to, retained: retained, retainedWithToParams: retainedWithToParams, exiting: exiting, entering: entering };
    };
    /**
     * Returns a new path which is: the subpath of the first path which matches the second path.
     *
     * The new path starts from root and contains any nodes that match the nodes in the second path.
     * It stops before the first non-matching node.
     *
     * Nodes are compared using their state property and their parameter values.
     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.
     *
     * @param pathA the first path
     * @param pathB the second path
     * @param paramsFn a function which returns the parameters to consider when comparing
     *
     * @returns an array of PathNodes from the first path which match the nodes in the second path
     */
    PathUtils.matching = function (pathA, pathB, paramsFn) {
        var done = false;
        var tuples = common_1.arrayTuples(pathA, pathB);
        return tuples.reduce(function (matching, _a) {
            var nodeA = _a[0], nodeB = _a[1];
            done = done || !nodeA.equals(nodeB, paramsFn);
            return done ? matching : matching.concat(nodeA);
        }, []);
    };
    /**
     * Returns true if two paths are identical.
     *
     * @param pathA
     * @param pathB
     * @param paramsFn a function which returns the parameters to consider when comparing
     * @returns true if the the states and parameter values for both paths are identical
     */
    PathUtils.equals = function (pathA, pathB, paramsFn) {
        return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;
    };
    /**
     * Return a subpath of a path, which stops at the first matching node
     *
     * Given an array of nodes, returns a subset of the array starting from the first node,
     * stopping when the first node matches the predicate.
     *
     * @param path a path of [[PathNode]]s
     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s
     * @returns a subpath up to the matching node, or undefined if no match is found
     */
    PathUtils.subPath = function (path, predicate) {
        var node = common_1.find(path, predicate);
        var elementIdx = path.indexOf(node);
        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);
    };
    PathUtils.nonDynamicParams = function (node) {
        return node.state.parameters({ inherit: false }).filter(function (param) { return !param.dynamic; });
    };
    /** Gets the raw parameter values from a path */
    PathUtils.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };
    return PathUtils;
}());
exports.PathUtils = PathUtils;
//# sourceMappingURL=pathUtils.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/resolve/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/resolve/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module resolve */ /** for typedoc */
__export(__webpack_require__(/*! ./interface */ "./node_modules/@uirouter/core/lib/resolve/interface.js"));
__export(__webpack_require__(/*! ./resolvable */ "./node_modules/@uirouter/core/lib/resolve/resolvable.js"));
__export(__webpack_require__(/*! ./resolveContext */ "./node_modules/@uirouter/core/lib/resolve/resolveContext.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/resolve/interface.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/resolve/interface.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @internalapi */
exports.resolvePolicies = {
    when: {
        LAZY: 'LAZY',
        EAGER: 'EAGER',
    },
    async: {
        WAIT: 'WAIT',
        NOWAIT: 'NOWAIT',
        RXWAIT: 'RXWAIT',
    },
};
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/resolve/resolvable.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/resolve/resolvable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module resolve
 */ /** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
var trace_1 = __webpack_require__(/*! ../common/trace */ "./node_modules/@uirouter/core/lib/common/trace.js");
var strings_1 = __webpack_require__(/*! ../common/strings */ "./node_modules/@uirouter/core/lib/common/strings.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var predicates_2 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
// TODO: explicitly make this user configurable
exports.defaultResolvePolicy = {
    when: 'LAZY',
    async: 'WAIT',
};
/**
 * The basic building block for the resolve system.
 *
 * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),
 * and the unwrapped-when-complete (.data) result of the resolveFn.
 *
 * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the
 * resolveFn) and returns the resulting promise.
 *
 * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first
 * parameter to those fns.
 */
var Resolvable = /** @class */ (function () {
    function Resolvable(arg1, resolveFn, deps, policy, data) {
        this.resolved = false;
        this.promise = undefined;
        if (arg1 instanceof Resolvable) {
            common_1.extend(this, arg1);
        }
        else if (predicates_1.isFunction(resolveFn)) {
            if (predicates_2.isNullOrUndefined(arg1))
                throw new Error('new Resolvable(): token argument is required');
            if (!predicates_1.isFunction(resolveFn))
                throw new Error('new Resolvable(): resolveFn argument must be a function');
            this.token = arg1;
            this.policy = policy;
            this.resolveFn = resolveFn;
            this.deps = deps || [];
            this.data = data;
            this.resolved = data !== undefined;
            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;
        }
        else if (predicates_1.isObject(arg1) && arg1.token && (arg1.hasOwnProperty('resolveFn') || arg1.hasOwnProperty('data'))) {
            var literal = arg1;
            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);
        }
    }
    Resolvable.prototype.getPolicy = function (state) {
        var thisPolicy = this.policy || {};
        var statePolicy = (state && state.resolvePolicy) || {};
        return {
            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,
            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,
        };
    };
    /**
     * Asynchronously resolve this Resolvable's data
     *
     * Given a ResolveContext that this Resolvable is found in:
     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function
     * and update the Resolvable's state
     */
    Resolvable.prototype.resolve = function (resolveContext, trans) {
        var _this = this;
        var $q = coreservices_1.services.$q;
        // Gets all dependencies from ResolveContext and wait for them to be resolved
        var getResolvableDependencies = function () {
            return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) { return resolvable.get(resolveContext, trans); }));
        };
        // Invokes the resolve function passing the resolved dependencies as arguments
        var invokeResolveFn = function (resolvedDeps) { return _this.resolveFn.apply(null, resolvedDeps); };
        /**
         * For RXWAIT policy:
         *
         * Given an observable returned from a resolve function:
         * - enables .cache() mode (this allows multicast subscribers)
         * - then calls toPromise() (this triggers subscribe() and thus fetches)
         * - Waits for the promise, then return the cached observable (not the first emitted value).
         */
        var waitForRx = function (observable$) {
            var cached = observable$.cache(1);
            return cached
                .take(1)
                .toPromise()
                .then(function () { return cached; });
        };
        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.
        var node = resolveContext.findNode(this);
        var state = node && node.state;
        var maybeWaitForRx = this.getPolicy(state).async === 'RXWAIT' ? waitForRx : common_1.identity;
        // After the final value has been resolved, update the state of the Resolvable
        var applyResolvedValue = function (resolvedValue) {
            _this.data = resolvedValue;
            _this.resolved = true;
            _this.resolveFn = null;
            trace_1.trace.traceResolvableResolved(_this, trans);
            return _this.data;
        };
        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.
        return (this.promise = $q
            .when()
            .then(getResolvableDependencies)
            .then(invokeResolveFn)
            .then(maybeWaitForRx)
            .then(applyResolvedValue));
    };
    /**
     * Gets a promise for this Resolvable's data.
     *
     * Fetches the data and returns a promise.
     * Returns the existing promise if it has already been fetched once.
     */
    Resolvable.prototype.get = function (resolveContext, trans) {
        return this.promise || this.resolve(resolveContext, trans);
    };
    Resolvable.prototype.toString = function () {
        return "Resolvable(token: " + strings_1.stringify(this.token) + ", requires: [" + this.deps.map(strings_1.stringify) + "])";
    };
    Resolvable.prototype.clone = function () {
        return new Resolvable(this);
    };
    Resolvable.fromData = function (token, data) { return new Resolvable(token, function () { return data; }, null, null, data); };
    return Resolvable;
}());
exports.Resolvable = Resolvable;
//# sourceMappingURL=resolvable.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/resolve/resolveContext.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/resolve/resolveContext.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module resolve */
/** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var trace_1 = __webpack_require__(/*! ../common/trace */ "./node_modules/@uirouter/core/lib/common/trace.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
var interface_1 = __webpack_require__(/*! ./interface */ "./node_modules/@uirouter/core/lib/resolve/interface.js");
var resolvable_1 = __webpack_require__(/*! ./resolvable */ "./node_modules/@uirouter/core/lib/resolve/resolvable.js");
var pathUtils_1 = __webpack_require__(/*! ../path/pathUtils */ "./node_modules/@uirouter/core/lib/path/pathUtils.js");
var strings_1 = __webpack_require__(/*! ../common/strings */ "./node_modules/@uirouter/core/lib/common/strings.js");
var common_2 = __webpack_require__(/*! ../common */ "./node_modules/@uirouter/core/lib/common/index.js");
var whens = interface_1.resolvePolicies.when;
var ALL_WHENS = [whens.EAGER, whens.LAZY];
var EAGER_WHENS = [whens.EAGER];
// tslint:disable-next-line:no-inferrable-types
exports.NATIVE_INJECTOR_TOKEN = 'Native Injector';
/**
 * Encapsulates Dependency Injection for a path of nodes
 *
 * UI-Router states are organized as a tree.
 * A nested state has a path of ancestors to the root of the tree.
 * When a state is being activated, each element in the path is wrapped as a [[PathNode]].
 * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.
 *
 * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.
 */
var ResolveContext = /** @class */ (function () {
    function ResolveContext(_path) {
        this._path = _path;
    }
    /** Gets all the tokens found in the resolve context, de-duplicated */
    ResolveContext.prototype.getTokens = function () {
        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);
    };
    /**
     * Gets the Resolvable that matches the token
     *
     * Gets the last Resolvable that matches the token in this context, or undefined.
     * Throws an error if it doesn't exist in the ResolveContext
     */
    ResolveContext.prototype.getResolvable = function (token) {
        var matching = this._path
            .map(function (node) { return node.resolvables; })
            .reduce(common_1.unnestR, [])
            .filter(function (r) { return r.token === token; });
        return common_1.tail(matching);
    };
    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */
    ResolveContext.prototype.getPolicy = function (resolvable) {
        var node = this.findNode(resolvable);
        return resolvable.getPolicy(node.state);
    };
    /**
     * Returns a ResolveContext that includes a portion of this one
     *
     * Given a state, this method creates a new ResolveContext from this one.
     * The new context starts at the first node (root) and stops at the node for the `state` parameter.
     *
     * #### Why
     *
     * When a transition is created, the nodes in the "To Path" are injected from a ResolveContext.
     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.
     * The "To State" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).
     * This method is used to create a narrower context when injecting ancestor nodes.
     *
     * @example
     * `let ABCD = new ResolveContext([A, B, C, D]);`
     *
     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:
     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.
     * However, `B` should only be able to access resolvables from `A`, `B`.
     *
     * When resolving for the `B` node, first take the full "To Path" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.
     * `let AB = ABCD.subcontext(a)`
     */
    ResolveContext.prototype.subContext = function (state) {
        return new ResolveContext(pathUtils_1.PathUtils.subPath(this._path, function (node) { return node.state === state; }));
    };
    /**
     * Adds Resolvables to the node that matches the state
     *
     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).
     * The resolvable is added to the node matching the `state` parameter.
     *
     * These new resolvables are not automatically fetched.
     * The calling code should either fetch them, fetch something that depends on them,
     * or rely on [[resolvePath]] being called when some state is being entered.
     *
     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.
     *
     * @param newResolvables the new Resolvables
     * @param state Used to find the node to put the resolvable on
     */
    ResolveContext.prototype.addResolvables = function (newResolvables, state) {
        var node = common_1.find(this._path, hof_1.propEq('state', state));
        var keys = newResolvables.map(function (r) { return r.token; });
        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);
    };
    /**
     * Returns a promise for an array of resolved path Element promises
     *
     * @param when
     * @param trans
     * @returns {Promise<any>|any}
     */
    ResolveContext.prototype.resolvePath = function (when, trans) {
        var _this = this;
        if (when === void 0) { when = 'LAZY'; }
        // This option determines which 'when' policy Resolvables we are about to fetch.
        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : 'LAZY';
        // If the caller specified EAGER, only the EAGER Resolvables are fetched.
        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`
        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;
        // get the subpath to the state argument, if provided
        trace_1.trace.traceResolvePath(this._path, when, trans);
        var matchesPolicy = function (acceptedVals, whenOrAsync) { return function (resolvable) {
            return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);
        }; };
        // Trigger all the (matching) Resolvables in the path
        // Reduce all the "WAIT" Resolvables into an array
        var promises = this._path.reduce(function (acc, node) {
            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));
            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));
            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));
            // For the matching Resolvables, start their async fetch process.
            var subContext = _this.subContext(node.state);
            var getResult = function (r) {
                return r
                    .get(subContext, trans)
                    // Return a tuple that includes the Resolvable's token
                    .then(function (value) { return ({ token: r.token, value: value }); });
            };
            nowait.forEach(getResult);
            return acc.concat(wait.map(getResult));
        }, []);
        // Wait for all the "WAIT" resolvables
        return coreservices_1.services.$q.all(promises);
    };
    ResolveContext.prototype.injector = function () {
        return this._injector || (this._injector = new UIInjectorImpl(this));
    };
    ResolveContext.prototype.findNode = function (resolvable) {
        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });
    };
    /**
     * Gets the async dependencies of a Resolvable
     *
     * Given a Resolvable, returns its dependencies as a Resolvable[]
     */
    ResolveContext.prototype.getDependencies = function (resolvable) {
        var _this = this;
        var node = this.findNode(resolvable);
        // Find which other resolvables are "visible" to the `resolvable` argument
        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)
        var subPath = pathUtils_1.PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;
        var availableResolvables = subPath
            .reduce(function (acc, _node) { return acc.concat(_node.resolvables); }, []) // all of subpath's resolvables
            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument
        var getDependency = function (token) {
            var matching = availableResolvables.filter(function (r) { return r.token === token; });
            if (matching.length)
                return common_1.tail(matching);
            var fromInjector = _this.injector().getNative(token);
            if (common_2.isUndefined(fromInjector)) {
                throw new Error('Could not find Dependency Injection token: ' + strings_1.stringify(token));
            }
            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);
        };
        return resolvable.deps.map(getDependency);
    };
    return ResolveContext;
}());
exports.ResolveContext = ResolveContext;
var UIInjectorImpl = /** @class */ (function () {
    function UIInjectorImpl(context) {
        this.context = context;
        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;
    }
    UIInjectorImpl.prototype.get = function (token) {
        var resolvable = this.context.getResolvable(token);
        if (resolvable) {
            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {
                return resolvable.get(this.context);
            }
            if (!resolvable.resolved) {
                throw new Error('Resolvable async .get() not complete:' + strings_1.stringify(resolvable.token));
            }
            return resolvable.data;
        }
        return this.getNative(token);
    };
    UIInjectorImpl.prototype.getAsync = function (token) {
        var resolvable = this.context.getResolvable(token);
        if (resolvable)
            return resolvable.get(this.context);
        return coreservices_1.services.$q.when(this.native.get(token));
    };
    UIInjectorImpl.prototype.getNative = function (token) {
        return this.native && this.native.get(token);
    };
    return UIInjectorImpl;
}());
//# sourceMappingURL=resolveContext.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/router.js":
/*!***************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/router.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module core
 */ /** */
var urlMatcherFactory_1 = __webpack_require__(/*! ./url/urlMatcherFactory */ "./node_modules/@uirouter/core/lib/url/urlMatcherFactory.js");
var urlRouter_1 = __webpack_require__(/*! ./url/urlRouter */ "./node_modules/@uirouter/core/lib/url/urlRouter.js");
var transitionService_1 = __webpack_require__(/*! ./transition/transitionService */ "./node_modules/@uirouter/core/lib/transition/transitionService.js");
var view_1 = __webpack_require__(/*! ./view/view */ "./node_modules/@uirouter/core/lib/view/view.js");
var stateRegistry_1 = __webpack_require__(/*! ./state/stateRegistry */ "./node_modules/@uirouter/core/lib/state/stateRegistry.js");
var stateService_1 = __webpack_require__(/*! ./state/stateService */ "./node_modules/@uirouter/core/lib/state/stateService.js");
var globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/@uirouter/core/lib/globals.js");
var common_1 = __webpack_require__(/*! ./common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var predicates_1 = __webpack_require__(/*! ./common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var urlService_1 = __webpack_require__(/*! ./url/urlService */ "./node_modules/@uirouter/core/lib/url/urlService.js");
var trace_1 = __webpack_require__(/*! ./common/trace */ "./node_modules/@uirouter/core/lib/common/trace.js");
/** @hidden */
var _routerInstance = 0;
/**
 * The master class used to instantiate an instance of UI-Router.
 *
 * UI-Router (for each specific framework) will create an instance of this class during bootstrap.
 * This class instantiates and wires the UI-Router services together.
 *
 * After a new instance of the UIRouter class is created, it should be configured for your app.
 * For instance, app states should be registered with the [[UIRouter.stateRegistry]].
 *
 * ---
 *
 * Normally the framework code will bootstrap UI-Router.
 * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling
 * [[UrlService.listen]] then [[UrlService.sync]].
 */
var UIRouter = /** @class */ (function () {
    /**
     * Creates a new `UIRouter` object
     *
     * @param locationService a [[LocationServices]] implementation
     * @param locationConfig a [[LocationConfig]] implementation
     * @internalapi
     */
    function UIRouter(locationService, locationConfig) {
        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }
        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }
        this.locationService = locationService;
        this.locationConfig = locationConfig;
        /** @hidden */ this.$id = _routerInstance++;
        /** @hidden */ this._disposed = false;
        /** @hidden */ this._disposables = [];
        /** Provides trace information to the console */
        this.trace = trace_1.trace;
        /** Provides services related to ui-view synchronization */
        this.viewService = new view_1.ViewService();
        /** Global router state */
        this.globals = new globals_1.UIRouterGlobals();
        /** Provides services related to Transitions */
        this.transitionService = new transitionService_1.TransitionService(this);
        /**
         * Deprecated for public use. Use [[urlService]] instead.
         * @deprecated Use [[urlService]] instead
         */
        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();
        /**
         * Deprecated for public use. Use [[urlService]] instead.
         * @deprecated Use [[urlService]] instead
         */
        this.urlRouter = new urlRouter_1.UrlRouter(this);
        /** Provides a registry for states, and related registration services */
        this.stateRegistry = new stateRegistry_1.StateRegistry(this);
        /** Provides services related to states */
        this.stateService = new stateService_1.StateService(this);
        /** Provides services related to the URL */
        this.urlService = new urlService_1.UrlService(this);
        /** @hidden plugin instances are registered here */
        this._plugins = {};
        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());
        this.globals.$current = this.stateRegistry.root();
        this.globals.current = this.globals.$current.self;
        this.disposable(this.globals);
        this.disposable(this.stateService);
        this.disposable(this.stateRegistry);
        this.disposable(this.transitionService);
        this.disposable(this.urlRouter);
        this.disposable(locationService);
        this.disposable(locationConfig);
    }
    /** Registers an object to be notified when the router is disposed */
    UIRouter.prototype.disposable = function (disposable) {
        this._disposables.push(disposable);
    };
    /**
     * Disposes this router instance
     *
     * When called, clears resources retained by the router by calling `dispose(this)` on all
     * registered [[disposable]] objects.
     *
     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.
     *
     * @param disposable (optional) the disposable to dispose
     */
    UIRouter.prototype.dispose = function (disposable) {
        var _this = this;
        if (disposable && predicates_1.isFunction(disposable.dispose)) {
            disposable.dispose(this);
            return undefined;
        }
        this._disposed = true;
        this._disposables.slice().forEach(function (d) {
            try {
                typeof d.dispose === 'function' && d.dispose(_this);
                common_1.removeFrom(_this._disposables, d);
            }
            catch (ignored) { }
        });
    };
    /**
     * Adds a plugin to UI-Router
     *
     * This method adds a UI-Router Plugin.
     * A plugin can enhance or change UI-Router behavior using any public API.
     *
     * #### Example:
     * ```js
     * import { MyCoolPlugin } from "ui-router-cool-plugin";
     *
     * var plugin = router.addPlugin(MyCoolPlugin);
     * ```
     *
     * ### Plugin authoring
     *
     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.
     *
     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].
     * For example, it may configure router options or add a Transition Hook.
     *
     * The plugin can then be published as a separate module.
     *
     * #### Example:
     * ```js
     * export class MyAuthPlugin implements UIRouterPlugin {
     *   constructor(router: UIRouter, options: any) {
     *     this.name = "MyAuthPlugin";
     *     let $transitions = router.transitionService;
     *     let $state = router.stateService;
     *
     *     let authCriteria = {
     *       to: (state) => state.data && state.data.requiresAuth
     *     };
     *
     *     function authHook(transition: Transition) {
     *       let authService = transition.injector().get('AuthService');
     *       if (!authService.isAuthenticated()) {
     *         return $state.target('login');
     *       }
     *     }
     *
     *     $transitions.onStart(authCriteria, authHook);
     *   }
     * }
     * ```
     *
     * @param plugin one of:
     *        - a plugin class which implements [[UIRouterPlugin]]
     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance
     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance
     * @param options options to pass to the plugin class/factory
     * @returns the registered plugin instance
     */
    UIRouter.prototype.plugin = function (plugin, options) {
        if (options === void 0) { options = {}; }
        var pluginInstance = new plugin(this, options);
        if (!pluginInstance.name)
            throw new Error('Required property `name` missing on plugin: ' + pluginInstance);
        this._disposables.push(pluginInstance);
        return (this._plugins[pluginInstance.name] = pluginInstance);
    };
    UIRouter.prototype.getPlugin = function (pluginName) {
        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);
    };
    return UIRouter;
}());
exports.UIRouter = UIRouter;
//# sourceMappingURL=router.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./stateBuilder */ "./node_modules/@uirouter/core/lib/state/stateBuilder.js"));
__export(__webpack_require__(/*! ./stateObject */ "./node_modules/@uirouter/core/lib/state/stateObject.js"));
__export(__webpack_require__(/*! ./stateMatcher */ "./node_modules/@uirouter/core/lib/state/stateMatcher.js"));
__export(__webpack_require__(/*! ./stateQueueManager */ "./node_modules/@uirouter/core/lib/state/stateQueueManager.js"));
__export(__webpack_require__(/*! ./stateRegistry */ "./node_modules/@uirouter/core/lib/state/stateRegistry.js"));
__export(__webpack_require__(/*! ./stateService */ "./node_modules/@uirouter/core/lib/state/stateService.js"));
__export(__webpack_require__(/*! ./targetState */ "./node_modules/@uirouter/core/lib/state/targetState.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateBuilder.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateBuilder.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module state */ /** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var strings_1 = __webpack_require__(/*! ../common/strings */ "./node_modules/@uirouter/core/lib/common/strings.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var resolvable_1 = __webpack_require__(/*! ../resolve/resolvable */ "./node_modules/@uirouter/core/lib/resolve/resolvable.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
var parseUrl = function (url) {
    if (!predicates_1.isString(url))
        return false;
    var root = url.charAt(0) === '^';
    return { val: root ? url.substring(1) : url, root: root };
};
function nameBuilder(state) {
    return state.name;
}
function selfBuilder(state) {
    state.self.$$state = function () { return state; };
    return state.self;
}
function dataBuilder(state) {
    if (state.parent && state.parent.data) {
        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);
    }
    return state.data;
}
var getUrlBuilder = function ($urlMatcherFactoryProvider, root) {
    return function urlBuilder(state) {
        var stateDec = state;
        // For future states, i.e., states whose name ends with `.**`,
        // match anything that starts with the url prefix
        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\.\*\*$/)) {
            stateDec.url += '{remainder:any}'; // match any path (.*)
        }
        var parsed = parseUrl(stateDec.url), parent = state.parent;
        var url = !parsed
            ? stateDec.url
            : $urlMatcherFactoryProvider.compile(parsed.val, {
                params: state.params || {},
                paramMap: function (paramConfig, isSearch) {
                    if (stateDec.reloadOnSearch === false && isSearch)
                        paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });
                    return paramConfig;
                },
            });
        if (!url)
            return null;
        if (!$urlMatcherFactoryProvider.isMatcher(url))
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
        return parsed && parsed.root ? url : ((parent && parent.navigable) || root()).url.append(url);
    };
};
var getNavigableBuilder = function (isRoot) {
    return function navigableBuilder(state) {
        return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null;
    };
};
var getParamsBuilder = function (paramFactory) {
    return function paramsBuilder(state) {
        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };
        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];
        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));
        return urlParams
            .concat(nonUrlParams)
            .map(function (p) { return [p.id, p]; })
            .reduce(common_1.applyPairs, {});
    };
};
function pathBuilder(state) {
    return state.parent ? state.parent.path.concat(state) : /*root*/ [state];
}
function includesBuilder(state) {
    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};
    includes[state.name] = true;
    return includes;
}
/**
 * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].
 *
 * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
 * validates the `resolve` property and converts it to a [[Resolvable]] array.
 *
 * resolve: input value can be:
 *
 * {
 *   // analyzed but not injected
 *   myFooResolve: function() { return "myFooData"; },
 *
 *   // function.toString() parsed, "DependencyName" dep as string (not min-safe)
 *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },
 *
 *   // Array split; "DependencyName" dep as string
 *   myBazResolve: [ "DependencyName", function(dep) { return dep.fetchSomethingAsPromise() },
 *
 *   // Array split; DependencyType dep as token (compared using ===)
 *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },
 *
 *   // val.$inject used as deps
 *   // where:
 *   //     corgeResolve.$inject = ["DependencyName"];
 *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }
 *   // then "DependencyName" dep as string
 *   myCorgeResolve: corgeResolve,
 *
 *  // inject service by name
 *  // When a string is found, desugar creating a resolve that injects the named service
 *   myGraultResolve: "SomeService"
 * }
 *
 * or:
 *
 * [
 *   new Resolvable("myFooResolve", function() { return "myFooData" }),
 *   new Resolvable("myBarResolve", function(dep) { return dep.fetchSomethingAsPromise() }, [ "DependencyName" ]),
 *   { provide: "myBazResolve", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ "DependencyName" ] }
 * ]
 */
function resolvablesBuilder(state) {
    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */
    var objects2Tuples = function (resolveObj, resolvePolicies) {
        return Object.keys(resolveObj || {}).map(function (token) { return ({
            token: token,
            val: resolveObj[token],
            deps: undefined,
            policy: resolvePolicies[token],
        }); });
    };
    /** fetch DI annotations from a function or ng1-style array */
    var annotate = function (fn) {
        var $injector = coreservices_1.services.$injector;
        // ng1 doesn't have an $injector until runtime.
        // If the $injector doesn't exist, use "deferred" literal as a
        // marker indicating they should be annotated when runtime starts
        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || 'deferred';
    };
    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */
    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };
    /** true if the object looks like a provide literal, or a ng2 Provider */
    var isLikeNg2Provider = function (obj) {
        return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass));
    };
    /** true if the object looks like a tuple from obj2Tuples */
    var isTupleFromObj = function (obj) {
        return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val)));
    };
    /** extracts the token from a Provider or provide literal */
    var getToken = function (p) { return p.provide || p.token; };
    /** Given a literal resolve or provider object, returns a Resolvable */
    var literal2Resolvable = hof_1.pattern([
        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(getToken(p), p.resolveFn, p.deps, p.policy); }],
        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(getToken(p), p.useFactory, p.deps || p.dependencies, p.policy); }],
        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(getToken(p), function () { return new p.useClass(); }, [], p.policy); }],
        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(getToken(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],
        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(getToken(p), common_1.identity, [p.useExisting], p.policy); }],
    ]);
    var tuple2Resolvable = hof_1.pattern([
        [hof_1.pipe(hof_1.prop('val'), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],
        [
            hof_1.pipe(hof_1.prop('val'), predicates_1.isArray),
            function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); },
        ],
        [
            hof_1.pipe(hof_1.prop('val'), predicates_1.isFunction),
            function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); },
        ],
    ]);
    var item2Resolvable = hof_1.pattern([
        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],
        [isResolveLiteral, literal2Resolvable],
        [isLikeNg2Provider, literal2Resolvable],
        [isTupleFromObj, tuple2Resolvable],
        [
            hof_1.val(true),
            function (obj) {
                throw new Error('Invalid resolve value: ' + strings_1.stringify(obj));
            },
        ],
    ]);
    // If resolveBlock is already an array, use it as-is.
    // Otherwise, assume it's an object and convert to an Array of tuples
    var decl = state.resolve;
    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});
    return items.map(item2Resolvable);
}
exports.resolvablesBuilder = resolvablesBuilder;
/**
 * @internalapi A internal global service
 *
 * StateBuilder is a factory for the internal [[StateObject]] objects.
 *
 * When you register a state with the [[StateRegistry]], you register a plain old javascript object which
 * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding
 * [[StateObject]] object, which has an API and is used internally.
 *
 * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function
 * using the [[builder]] method.
 */
var StateBuilder = /** @class */ (function () {
    function StateBuilder(matcher, urlMatcherFactory) {
        this.matcher = matcher;
        var self = this;
        var root = function () { return matcher.find(''); };
        var isRoot = function (state) { return state.name === ''; };
        function parentBuilder(state) {
            if (isRoot(state))
                return null;
            return matcher.find(self.parentName(state)) || root();
        }
        this.builders = {
            name: [nameBuilder],
            self: [selfBuilder],
            parent: [parentBuilder],
            data: [dataBuilder],
            // Build a URLMatcher if necessary, either via a relative or absolute URL
            url: [getUrlBuilder(urlMatcherFactory, root)],
            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
            navigable: [getNavigableBuilder(isRoot)],
            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],
            // Each framework-specific ui-router implementation should define its own `views` builder
            // e.g., src/ng1/statebuilders/views.ts
            views: [],
            // Keep a full path from the root down to this state as this is needed for state activation.
            path: [pathBuilder],
            // Speed up $state.includes() as it's used a lot
            includes: [includesBuilder],
            resolvables: [resolvablesBuilder],
        };
    }
    /**
     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).
     * More than one BuilderFunction can be registered for a given property.
     *
     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.
     *
     * @param name The name of the State property being registered for.
     * @param fn The BuilderFunction which will be used to build the State property
     * @returns a function which deregisters the BuilderFunction
     */
    StateBuilder.prototype.builder = function (name, fn) {
        var builders = this.builders;
        var array = builders[name] || [];
        // Backwards compat: if only one builder exists, return it, else return whole arary.
        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))
            return array.length > 1 ? array : array[0];
        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))
            return;
        builders[name] = array;
        builders[name].push(fn);
        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };
    };
    /**
     * Builds all of the properties on an essentially blank State object, returning a State object which has all its
     * properties and API built.
     *
     * @param state an uninitialized State object
     * @returns the built State object
     */
    StateBuilder.prototype.build = function (state) {
        var _a = this, matcher = _a.matcher, builders = _a.builders;
        var parent = this.parentName(state);
        if (parent && !matcher.find(parent, undefined, false)) {
            return null;
        }
        for (var key in builders) {
            if (!builders.hasOwnProperty(key))
                continue;
            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);
            state[key] = chain(state);
        }
        return state;
    };
    StateBuilder.prototype.parentName = function (state) {
        // name = 'foo.bar.baz.**'
        var name = state.name || '';
        // segments = ['foo', 'bar', 'baz', '.**']
        var segments = name.split('.');
        // segments = ['foo', 'bar', 'baz']
        var lastSegment = segments.pop();
        // segments = ['foo', 'bar'] (ignore .** segment for future states)
        if (lastSegment === '**')
            segments.pop();
        if (segments.length) {
            if (state.parent) {
                throw new Error("States that specify the 'parent:' property should not have a '.' in their name (" + name + ")");
            }
            // 'foo.bar'
            return segments.join('.');
        }
        if (!state.parent)
            return '';
        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;
    };
    StateBuilder.prototype.name = function (state) {
        var name = state.name;
        if (name.indexOf('.') !== -1 || !state.parent)
            return name;
        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;
        return parentName ? parentName + '.' + name : name;
    };
    return StateBuilder;
}());
exports.StateBuilder = StateBuilder;
//# sourceMappingURL=stateBuilder.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateMatcher.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateMatcher.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module state */ /** for typedoc */
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var StateMatcher = /** @class */ (function () {
    function StateMatcher(_states) {
        this._states = _states;
    }
    StateMatcher.prototype.isRelative = function (stateName) {
        stateName = stateName || '';
        return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;
    };
    StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {
        if (matchGlob === void 0) { matchGlob = true; }
        if (!stateOrName && stateOrName !== '')
            return undefined;
        var isStr = predicates_1.isString(stateOrName);
        var name = isStr ? stateOrName : stateOrName.name;
        if (this.isRelative(name))
            name = this.resolvePath(name, base);
        var state = this._states[name];
        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
        }
        else if (isStr && matchGlob) {
            var _states = common_1.values(this._states);
            var matches = _states.filter(function (_state) { return _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name); });
            if (matches.length > 1) {
                // tslint:disable-next-line:no-console
                console.log("stateMatcher.find: Found multiple matches for " + name + " using glob: ", matches.map(function (match) { return match.name; }));
            }
            return matches[0];
        }
        return undefined;
    };
    StateMatcher.prototype.resolvePath = function (name, base) {
        if (!base)
            throw new Error("No reference point given for path '" + name + "'");
        var baseState = this.find(base);
        var splitName = name.split('.');
        var pathLength = splitName.length;
        var i = 0, current = baseState;
        for (; i < pathLength; i++) {
            if (splitName[i] === '' && i === 0) {
                current = baseState;
                continue;
            }
            if (splitName[i] === '^') {
                if (!current.parent)
                    throw new Error("Path '" + name + "' not valid for state '" + baseState.name + "'");
                current = current.parent;
                continue;
            }
            break;
        }
        var relName = splitName.slice(i).join('.');
        return current.name + (current.name && relName ? '.' : '') + relName;
    };
    return StateMatcher;
}());
exports.StateMatcher = StateMatcher;
//# sourceMappingURL=stateMatcher.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateObject.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateObject.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var glob_1 = __webpack_require__(/*! ../common/glob */ "./node_modules/@uirouter/core/lib/common/glob.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
/**
 * Internal representation of a UI-Router state.
 *
 * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].
 *
 * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.
 *
 * This class prototypally inherits from the corresponding [[StateDeclaration]].
 * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].
 */
var StateObject = /** @class */ (function () {
    /** @deprecated use State.create() */
    function StateObject(config) {
        return StateObject.create(config || {});
    }
    /**
     * Create a state object to put the private/internal implementation details onto.
     * The object's prototype chain looks like:
     * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)
     *
     * @param stateDecl the user-supplied State Declaration
     * @returns {StateObject} an internal State object
     */
    StateObject.create = function (stateDecl) {
        stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;
        var state = common_1.inherit(common_1.inherit(stateDecl, StateObject.prototype));
        stateDecl.$$state = function () { return state; };
        state.self = stateDecl;
        state.__stateObjectCache = {
            nameGlob: glob_1.Glob.fromString(state.name),
        };
        return state;
    };
    /**
     * Returns true if the provided parameter is the same state.
     *
     * Compares the identity of the state against the passed value, which is either an object
     * reference to the actual `State` instance, the original definition object passed to
     * `$stateProvider.state()`, or the fully-qualified name.
     *
     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed
     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.
     * @returns Returns `true` if `ref` matches the current `State` instance.
     */
    StateObject.prototype.is = function (ref) {
        return this === ref || this.self === ref || this.fqn() === ref;
    };
    /**
     * @deprecated this does not properly handle dot notation
     * @returns Returns a dot-separated name of the state.
     */
    StateObject.prototype.fqn = function () {
        if (!this.parent || !(this.parent instanceof this.constructor))
            return this.name;
        var name = this.parent.fqn();
        return name ? name + '.' + this.name : this.name;
    };
    /**
     * Returns the root node of this state's tree.
     *
     * @returns The root of this state's tree.
     */
    StateObject.prototype.root = function () {
        return (this.parent && this.parent.root()) || this;
    };
    /**
     * Gets the state's `Param` objects
     *
     * Gets the list of [[Param]] objects owned by the state.
     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.
     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object
     *
     * @param opts options
     */
    StateObject.prototype.parameters = function (opts) {
        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });
        var inherited = (opts.inherit && this.parent && this.parent.parameters()) || [];
        return inherited
            .concat(common_1.values(this.params))
            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });
    };
    /**
     * Returns a single [[Param]] that is owned by the state
     *
     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.
     * @param id the name of the [[Param]] to return
     * @param opts options
     */
    StateObject.prototype.parameter = function (id, opts) {
        if (opts === void 0) { opts = {}; }
        return ((this.url && this.url.parameter(id, opts)) ||
            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||
            (opts.inherit && this.parent && this.parent.parameter(id)));
    };
    StateObject.prototype.toString = function () {
        return this.fqn();
    };
    /** Predicate which returns true if the object is an class with @State() decorator */
    StateObject.isStateClass = function (stateDecl) {
        return predicates_1.isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;
    };
    /** Predicate which returns true if the object is an internal [[StateObject]] object */
    StateObject.isState = function (obj) { return predicates_1.isObject(obj['__stateObjectCache']); };
    return StateObject;
}());
exports.StateObject = StateObject;
//# sourceMappingURL=stateObject.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateQueueManager.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateQueueManager.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module state */ /** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var stateObject_1 = __webpack_require__(/*! ./stateObject */ "./node_modules/@uirouter/core/lib/state/stateObject.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
/** @internalapi */
var StateQueueManager = /** @class */ (function () {
    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {
        this.$registry = $registry;
        this.$urlRouter = $urlRouter;
        this.states = states;
        this.builder = builder;
        this.listeners = listeners;
        this.queue = [];
        this.matcher = $registry.matcher;
    }
    /** @internalapi */
    StateQueueManager.prototype.dispose = function () {
        this.queue = [];
    };
    StateQueueManager.prototype.register = function (stateDecl) {
        var queue = this.queue;
        var state = stateObject_1.StateObject.create(stateDecl);
        var name = state.name;
        if (!predicates_1.isString(name))
            throw new Error('State must have a valid name');
        if (this.states.hasOwnProperty(name) || common_1.inArray(queue.map(hof_1.prop('name')), name))
            throw new Error("State '" + name + "' is already defined");
        queue.push(state);
        this.flush();
        return state;
    };
    StateQueueManager.prototype.flush = function () {
        var _this = this;
        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;
        var registered = [], // states that got registered
        orphans = [], // states that don't yet have a parent registered
        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered
        var getState = function (name) { return _this.states.hasOwnProperty(name) && _this.states[name]; };
        var notifyListeners = function () {
            if (registered.length) {
                _this.listeners.forEach(function (listener) { return listener('registered', registered.map(function (s) { return s.self; })); });
            }
        };
        while (queue.length > 0) {
            var state = queue.shift();
            var name_1 = state.name;
            var result = builder.build(state);
            var orphanIdx = orphans.indexOf(state);
            if (result) {
                var existingState = getState(name_1);
                if (existingState && existingState.name === name_1) {
                    throw new Error("State '" + name_1 + "' is already defined");
                }
                var existingFutureState = getState(name_1 + '.**');
                if (existingFutureState) {
                    // Remove future state of the same name
                    this.$registry.deregister(existingFutureState);
                }
                states[name_1] = state;
                this.attachRoute(state);
                if (orphanIdx >= 0)
                    orphans.splice(orphanIdx, 1);
                registered.push(state);
                continue;
            }
            var prev = previousQueueLength[name_1];
            previousQueueLength[name_1] = queue.length;
            if (orphanIdx >= 0 && prev === queue.length) {
                // Wait until two consecutive iterations where no additional states were dequeued successfully.
                // throw new Error(`Cannot register orphaned state '${name}'`);
                queue.push(state);
                notifyListeners();
                return states;
            }
            else if (orphanIdx < 0) {
                orphans.push(state);
            }
            queue.push(state);
        }
        notifyListeners();
        return states;
    };
    StateQueueManager.prototype.attachRoute = function (state) {
        if (state.abstract || !state.url)
            return;
        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));
    };
    return StateQueueManager;
}());
exports.StateQueueManager = StateQueueManager;
//# sourceMappingURL=stateQueueManager.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateRegistry.js":
/*!****************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateRegistry.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module state
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var stateMatcher_1 = __webpack_require__(/*! ./stateMatcher */ "./node_modules/@uirouter/core/lib/state/stateMatcher.js");
var stateBuilder_1 = __webpack_require__(/*! ./stateBuilder */ "./node_modules/@uirouter/core/lib/state/stateBuilder.js");
var stateQueueManager_1 = __webpack_require__(/*! ./stateQueueManager */ "./node_modules/@uirouter/core/lib/state/stateQueueManager.js");
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var StateRegistry = /** @class */ (function () {
    /** @internalapi */
    function StateRegistry(_router) {
        this._router = _router;
        this.states = {};
        this.listeners = [];
        this.matcher = new stateMatcher_1.StateMatcher(this.states);
        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);
        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);
        this._registerRoot();
    }
    /** @internalapi */
    StateRegistry.prototype._registerRoot = function () {
        var rootStateDef = {
            name: '',
            url: '^',
            views: null,
            params: {
                '#': { value: null, type: 'hash', dynamic: true },
            },
            abstract: true,
        };
        var _root = (this._root = this.stateQueue.register(rootStateDef));
        _root.navigable = null;
    };
    /** @internalapi */
    StateRegistry.prototype.dispose = function () {
        var _this = this;
        this.stateQueue.dispose();
        this.listeners = [];
        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });
    };
    /**
     * Listen for a State Registry events
     *
     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.
     *
     * #### Example:
     * ```js
     * let allStates = registry.get();
     *
     * // Later, invoke deregisterFn() to remove the listener
     * let deregisterFn = registry.onStatesChanged((event, states) => {
     *   switch(event) {
     *     case: 'registered':
     *       states.forEach(state => allStates.push(state));
     *       break;
     *     case: 'deregistered':
     *       states.forEach(state => {
     *         let idx = allStates.indexOf(state);
     *         if (idx !== -1) allStates.splice(idx, 1);
     *       });
     *       break;
     *   }
     * });
     * ```
     *
     * @param listener a callback function invoked when the registered states changes.
     *        The function receives two parameters, `event` and `state`.
     *        See [[StateRegistryListener]]
     * @return a function that deregisters the listener
     */
    StateRegistry.prototype.onStatesChanged = function (listener) {
        this.listeners.push(listener);
        return function deregisterListener() {
            common_1.removeFrom(this.listeners)(listener);
        }.bind(this);
    };
    /**
     * Gets the implicit root state
     *
     * Gets the root of the state tree.
     * The root state is implicitly created by UI-Router.
     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]
     *
     * @return the root [[StateObject]]
     */
    StateRegistry.prototype.root = function () {
        return this._root;
    };
    /**
     * Adds a state to the registry
     *
     * Registers a [[StateDeclaration]] or queues it for registration.
     *
     * Note: a state will be queued if the state's parent isn't yet registered.
     *
     * @param stateDefinition the definition of the state to register.
     * @returns the internal [[StateObject]] object.
     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).
     *          If the state was only queued, then the object is not fully built.
     */
    StateRegistry.prototype.register = function (stateDefinition) {
        return this.stateQueue.register(stateDefinition);
    };
    /** @hidden */
    StateRegistry.prototype._deregisterTree = function (state) {
        var _this = this;
        var all = this.get().map(function (s) { return s.$$state(); });
        var getChildren = function (states) {
            var _children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });
            return _children.length === 0 ? _children : _children.concat(getChildren(_children));
        };
        var children = getChildren([state]);
        var deregistered = [state].concat(children).reverse();
        deregistered.forEach(function (_state) {
            var $ur = _this._router.urlRouter;
            // Remove URL rule
            $ur
                .rules()
                .filter(hof_1.propEq('state', _state))
                .forEach($ur.removeRule.bind($ur));
            // Remove state from registry
            delete _this.states[_state.name];
        });
        return deregistered;
    };
    /**
     * Removes a state from the registry
     *
     * This removes a state from the registry.
     * If the state has children, they are are also removed from the registry.
     *
     * @param stateOrName the state's name or object representation
     * @returns {StateObject[]} a list of removed states
     */
    StateRegistry.prototype.deregister = function (stateOrName) {
        var _state = this.get(stateOrName);
        if (!_state)
            throw new Error("Can't deregister state; not found: " + stateOrName);
        var deregisteredStates = this._deregisterTree(_state.$$state());
        this.listeners.forEach(function (listener) { return listener('deregistered', deregisteredStates.map(function (s) { return s.self; })); });
        return deregisteredStates;
    };
    StateRegistry.prototype.get = function (stateOrName, base) {
        var _this = this;
        if (arguments.length === 0)
            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });
        var found = this.matcher.find(stateOrName, base);
        return (found && found.self) || null;
    };
    StateRegistry.prototype.decorator = function (name, func) {
        return this.builder.builder(name, func);
    };
    return StateRegistry;
}());
exports.StateRegistry = StateRegistry;
//# sourceMappingURL=stateRegistry.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/stateService.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/stateService.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module state
 */
/** */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var queue_1 = __webpack_require__(/*! ../common/queue */ "./node_modules/@uirouter/core/lib/common/queue.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
var pathUtils_1 = __webpack_require__(/*! ../path/pathUtils */ "./node_modules/@uirouter/core/lib/path/pathUtils.js");
var pathNode_1 = __webpack_require__(/*! ../path/pathNode */ "./node_modules/@uirouter/core/lib/path/pathNode.js");
var transitionService_1 = __webpack_require__(/*! ../transition/transitionService */ "./node_modules/@uirouter/core/lib/transition/transitionService.js");
var rejectFactory_1 = __webpack_require__(/*! ../transition/rejectFactory */ "./node_modules/@uirouter/core/lib/transition/rejectFactory.js");
var targetState_1 = __webpack_require__(/*! ./targetState */ "./node_modules/@uirouter/core/lib/state/targetState.js");
var param_1 = __webpack_require__(/*! ../params/param */ "./node_modules/@uirouter/core/lib/params/param.js");
var glob_1 = __webpack_require__(/*! ../common/glob */ "./node_modules/@uirouter/core/lib/common/glob.js");
var resolveContext_1 = __webpack_require__(/*! ../resolve/resolveContext */ "./node_modules/@uirouter/core/lib/resolve/resolveContext.js");
var lazyLoad_1 = __webpack_require__(/*! ../hooks/lazyLoad */ "./node_modules/@uirouter/core/lib/hooks/lazyLoad.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
/**
 * Provides state related service functions
 *
 * This class provides services related to ui-router states.
 * An instance of this class is located on the global [[UIRouter]] object.
 */
var StateService = /** @class */ (function () {
    /** @internalapi */
    function StateService(router) {
        this.router = router;
        /** @internalapi */
        this.invalidCallbacks = [];
        /** @hidden */
        this._defaultErrorHandler = function $defaultErrorHandler($error$) {
            if ($error$ instanceof Error && $error$.stack) {
                console.error($error$);
                console.error($error$.stack);
            }
            else if ($error$ instanceof rejectFactory_1.Rejection) {
                console.error($error$.toString());
                if ($error$.detail && $error$.detail.stack)
                    console.error($error$.detail.stack);
            }
            else {
                console.error($error$);
            }
        };
        var getters = ['current', '$current', 'params', 'transition'];
        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));
        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);
    }
    Object.defineProperty(StateService.prototype, "transition", {
        /**
         * The [[Transition]] currently in progress (or null)
         *
         * This is a passthrough through to [[UIRouterGlobals.transition]]
         */
        get: function () {
            return this.router.globals.transition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "params", {
        /**
         * The latest successful state parameters
         *
         * This is a passthrough through to [[UIRouterGlobals.params]]
         */
        get: function () {
            return this.router.globals.params;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "current", {
        /**
         * The current [[StateDeclaration]]
         *
         * This is a passthrough through to [[UIRouterGlobals.current]]
         */
        get: function () {
            return this.router.globals.current;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "$current", {
        /**
         * The current [[StateObject]]
         *
         * This is a passthrough through to [[UIRouterGlobals.$current]]
         */
        get: function () {
            return this.router.globals.$current;
        },
        enumerable: true,
        configurable: true
    });
    /** @internalapi */
    StateService.prototype.dispose = function () {
        this.defaultErrorHandler(common_1.noop);
        this.invalidCallbacks = [];
    };
    /**
     * Handler for when [[transitionTo]] is called with an invalid state.
     *
     * Invokes the [[onInvalid]] callbacks, in natural order.
     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.
     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.
     *
     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.
     *
     * @internalapi
     */
    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {
        var _this = this;
        var fromState = pathUtils_1.PathUtils.makeTargetState(this.router.stateRegistry, fromPath);
        var globals = this.router.globals;
        var latestThing = function () { return globals.transitionHistory.peekTail(); };
        var latest = latestThing();
        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());
        var injector = new resolveContext_1.ResolveContext(fromPath).injector();
        var checkForRedirect = function (result) {
            if (!(result instanceof targetState_1.TargetState)) {
                return;
            }
            var target = result;
            // Recreate the TargetState, in case the state is now defined.
            target = _this.target(target.identifier(), target.params(), target.options());
            if (!target.valid()) {
                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();
            }
            if (latestThing() !== latest) {
                return rejectFactory_1.Rejection.superseded().toPromise();
            }
            return _this.transitionTo(target.identifier(), target.params(), target.options());
        };
        function invokeNextCallback() {
            var nextCallback = callbackQueue.dequeue();
            if (nextCallback === undefined)
                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();
            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));
            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });
        }
        return invokeNextCallback();
    };
    /**
     * Registers an Invalid State handler
     *
     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]
     * has been called with an invalid state reference parameter
     *
     * Example:
     * ```js
     * stateService.onInvalid(function(to, from, injector) {
     *   if (to.name() === 'foo') {
     *     let lazyLoader = injector.get('LazyLoadService');
     *     return lazyLoader.load('foo')
     *         .then(() => stateService.target('foo'));
     *   }
     * });
     * ```
     *
     * @param {function} callback invoked when the toState is invalid
     *   This function receives the (invalid) toState, the fromState, and an injector.
     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.
     *   If one is returned, it is treated as a redirect.
     *
     * @returns a function which deregisters the callback
     */
    StateService.prototype.onInvalid = function (callback) {
        this.invalidCallbacks.push(callback);
        return function deregisterListener() {
            common_1.removeFrom(this.invalidCallbacks)(callback);
        }.bind(this);
    };
    /**
     * Reloads the current state
     *
     * A method that force reloads the current state, or a partial state hierarchy.
     * All resolves are re-resolved, and components reinstantiated.
     *
     * #### Example:
     * ```js
     * let app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     $state.reload();
     *   }
     * });
     * ```
     *
     * Note: `reload()` is just an alias for:
     *
     * ```js
     * $state.transitionTo($state.current, $state.params, {
     *   reload: true, inherit: false
     * });
     * ```
     *
     * @param reloadState A state name or a state object.
     *    If present, this state and all its children will be reloaded, but ancestors will not reload.
     *
     * #### Example:
     * ```js
     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'
     * //and current state is 'contacts.detail.item'
     * let app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     //will reload 'contact.detail' and nested 'contact.detail.item' states
     *     $state.reload('contact.detail');
     *   }
     * });
     * ```
     *
     * @returns A promise representing the state of the new transition. See [[StateService.go]]
     */
    StateService.prototype.reload = function (reloadState) {
        return this.transitionTo(this.current, this.params, {
            reload: predicates_1.isDefined(reloadState) ? reloadState : true,
            inherit: false,
            notify: false,
        });
    };
    /**
     * Transition to a different state and/or parameters
     *
     * Convenience method for transitioning to a new state.
     *
     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to
     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.
     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).
     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters
     * inherit from the current parameter values (because of `inherit: true`).
     *
     * #### Example:
     * ```js
     * let app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.go('contact.detail');
     *   };
     * });
     * ```
     *
     * @param to Absolute state name, state object, or relative state path (relative to current state).
     *
     * Some examples:
     *
     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
     * - `$state.go('^')` - will go to the parent state
     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state
     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state
     *
     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.
     *
     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).
     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.
     *
     * @param options Transition options
     *
     * @returns {promise} A promise representing the state of the new transition.
     */
    StateService.prototype.go = function (to, params, options) {
        var defautGoOpts = { relative: this.$current, inherit: true };
        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);
        return this.transitionTo(to, params, transOpts);
    };
    /**
     * Creates a [[TargetState]]
     *
     * This is a factory method for creating a TargetState
     *
     * This may be returned from a Transition Hook to redirect a transition, for example.
     */
    StateService.prototype.target = function (identifier, params, options) {
        if (options === void 0) { options = {}; }
        // If we're reloading, find the state object to reload from
        if (predicates_1.isObject(options.reload) && !options.reload.name)
            throw new Error('Invalid reload state object');
        var reg = this.router.stateRegistry;
        options.reloadState =
            options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);
        if (options.reload && !options.reloadState)
            throw new Error("No such reload state '" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + "'");
        return new targetState_1.TargetState(this.router.stateRegistry, identifier, params, options);
    };
    StateService.prototype.getCurrentPath = function () {
        var _this = this;
        var globals = this.router.globals;
        var latestSuccess = globals.successfulTransitions.peekTail();
        var rootPath = function () { return [new pathNode_1.PathNode(_this.router.stateRegistry.root())]; };
        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();
    };
    /**
     * Low-level method for transitioning to a new state.
     *
     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.
     *
     * #### Example:
     * ```js
     * let app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.transitionTo('contact.detail');
     *   };
     * });
     * ```
     *
     * @param to State name or state object.
     * @param toParams A map of the parameters that will be sent to the state,
     *      will populate $stateParams.
     * @param options Transition options
     *
     * @returns A promise representing the state of the new transition. See [[go]]
     */
    StateService.prototype.transitionTo = function (to, toParams, options) {
        var _this = this;
        if (toParams === void 0) { toParams = {}; }
        if (options === void 0) { options = {}; }
        var router = this.router;
        var globals = router.globals;
        options = common_1.defaults(options, transitionService_1.defaultTransOpts);
        var getCurrent = function () { return globals.transition; };
        options = common_1.extend(options, { current: getCurrent });
        var ref = this.target(to, toParams, options);
        var currentPath = this.getCurrentPath();
        if (!ref.exists())
            return this._handleInvalidTargetState(currentPath, ref);
        if (!ref.valid())
            return common_1.silentRejection(ref.error());
        /**
         * Special handling for Ignored, Aborted, and Redirected transitions
         *
         * The semantics for the transition.run() promise and the StateService.transitionTo()
         * promise differ. For instance, the run() promise may be rejected because it was
         * IGNORED, but the transitionTo() promise is resolved because from the user perspective
         * no error occurred.  Likewise, the transition.run() promise may be rejected because of
         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.
         */
        var rejectedTransitionHandler = function (trans) { return function (error) {
            if (error instanceof rejectFactory_1.Rejection) {
                var isLatest = router.globals.lastStartedTransitionId === trans.$id;
                if (error.type === rejectFactory_1.RejectType.IGNORED) {
                    isLatest && router.urlRouter.update();
                    // Consider ignored `Transition.run()` as a successful `transitionTo`
                    return coreservices_1.services.$q.when(globals.current);
                }
                var detail = error.detail;
                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {
                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully
                    // by returning the promise for the new (redirect) `Transition.run()`.
                    var redirect = trans.redirect(detail);
                    return redirect.run().catch(rejectedTransitionHandler(redirect));
                }
                if (error.type === rejectFactory_1.RejectType.ABORTED) {
                    isLatest && router.urlRouter.update();
                    return coreservices_1.services.$q.reject(error);
                }
            }
            var errorHandler = _this.defaultErrorHandler();
            errorHandler(error);
            return coreservices_1.services.$q.reject(error);
        }; };
        var transition = this.router.transitionService.create(currentPath, ref);
        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));
        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676
        // Return a promise for the transition, which also has the transition object on it.
        return common_1.extend(transitionToPromise, { transition: transition });
    };
    /**
     * Checks if the current state *is* the provided state
     *
     * Similar to [[includes]] but only checks for the full state name.
     * If params is supplied then it will be tested for strict equality against the current
     * active params object, so all params must match with none missing and no extras.
     *
     * #### Example:
     * ```js
     * $state.$current.name = 'contacts.details.item';
     *
     * // absolute name
     * $state.is('contact.details.item'); // returns true
     * $state.is(contactDetailItemStateObject); // returns true
     * ```
     *
     * // relative name (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * ```html
     * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
     * ```
     *
     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.
     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like
     * to test against the current active state.
     * @param options An options object. The options are:
     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
     *     test relative to `options.relative` state (or name).
     *
     * @returns Returns true if it is the state.
     */
    StateService.prototype.is = function (stateOrName, params, options) {
        options = common_1.defaults(options, { relative: this.$current });
        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
        if (!predicates_1.isDefined(state))
            return undefined;
        if (this.$current !== state)
            return false;
        if (!params)
            return true;
        var schema = state.parameters({ inherit: true, matchingKeys: params });
        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);
    };
    /**
     * Checks if the current state *includes* the provided state
     *
     * A method to determine if the current active state is equal to or is the child of the
     * state stateName. If any params are passed then they will be tested for a match as well.
     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
     *
     * #### Example when `$state.$current.name === 'contacts.details.item'`
     * ```js
     * // Using partial names
     * $state.includes("contacts"); // returns true
     * $state.includes("contacts.details"); // returns true
     * $state.includes("contacts.details.item"); // returns true
     * $state.includes("contacts.list"); // returns false
     * $state.includes("about"); // returns false
     * ```
     *
     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:
     * ```js
     * $state.includes("*.details.*.*"); // returns true
     * $state.includes("*.details.**"); // returns true
     * $state.includes("**.item.**"); // returns true
     * $state.includes("*.details.item.url"); // returns true
     * $state.includes("*.details.*.url"); // returns true
     * $state.includes("*.details.*"); // returns false
     * $state.includes("item.**"); // returns false
     * ```
     *
     * @param stateOrName A partial name, relative name, glob pattern,
     *   or state object to be searched for within the current state name.
     * @param params A param object, e.g. `{sectionId: section.id}`,
     *   that you'd like to test against the current active state.
     * @param options An options object. The options are:
     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
     *     test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it does include the state
     */
    StateService.prototype.includes = function (stateOrName, params, options) {
        options = common_1.defaults(options, { relative: this.$current });
        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);
        if (glob) {
            if (!glob.matches(this.$current.name))
                return false;
            stateOrName = this.$current.name;
        }
        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;
        if (!predicates_1.isDefined(state))
            return undefined;
        if (!predicates_1.isDefined(include[state.name]))
            return false;
        if (!params)
            return true;
        var schema = state.parameters({ inherit: true, matchingKeys: params });
        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);
    };
    /**
     * Generates a URL for a state and parameters
     *
     * Returns the url for the given state populated with the given params.
     *
     * #### Example:
     * ```js
     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
     * ```
     *
     * @param stateOrName The state name or state object you'd like to generate a url from.
     * @param params An object of parameter values to fill the state's required parameters.
     * @param options Options object. The options are:
     *
     * @returns {string} compiled state url
     */
    StateService.prototype.href = function (stateOrName, params, options) {
        var defaultHrefOpts = {
            lossy: true,
            inherit: true,
            absolute: false,
            relative: this.$current,
        };
        options = common_1.defaults(options, defaultHrefOpts);
        params = params || {};
        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
        if (!predicates_1.isDefined(state))
            return null;
        if (options.inherit)
            params = this.params.$inherit(params, this.$current, state);
        var nav = state && options.lossy ? state.navigable : state;
        if (!nav || nav.url === undefined || nav.url === null) {
            return null;
        }
        return this.router.urlRouter.href(nav.url, params, {
            absolute: options.absolute,
        });
    };
    /**
     * Sets or gets the default [[transitionTo]] error handler.
     *
     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.
     * This includes errors caused by resolves and transition hooks.
     *
     * Note:
     * This handler does not receive certain Transition rejections.
     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].
     *
     * The built-in default error handler logs the error to the console.
     *
     * You can provide your own custom handler.
     *
     * #### Example:
     * ```js
     * stateService.defaultErrorHandler(function() {
     *   // Do not log transitionTo errors
     * });
     * ```
     *
     * @param handler a global error handler function
     * @returns the current global error handler
     */
    StateService.prototype.defaultErrorHandler = function (handler) {
        return (this._defaultErrorHandler = handler || this._defaultErrorHandler);
    };
    StateService.prototype.get = function (stateOrName, base) {
        var reg = this.router.stateRegistry;
        if (arguments.length === 0)
            return reg.get();
        return reg.get(stateOrName, base || this.$current);
    };
    /**
     * Lazy loads a state
     *
     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.
     *
     * @param stateOrName the state that should be lazy loaded
     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)
     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.
     * This noop transition is not actually run.
     *
     * @returns a promise to lazy load
     */
    StateService.prototype.lazyLoad = function (stateOrName, transition) {
        var state = this.get(stateOrName);
        if (!state || !state.lazyLoad)
            throw new Error('Can not lazy load ' + stateOrName);
        var currentPath = this.getCurrentPath();
        var target = pathUtils_1.PathUtils.makeTargetState(this.router.stateRegistry, currentPath);
        transition = transition || this.router.transitionService.create(currentPath, target);
        return lazyLoad_1.lazyLoadState(transition, state);
    };
    return StateService;
}());
exports.StateService = StateService;
//# sourceMappingURL=stateService.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/state/targetState.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/state/targetState.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module state
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var strings_1 = __webpack_require__(/*! ../common/strings */ "./node_modules/@uirouter/core/lib/common/strings.js");
var common_1 = __webpack_require__(/*! ../common */ "./node_modules/@uirouter/core/lib/common/index.js");
/**
 * Encapsulate the target (destination) state/params/options of a [[Transition]].
 *
 * This class is frequently used to redirect a transition to a new destination.
 *
 * See:
 *
 * - [[HookResult]]
 * - [[TransitionHookFn]]
 * - [[TransitionService.onStart]]
 *
 * To create a `TargetState`, use [[StateService.target]].
 *
 * ---
 *
 * This class wraps:
 *
 * 1) an identifier for a state
 * 2) a set of parameters
 * 3) and transition options
 * 4) the registered state object (the [[StateDeclaration]])
 *
 * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can
 * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).
 * The `TargetState` class normalizes those options.
 *
 * A `TargetState` may be valid (the state being targeted exists in the registry)
 * or invalid (the state being targeted is not registered).
 */
var TargetState = /** @class */ (function () {
    /**
     * The TargetState constructor
     *
     * Note: Do not construct a `TargetState` manually.
     * To create a `TargetState`, use the [[StateService.target]] factory method.
     *
     * @param _stateRegistry The StateRegistry to use to look up the _definition
     * @param _identifier An identifier for a state.
     *    Either a fully-qualified state name, or the object used to define the state.
     * @param _params Parameters for the target state
     * @param _options Transition options.
     *
     * @internalapi
     */
    function TargetState(_stateRegistry, _identifier, _params, _options) {
        this._stateRegistry = _stateRegistry;
        this._identifier = _identifier;
        this._identifier = _identifier;
        this._params = common_1.extend({}, _params || {});
        this._options = common_1.extend({}, _options || {});
        this._definition = _stateRegistry.matcher.find(_identifier, this._options.relative);
    }
    /** The name of the state this object targets */
    TargetState.prototype.name = function () {
        return (this._definition && this._definition.name) || this._identifier;
    };
    /** The identifier used when creating this TargetState */
    TargetState.prototype.identifier = function () {
        return this._identifier;
    };
    /** The target parameter values */
    TargetState.prototype.params = function () {
        return this._params;
    };
    /** The internal state object (if it was found) */
    TargetState.prototype.$state = function () {
        return this._definition;
    };
    /** The internal state declaration (if it was found) */
    TargetState.prototype.state = function () {
        return this._definition && this._definition.self;
    };
    /** The target options */
    TargetState.prototype.options = function () {
        return this._options;
    };
    /** True if the target state was found */
    TargetState.prototype.exists = function () {
        return !!(this._definition && this._definition.self);
    };
    /** True if the object is valid */
    TargetState.prototype.valid = function () {
        return !this.error();
    };
    /** If the object is invalid, returns the reason why */
    TargetState.prototype.error = function () {
        var base = this.options().relative;
        if (!this._definition && !!base) {
            var stateName = base.name ? base.name : base;
            return "Could not resolve '" + this.name() + "' from state '" + stateName + "'";
        }
        if (!this._definition)
            return "No such state '" + this.name() + "'";
        if (!this._definition.self)
            return "State '" + this.name() + "' has an invalid definition";
    };
    TargetState.prototype.toString = function () {
        return "'" + this.name() + "'" + strings_1.stringify(this.params());
    };
    /**
     * Returns a copy of this TargetState which targets a different state.
     * The new TargetState has the same parameter values and transition options.
     *
     * @param state The new state that should be targeted
     */
    TargetState.prototype.withState = function (state) {
        return new TargetState(this._stateRegistry, state, this._params, this._options);
    };
    /**
     * Returns a copy of this TargetState, using the specified parameter values.
     *
     * @param params the new parameter values to use
     * @param replace When false (default) the new parameter values will be merged with the current values.
     *                When true the parameter values will be used instead of the current values.
     */
    TargetState.prototype.withParams = function (params, replace) {
        if (replace === void 0) { replace = false; }
        var newParams = replace ? params : common_1.extend({}, this._params, params);
        return new TargetState(this._stateRegistry, this._identifier, newParams, this._options);
    };
    /**
     * Returns a copy of this TargetState, using the specified Transition Options.
     *
     * @param options the new options to use
     * @param replace When false (default) the new options will be merged with the current options.
     *                When true the options will be used instead of the current options.
     */
    TargetState.prototype.withOptions = function (options, replace) {
        if (replace === void 0) { replace = false; }
        var newOpts = replace ? options : common_1.extend({}, this._options, options);
        return new TargetState(this._stateRegistry, this._identifier, this._params, newOpts);
    };
    /** Returns true if the object has a state property that might be a state or state name */
    TargetState.isDef = function (obj) { return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name)); };
    return TargetState;
}());
exports.TargetState = TargetState;
//# sourceMappingURL=targetState.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/hookBuilder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/hookBuilder.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module transition
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var interface_1 = __webpack_require__(/*! ./interface */ "./node_modules/@uirouter/core/lib/transition/interface.js");
var transitionHook_1 = __webpack_require__(/*! ./transitionHook */ "./node_modules/@uirouter/core/lib/transition/transitionHook.js");
/**
 * This class returns applicable TransitionHooks for a specific Transition instance.
 *
 * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.
 * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is
 * determined by the type of hook)
 *
 * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.
 *
 * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder
 * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private
 * in the Transition class, so we must also provide the Transition's _treeChanges)
 *
 */
var HookBuilder = /** @class */ (function () {
    function HookBuilder(transition) {
        this.transition = transition;
    }
    HookBuilder.prototype.buildHooksForPhase = function (phase) {
        var _this = this;
        var $transitions = this.transition.router.transitionService;
        return $transitions._pluginapi
            ._getEvents(phase)
            .map(function (type) { return _this.buildHooks(type); })
            .reduce(common_1.unnestR, [])
            .filter(common_1.identity);
    };
    /**
     * Returns an array of newly built TransitionHook objects.
     *
     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].
     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)
     * - For each of the [[PathNode]]s, creates a TransitionHook
     *
     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.
     */
    HookBuilder.prototype.buildHooks = function (hookType) {
        var transition = this.transition;
        var treeChanges = transition.treeChanges();
        // Find all the matching registered hooks for a given hook type
        var matchingHooks = this.getMatchingHooks(hookType, treeChanges);
        if (!matchingHooks)
            return [];
        var baseHookOptions = {
            transition: transition,
            current: transition.options().current,
        };
        var makeTransitionHooks = function (hook) {
            // Fetch the Nodes that caused this hook to match.
            var matches = hook.matches(treeChanges);
            // Select the PathNode[] that will be used as TransitionHook context objects
            var matchingNodes = matches[hookType.criteriaMatchPath.name];
            // Return an array of HookTuples
            return matchingNodes.map(function (node) {
                var _options = common_1.extend({
                    bind: hook.bind,
                    traceData: { hookType: hookType.name, context: node },
                }, baseHookOptions);
                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state.self : null;
                var transitionHook = new transitionHook_1.TransitionHook(transition, state, hook, _options);
                return { hook: hook, node: node, transitionHook: transitionHook };
            });
        };
        return matchingHooks
            .map(makeTransitionHooks)
            .reduce(common_1.unnestR, [])
            .sort(tupleSort(hookType.reverseSort))
            .map(function (tuple) { return tuple.transitionHook; });
    };
    /**
     * Finds all RegisteredHooks from:
     * - The Transition object instance hook registry
     * - The TransitionService ($transitions) global hook registry
     *
     * which matched:
     * - the eventType
     * - the matchCriteria (to, from, exiting, retained, entering)
     *
     * @returns an array of matched [[RegisteredHook]]s
     */
    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {
        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;
        // Instance and Global hook registries
        var $transitions = this.transition.router.transitionService;
        var registries = isCreate ? [$transitions] : [this.transition, $transitions];
        return registries
            .map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries
            .filter(common_1.assertPredicate(predicates_1.isArray, "broken event named: " + hookType.name)) // Sanity check
            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array
            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria
    };
    return HookBuilder;
}());
exports.HookBuilder = HookBuilder;
/**
 * A factory for a sort function for HookTuples.
 *
 * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares
 * the EventHook priority.
 *
 * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth
 * @returns a tuple sort function
 */
function tupleSort(reverseDepthSort) {
    if (reverseDepthSort === void 0) { reverseDepthSort = false; }
    return function nodeDepthThenPriority(l, r) {
        var factor = reverseDepthSort ? -1 : 1;
        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;
        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;
    };
}
//# sourceMappingURL=hookBuilder.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/hookRegistry.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/hookRegistry.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */ /** for typedoc */
var common_1 = __webpack_require__(/*! ../common */ "./node_modules/@uirouter/core/lib/common/index.js");
var interface_1 = __webpack_require__(/*! ./interface */ "./node_modules/@uirouter/core/lib/transition/interface.js");
/**
 * Determines if the given state matches the matchCriteria
 *
 * @hidden
 *
 * @param state a State Object to test against
 * @param criterion
 * - If a string, matchState uses the string as a glob-matcher against the state name
 * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name
 *   and returns a positive match if any of the globs match.
 * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.
 * @returns {boolean}
 */
function matchState(state, criterion) {
    var toMatch = common_1.isString(criterion) ? [criterion] : criterion;
    function matchGlobs(_state) {
        var globStrings = toMatch;
        for (var i = 0; i < globStrings.length; i++) {
            var glob = new common_1.Glob(globStrings[i]);
            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {
                return true;
            }
        }
        return false;
    }
    var matchFn = (common_1.isFunction(toMatch) ? toMatch : matchGlobs);
    return !!matchFn(state);
}
exports.matchState = matchState;
/**
 * @internalapi
 * The registration data for a registered transition hook
 */
var RegisteredHook = /** @class */ (function () {
    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {
        if (options === void 0) { options = {}; }
        this.tranSvc = tranSvc;
        this.eventType = eventType;
        this.callback = callback;
        this.matchCriteria = matchCriteria;
        this.removeHookFromRegistry = removeHookFromRegistry;
        this.invokeCount = 0;
        this._deregistered = false;
        this.priority = options.priority || 0;
        this.bind = options.bind || null;
        this.invokeLimit = options.invokeLimit;
    }
    /**
     * Gets the matching [[PathNode]]s
     *
     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing
     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.
     *
     * Returning `null` is significant to distinguish between the default
     * "match-all criterion value" of `true` compared to a `() => true` function,
     * when the nodes is an empty array.
     *
     * This is useful to allow a transition match criteria of `entering: true`
     * to still match a transition, even when `entering === []`.  Contrast that
     * with `entering: (state) => true` which only matches when a state is actually
     * being entered.
     */
    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {
        if (criterion === true)
            return nodes;
        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });
        return matching.length ? matching : null;
    };
    /**
     * Gets the default match criteria (all `true`)
     *
     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:
     *
     * ```js
     * {
     *   to: true,
     *   from: true,
     *   entering: true,
     *   exiting: true,
     *   retained: true,
     * }
     */
    RegisteredHook.prototype._getDefaultMatchCriteria = function () {
        return common_1.mapObj(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });
    };
    /**
     * Gets matching nodes as [[IMatchingNodes]]
     *
     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:
     *
     * ```js
     * let matches: IMatchingNodes = {
     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),
     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),
     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),
     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),
     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),
     * };
     * ```
     */
    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {
        var _this = this;
        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);
        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());
        return paths.reduce(function (mn, pathtype) {
            // STATE scope criteria matches against every node in the path.
            // TRANSITION scope criteria matches against only the last node in the path
            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;
            var path = treeChanges[pathtype.name] || [];
            var nodes = isStateHook ? path : [common_1.tail(path)];
            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);
            return mn;
        }, {});
    };
    /**
     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]
     *
     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values
     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)
     */
    RegisteredHook.prototype.matches = function (treeChanges) {
        var matches = this._getMatchingNodes(treeChanges);
        // Check if all the criteria matched the TreeChanges object
        var allMatched = common_1.values(matches).every(common_1.identity);
        return allMatched ? matches : null;
    };
    RegisteredHook.prototype.deregister = function () {
        this.removeHookFromRegistry(this);
        this._deregistered = true;
    };
    return RegisteredHook;
}());
exports.RegisteredHook = RegisteredHook;
/** @hidden Return a registration function of the requested type. */
function makeEvent(registry, transitionService, eventType) {
    // Create the object which holds the registered transition hooks.
    var _registeredHooks = (registry._registeredHooks = registry._registeredHooks || {});
    var hooks = (_registeredHooks[eventType.name] = []);
    var removeHookFn = common_1.removeFrom(hooks);
    // Create hook registration function on the IHookRegistry for the event
    registry[eventType.name] = hookRegistrationFn;
    function hookRegistrationFn(matchObject, callback, options) {
        if (options === void 0) { options = {}; }
        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);
        hooks.push(registeredHook);
        return registeredHook.deregister.bind(registeredHook);
    }
    return hookRegistrationFn;
}
exports.makeEvent = makeEvent;
//# sourceMappingURL=hookRegistry.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * # Transition subsystem
 *
 * This module contains APIs related to a Transition.
 *
 * See:
 * - [[TransitionService]]
 * - [[Transition]]
 * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]
 *
 * @coreapi
 * @preferred
 * @module transition
 */ /** for typedoc */
__export(__webpack_require__(/*! ./interface */ "./node_modules/@uirouter/core/lib/transition/interface.js"));
__export(__webpack_require__(/*! ./hookBuilder */ "./node_modules/@uirouter/core/lib/transition/hookBuilder.js"));
__export(__webpack_require__(/*! ./hookRegistry */ "./node_modules/@uirouter/core/lib/transition/hookRegistry.js"));
__export(__webpack_require__(/*! ./rejectFactory */ "./node_modules/@uirouter/core/lib/transition/rejectFactory.js"));
__export(__webpack_require__(/*! ./transition */ "./node_modules/@uirouter/core/lib/transition/transition.js"));
__export(__webpack_require__(/*! ./transitionHook */ "./node_modules/@uirouter/core/lib/transition/transitionHook.js"));
__export(__webpack_require__(/*! ./transitionEventType */ "./node_modules/@uirouter/core/lib/transition/transitionEventType.js"));
__export(__webpack_require__(/*! ./transitionService */ "./node_modules/@uirouter/core/lib/transition/transitionService.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/interface.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/interface.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TransitionHookPhase;
(function (TransitionHookPhase) {
    TransitionHookPhase[TransitionHookPhase["CREATE"] = 0] = "CREATE";
    TransitionHookPhase[TransitionHookPhase["BEFORE"] = 1] = "BEFORE";
    TransitionHookPhase[TransitionHookPhase["RUN"] = 2] = "RUN";
    TransitionHookPhase[TransitionHookPhase["SUCCESS"] = 3] = "SUCCESS";
    TransitionHookPhase[TransitionHookPhase["ERROR"] = 4] = "ERROR";
})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));
var TransitionHookScope;
(function (TransitionHookScope) {
    TransitionHookScope[TransitionHookScope["TRANSITION"] = 0] = "TRANSITION";
    TransitionHookScope[TransitionHookScope["STATE"] = 1] = "STATE";
})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/rejectFactory.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/rejectFactory.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @coreapi
 * @module transition
 */ /** for typedoc */

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var strings_1 = __webpack_require__(/*! ../common/strings */ "./node_modules/@uirouter/core/lib/common/strings.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var RejectType;
(function (RejectType) {
    /**
     * A new transition superseded this one.
     *
     * While this transition was running, a new transition started.
     * This transition is cancelled because it was superseded by new transition.
     */
    RejectType[RejectType["SUPERSEDED"] = 2] = "SUPERSEDED";
    /**
     * The transition was aborted
     *
     * The transition was aborted by a hook which returned `false`
     */
    RejectType[RejectType["ABORTED"] = 3] = "ABORTED";
    /**
     * The transition was invalid
     *
     * The transition was never started because it was invalid
     */
    RejectType[RejectType["INVALID"] = 4] = "INVALID";
    /**
     * The transition was ignored
     *
     * The transition was ignored because it would have no effect.
     *
     * Either:
     *
     * - The transition is targeting the current state and parameter values
     * - The transition is targeting the same state and parameter values as the currently running transition.
     */
    RejectType[RejectType["IGNORED"] = 5] = "IGNORED";
    /**
     * The transition errored.
     *
     * This generally means a hook threw an error or returned a rejected promise
     */
    RejectType[RejectType["ERROR"] = 6] = "ERROR";
})(RejectType = exports.RejectType || (exports.RejectType = {}));
/** @hidden */
var id = 0;
var Rejection = /** @class */ (function () {
    function Rejection(type, message, detail) {
        /** @hidden */
        this.$id = id++;
        this.type = type;
        this.message = message;
        this.detail = detail;
    }
    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */
    Rejection.isRejectionPromise = function (obj) {
        return obj && typeof obj.then === 'function' && hof_1.is(Rejection)(obj._transitionRejection);
    };
    /** Returns a Rejection due to transition superseded */
    Rejection.superseded = function (detail, options) {
        var message = 'The transition has been superseded by a different transition';
        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);
        if (options && options.redirected) {
            rejection.redirected = true;
        }
        return rejection;
    };
    /** Returns a Rejection due to redirected transition */
    Rejection.redirected = function (detail) {
        return Rejection.superseded(detail, { redirected: true });
    };
    /** Returns a Rejection due to invalid transition */
    Rejection.invalid = function (detail) {
        var message = 'This transition is invalid';
        return new Rejection(RejectType.INVALID, message, detail);
    };
    /** Returns a Rejection due to ignored transition */
    Rejection.ignored = function (detail) {
        var message = 'The transition was ignored';
        return new Rejection(RejectType.IGNORED, message, detail);
    };
    /** Returns a Rejection due to aborted transition */
    Rejection.aborted = function (detail) {
        var message = 'The transition has been aborted';
        return new Rejection(RejectType.ABORTED, message, detail);
    };
    /** Returns a Rejection due to aborted transition */
    Rejection.errored = function (detail) {
        var message = 'The transition errored';
        return new Rejection(RejectType.ERROR, message, detail);
    };
    /**
     * Returns a Rejection
     *
     * Normalizes a value as a Rejection.
     * If the value is already a Rejection, returns it.
     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).
     *
     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.
     */
    Rejection.normalize = function (detail) {
        return hof_1.is(Rejection)(detail) ? detail : Rejection.errored(detail);
    };
    Rejection.prototype.toString = function () {
        var detailString = function (d) { return (d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d)); };
        var detail = detailString(this.detail);
        var _a = this, $id = _a.$id, type = _a.type, message = _a.message;
        return "Transition Rejection($id: " + $id + " type: " + type + ", message: " + message + ", detail: " + detail + ")";
    };
    Rejection.prototype.toPromise = function () {
        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });
    };
    return Rejection;
}());
exports.Rejection = Rejection;
//# sourceMappingURL=rejectFactory.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/transition.js":
/*!******************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/transition.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */
/** for typedoc */
var trace_1 = __webpack_require__(/*! ../common/trace */ "./node_modules/@uirouter/core/lib/common/trace.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
var strings_1 = __webpack_require__(/*! ../common/strings */ "./node_modules/@uirouter/core/lib/common/strings.js");
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var interface_1 = __webpack_require__(/*! ./interface */ "./node_modules/@uirouter/core/lib/transition/interface.js"); // has or is using
var transitionHook_1 = __webpack_require__(/*! ./transitionHook */ "./node_modules/@uirouter/core/lib/transition/transitionHook.js");
var hookRegistry_1 = __webpack_require__(/*! ./hookRegistry */ "./node_modules/@uirouter/core/lib/transition/hookRegistry.js");
var hookBuilder_1 = __webpack_require__(/*! ./hookBuilder */ "./node_modules/@uirouter/core/lib/transition/hookBuilder.js");
var pathUtils_1 = __webpack_require__(/*! ../path/pathUtils */ "./node_modules/@uirouter/core/lib/path/pathUtils.js");
var param_1 = __webpack_require__(/*! ../params/param */ "./node_modules/@uirouter/core/lib/params/param.js");
var resolvable_1 = __webpack_require__(/*! ../resolve/resolvable */ "./node_modules/@uirouter/core/lib/resolve/resolvable.js");
var resolveContext_1 = __webpack_require__(/*! ../resolve/resolveContext */ "./node_modules/@uirouter/core/lib/resolve/resolveContext.js");
var rejectFactory_1 = __webpack_require__(/*! ./rejectFactory */ "./node_modules/@uirouter/core/lib/transition/rejectFactory.js");
/** @hidden */
var stateSelf = hof_1.prop('self');
/**
 * Represents a transition between two states.
 *
 * When navigating to a state, we are transitioning **from** the current state **to** the new state.
 *
 * This object contains all contextual information about the to/from states, parameters, resolves.
 * It has information about all states being entered and exited as a result of the transition.
 */
var Transition = /** @class */ (function () {
    /**
     * Creates a new Transition object.
     *
     * If the target state is not valid, an error is thrown.
     *
     * @internalapi
     *
     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`
     *        encapsulates the "from state".
     * @param targetState The target state and parameters being transitioned to (also, the transition options)
     * @param router The [[UIRouter]] instance
     */
    function Transition(fromPath, targetState, router) {
        var _this = this;
        /** @hidden */
        this._deferred = coreservices_1.services.$q.defer();
        /**
         * This promise is resolved or rejected based on the outcome of the Transition.
         *
         * When the transition is successful, the promise is resolved
         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error
         */
        this.promise = this._deferred.promise;
        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */
        this._registeredHooks = {};
        /** @hidden */
        this._hookBuilder = new hookBuilder_1.HookBuilder(this);
        /** Checks if this transition is currently active/running. */
        this.isActive = function () { return _this.router.globals.transition === _this; };
        this.router = router;
        this._targetState = targetState;
        if (!targetState.valid()) {
            throw new Error(targetState.error());
        }
        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.
        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());
        this.$id = router.transitionService._transitionCount++;
        var toPath = pathUtils_1.PathUtils.buildToPath(fromPath, targetState);
        this._treeChanges = pathUtils_1.PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);
        this.createTransitionHookRegFns();
        var onCreateHooks = this._hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);
        transitionHook_1.TransitionHook.invokeHooks(onCreateHooks, function () { return null; });
        this.applyViewConfigs(router);
    }
    /** @hidden */
    Transition.prototype.onBefore = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    Transition.prototype.onStart = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    Transition.prototype.onExit = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    Transition.prototype.onRetain = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    Transition.prototype.onEnter = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    Transition.prototype.onFinish = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    Transition.prototype.onSuccess = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    Transition.prototype.onError = function (criteria, callback, options) {
        return;
    };
    /** @hidden
     * Creates the transition-level hook registration functions
     * (which can then be used to register hooks)
     */
    Transition.prototype.createTransitionHookRegFns = function () {
        var _this = this;
        this.router.transitionService._pluginapi
            ._getEvents()
            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })
            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });
    };
    /** @internalapi */
    Transition.prototype.getHooks = function (hookName) {
        return this._registeredHooks[hookName];
    };
    Transition.prototype.applyViewConfigs = function (router) {
        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });
        pathUtils_1.PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);
    };
    /**
     * @internalapi
     *
     * @returns the internal from [State] object
     */
    Transition.prototype.$from = function () {
        return common_1.tail(this._treeChanges.from).state;
    };
    /**
     * @internalapi
     *
     * @returns the internal to [State] object
     */
    Transition.prototype.$to = function () {
        return common_1.tail(this._treeChanges.to).state;
    };
    /**
     * Returns the "from state"
     *
     * Returns the state that the transition is coming *from*.
     *
     * @returns The state declaration object for the Transition's ("from state").
     */
    Transition.prototype.from = function () {
        return this.$from().self;
    };
    /**
     * Returns the "to state"
     *
     * Returns the state that the transition is going *to*.
     *
     * @returns The state declaration object for the Transition's target state ("to state").
     */
    Transition.prototype.to = function () {
        return this.$to().self;
    };
    /**
     * Gets the Target State
     *
     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.
     *
     * @returns the [[TargetState]] of this Transition
     */
    Transition.prototype.targetState = function () {
        return this._targetState;
    };
    /**
     * Determines whether two transitions are equivalent.
     * @deprecated
     */
    Transition.prototype.is = function (compare) {
        if (compare instanceof Transition) {
            // TODO: Also compare parameters
            return this.is({ to: compare.$to().name, from: compare.$from().name });
        }
        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||
            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));
    };
    Transition.prototype.params = function (pathname) {
        if (pathname === void 0) { pathname = 'to'; }
        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}));
    };
    /**
     * Creates a [[UIInjector]] Dependency Injector
     *
     * Returns a Dependency Injector for the Transition's target state (to state).
     * The injector provides resolve values which the target state has access to.
     *
     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).
     *
     * #### Example:
     * ```js
     * .onEnter({ entering: 'myState' }, trans => {
     *   var myResolveValue = trans.injector().get('myResolve');
     *   // Inject a global service from the global/native injector (if it exists)
     *   var MyService = trans.injector().get('MyService');
     * })
     * ```
     *
     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.
     * You can use [[UIInjector.getAsync]] to get a promise for the data.
     * #### Example:
     * ```js
     * .onBefore({}, trans => {
     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>
     *     return myResolveValue !== 'ABORT';
     *   });
     * });
     * ```
     *
     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.
     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.
     * #### Example:
     * ```js
     * .onEnter({ to: 'foo.bar' }, trans => {
     *   // returns result of `foo` state's `myResolve` resolve
     *   // even though `foo.bar` also has a `myResolve` resolve
     *   var fooData = trans.injector('foo').get('myResolve');
     * });
     * ```
     *
     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.
     * The resolve data from the `from` path will be returned.
     * #### Example:
     * ```js
     * .onExit({ exiting: 'foo.bar' }, trans => {
     *   // Gets the resolve value of `myResolve` from the state being exited
     *   var fooData = trans.injector(null, 'from').get('myResolve');
     * });
     * ```
     *
     *
     * @param state Limits the resolves provided to only the resolves the provided state has access to.
     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.
     *
     * @returns a [[UIInjector]]
     */
    Transition.prototype.injector = function (state, pathName) {
        if (pathName === void 0) { pathName = 'to'; }
        var path = this._treeChanges[pathName];
        if (state)
            path = pathUtils_1.PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });
        return new resolveContext_1.ResolveContext(path).injector();
    };
    /**
     * Gets all available resolve tokens (keys)
     *
     * This method can be used in conjunction with [[injector]] to inspect the resolve values
     * available to the Transition.
     *
     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states
     * in the Transition's [[TreeChanges.to]] path.
     *
     * #### Example:
     * This example logs all resolve values
     * ```js
     * let tokens = trans.getResolveTokens();
     * tokens.forEach(token => console.log(token + " = " + trans.injector().get(token)));
     * ```
     *
     * #### Example:
     * This example creates promises for each resolve value.
     * This triggers fetches of resolves (if any have not yet been fetched).
     * When all promises have all settled, it logs the resolve values.
     * ```js
     * let tokens = trans.getResolveTokens();
     * let promise = tokens.map(token => trans.injector().getAsync(token));
     * Promise.all(promises).then(values => console.log("Resolved values: " + values));
     * ```
     *
     * Note: Angular 1 users whould use `$q.all()`
     *
     * @param pathname resolve context's path name (e.g., `to` or `from`)
     *
     * @returns an array of resolve tokens (keys)
     */
    Transition.prototype.getResolveTokens = function (pathname) {
        if (pathname === void 0) { pathname = 'to'; }
        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();
    };
    /**
     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.
     *
     * Allows a transition hook to dynamically add a Resolvable to this Transition.
     *
     * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).
     *
     * If a `state` argument is provided, the Resolvable is processed when that state is being entered.
     * If no `state` is provided then the root state is used.
     * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.
     * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.
     *
     * The `state` argument also scopes the resolved data.
     * The resolved data is available from the injector for that `state` and any children states.
     *
     * #### Example:
     * ```js
     * transitionService.onBefore({}, transition => {
     *   transition.addResolvable({
     *     token: 'myResolve',
     *     deps: ['MyService'],
     *     resolveFn: myService => myService.getData()
     *   });
     * });
     * ```
     *
     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])
     * @param state the state in the "to path" which should receive the new resolve (otherwise, the root state)
     */
    Transition.prototype.addResolvable = function (resolvable, state) {
        if (state === void 0) { state = ''; }
        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);
        var stateName = typeof state === 'string' ? state : state.name;
        var topath = this._treeChanges.to;
        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });
        var resolveContext = new resolveContext_1.ResolveContext(topath);
        resolveContext.addResolvables([resolvable], targetNode.state);
    };
    /**
     * Gets the transition from which this transition was redirected.
     *
     * If the current transition is a redirect, this method returns the transition that was redirected.
     *
     * #### Example:
     * ```js
     * let transitionA = $state.go('A').transition
     * transitionA.onStart({}, () => $state.target('B'));
     * $transitions.onSuccess({ to: 'B' }, (trans) => {
     *   trans.to().name === 'B'; // true
     *   trans.redirectedFrom() === transitionA; // true
     * });
     * ```
     *
     * @returns The previous Transition, or null if this Transition is not the result of a redirection
     */
    Transition.prototype.redirectedFrom = function () {
        return this._options.redirectedFrom || null;
    };
    /**
     * Gets the original transition in a redirect chain
     *
     * A transition might belong to a long chain of multiple redirects.
     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.
     *
     * #### Example:
     * ```js
     * // states
     * registry.register({ name: 'A', redirectTo: 'B' });
     * registry.register({ name: 'B', redirectTo: 'C' });
     * registry.register({ name: 'C', redirectTo: 'D' });
     * registry.register({ name: 'D' });
     *
     * let transitionA = $state.go('A').transition
     *
     * $transitions.onSuccess({ to: 'D' }, (trans) => {
     *   trans.to().name === 'D'; // true
     *   trans.redirectedFrom().to().name === 'C'; // true
     *   trans.originalTransition() === transitionA; // true
     *   trans.originalTransition().to().name === 'A'; // true
     * });
     * ```
     *
     * @returns The original Transition that started a redirect chain
     */
    Transition.prototype.originalTransition = function () {
        var rf = this.redirectedFrom();
        return (rf && rf.originalTransition()) || this;
    };
    /**
     * Get the transition options
     *
     * @returns the options for this Transition.
     */
    Transition.prototype.options = function () {
        return this._options;
    };
    /**
     * Gets the states being entered.
     *
     * @returns an array of states that will be entered during this transition.
     */
    Transition.prototype.entering = function () {
        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);
    };
    /**
     * Gets the states being exited.
     *
     * @returns an array of states that will be exited during this transition.
     */
    Transition.prototype.exiting = function () {
        return common_1.map(this._treeChanges.exiting, hof_1.prop('state'))
            .map(stateSelf)
            .reverse();
    };
    /**
     * Gets the states being retained.
     *
     * @returns an array of states that are already entered from a previous Transition, that will not be
     *    exited during this Transition
     */
    Transition.prototype.retained = function () {
        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);
    };
    /**
     * Get the [[ViewConfig]]s associated with this Transition
     *
     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.
     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., "to" or "entering").
     *
     * @param pathname the name of the path to fetch views for:
     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)
     * @param state If provided, only returns the `ViewConfig`s for a single state in the path
     *
     * @returns a list of ViewConfig objects for the given path.
     */
    Transition.prototype.views = function (pathname, state) {
        if (pathname === void 0) { pathname = 'entering'; }
        var path = this._treeChanges[pathname];
        path = !state ? path : path.filter(hof_1.propEq('state', state));
        return path
            .map(hof_1.prop('views'))
            .filter(common_1.identity)
            .reduce(common_1.unnestR, []);
    };
    Transition.prototype.treeChanges = function (pathname) {
        return pathname ? this._treeChanges[pathname] : this._treeChanges;
    };
    /**
     * Creates a new transition that is a redirection of the current one.
     *
     * This transition can be returned from a [[TransitionService]] hook to
     * redirect a transition to a new state and/or set of parameters.
     *
     * @internalapi
     *
     * @returns Returns a new [[Transition]] instance.
     */
    Transition.prototype.redirect = function (targetState) {
        var redirects = 1, trans = this;
        // tslint:disable-next-line:no-conditional-assignment
        while ((trans = trans.redirectedFrom()) != null) {
            if (++redirects > 20)
                throw new Error("Too many consecutive Transition redirects (20+)");
        }
        var redirectOpts = { redirectedFrom: this, source: 'redirect' };
        // If the original transition was caused by URL sync, then use { location: 'replace' }
        // on the new transition (unless the target state explicitly specifies location: false).
        // This causes the original url to be replaced with the url for the redirect target
        // so the original url disappears from the browser history.
        if (this.options().source === 'url' && targetState.options().location !== false) {
            redirectOpts.location = 'replace';
        }
        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);
        targetState = targetState.withOptions(newOptions, true);
        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);
        var originalEnteringNodes = this._treeChanges.entering;
        var redirectEnteringNodes = newTransition._treeChanges.entering;
        // --- Re-use resolve data from original transition ---
        // When redirecting from a parent state to a child state where the parent parameter values haven't changed
        // (because of the redirect), the resolves fetched by the original transition are still valid in the
        // redirected transition.
        //
        // This allows you to define a redirect on a parent state which depends on an async resolve value.
        // You can wait for the resolve, then redirect to a child state based on the result.
        // The redirected transition does not have to re-fetch the resolve.
        // ---------------------------------------------------------
        var nodeIsReloading = function (reloadState) { return function (node) {
            return reloadState && node.state.includes[reloadState.name];
        }; };
        // Find any "entering" nodes in the redirect path that match the original path and aren't being reloaded
        var matchingEnteringNodes = pathUtils_1.PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, pathUtils_1.PathUtils.nonDynamicParams).filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));
        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.
        matchingEnteringNodes.forEach(function (node, idx) {
            node.resolvables = originalEnteringNodes[idx].resolvables;
        });
        return newTransition;
    };
    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */
    Transition.prototype._changedParams = function () {
        var tc = this._treeChanges;
        /** Return undefined if it's not a "dynamic" transition, for the following reasons */
        // If user explicitly wants a reload
        if (this._options.reload)
            return undefined;
        // If any states are exiting or entering
        if (tc.exiting.length || tc.entering.length)
            return undefined;
        // If to/from path lengths differ
        if (tc.to.length !== tc.from.length)
            return undefined;
        // If the to/from paths are different
        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)
            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })
            .reduce(common_1.anyTrueR, false);
        if (pathsDiffer)
            return undefined;
        // Find any parameter values that differ
        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });
        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];
        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);
        return tuples.map(function (_a) {
            var schema = _a[0], toVals = _a[1], fromVals = _a[2];
            return param_1.Param.changed(schema, toVals, fromVals);
        }).reduce(common_1.unnestR, []);
    };
    /**
     * Returns true if the transition is dynamic.
     *
     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.
     *
     * @returns true if the Transition is dynamic
     */
    Transition.prototype.dynamic = function () {
        var changes = this._changedParams();
        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);
    };
    /**
     * Returns true if the transition is ignored.
     *
     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.
     *
     * @returns true if the Transition is ignored.
     */
    Transition.prototype.ignored = function () {
        return !!this._ignoredReason();
    };
    /** @hidden */
    Transition.prototype._ignoredReason = function () {
        var pending = this.router.globals.transition;
        var reloadState = this._options.reloadState;
        var same = function (pathA, pathB) {
            if (pathA.length !== pathB.length)
                return false;
            var matching = pathUtils_1.PathUtils.matching(pathA, pathB);
            return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;
        };
        var newTC = this.treeChanges();
        var pendTC = pending && pending.treeChanges();
        if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))
            return 'SameAsPending';
        if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))
            return 'SameAsCurrent';
    };
    /**
     * Runs the transition
     *
     * This method is generally called from the [[StateService.transitionTo]]
     *
     * @internalapi
     *
     * @returns a promise for a successful transition.
     */
    Transition.prototype.run = function () {
        var _this = this;
        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;
        // Gets transition hooks array for the given phase
        var getHooksFor = function (phase) { return _this._hookBuilder.buildHooksForPhase(phase); };
        // When the chain is complete, then resolve or reject the deferred
        var transitionSuccess = function () {
            trace_1.trace.traceSuccess(_this.$to(), _this);
            _this.success = true;
            _this._deferred.resolve(_this.to());
            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.SUCCESS));
        };
        var transitionError = function (reason) {
            trace_1.trace.traceError(reason, _this);
            _this.success = false;
            _this._deferred.reject(reason);
            _this._error = reason;
            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.ERROR));
        };
        var runTransition = function () {
            // Wait to build the RUN hook chain until the BEFORE hooks are done
            // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.
            var allRunHooks = getHooksFor(interface_1.TransitionHookPhase.RUN);
            var done = function () { return coreservices_1.services.$q.when(undefined); };
            return transitionHook_1.TransitionHook.invokeHooks(allRunHooks, done);
        };
        var startTransition = function () {
            var globals = _this.router.globals;
            globals.lastStartedTransitionId = _this.$id;
            globals.transition = _this;
            globals.transitionHistory.enqueue(_this);
            trace_1.trace.traceTransitionStart(_this);
            return coreservices_1.services.$q.when(undefined);
        };
        var allBeforeHooks = getHooksFor(interface_1.TransitionHookPhase.BEFORE);
        transitionHook_1.TransitionHook.invokeHooks(allBeforeHooks, startTransition)
            .then(runTransition)
            .then(transitionSuccess, transitionError);
        return this.promise;
    };
    /**
     * Checks if the Transition is valid
     *
     * @returns true if the Transition is valid
     */
    Transition.prototype.valid = function () {
        return !this.error() || this.success !== undefined;
    };
    /**
     * Aborts this transition
     *
     * Imperative API to abort a Transition.
     * This only applies to Transitions that are not yet complete.
     */
    Transition.prototype.abort = function () {
        // Do not set flag if the transition is already complete
        if (predicates_1.isUndefined(this.success)) {
            this._aborted = true;
        }
    };
    /**
     * The Transition error reason.
     *
     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.
     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.
     *
     * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.
     */
    Transition.prototype.error = function () {
        var state = this.$to();
        if (state.self.abstract) {
            return rejectFactory_1.Rejection.invalid("Cannot transition to abstract state '" + state.name + "'");
        }
        var paramDefs = state.parameters();
        var values = this.params();
        var invalidParams = paramDefs.filter(function (param) { return !param.validates(values[param.id]); });
        if (invalidParams.length) {
            var invalidValues = invalidParams.map(function (param) { return "[" + param.id + ":" + strings_1.stringify(values[param.id]) + "]"; }).join(', ');
            var detail = "The following parameter values are not valid for state '" + state.name + "': " + invalidValues;
            return rejectFactory_1.Rejection.invalid(detail);
        }
        if (this.success === false)
            return this._error;
    };
    /**
     * A string representation of the Transition
     *
     * @returns A string representation of the Transition
     */
    Transition.prototype.toString = function () {
        var fromStateOrName = this.from();
        var toStateOrName = this.to();
        var avoidEmptyHash = function (params) {
            return params['#'] !== null && params['#'] !== undefined ? params : common_1.omit(params, ['#']);
        };
        // (X) means the to state is invalid.
        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = strings_1.stringify(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? '' : '(X) ', to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = strings_1.stringify(avoidEmptyHash(this.params()));
        return "Transition#" + id + "( '" + from + "'" + fromParams + " -> " + toValid + "'" + to + "'" + toParams + " )";
    };
    /** @hidden */
    Transition.diToken = Transition;
    return Transition;
}());
exports.Transition = Transition;
//# sourceMappingURL=transition.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/transitionEventType.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/transitionEventType.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var transitionHook_1 = __webpack_require__(/*! ./transitionHook */ "./node_modules/@uirouter/core/lib/transition/transitionHook.js");
/**
 * This class defines a type of hook, such as `onBefore` or `onEnter`.
 * Plugins can define custom hook types, such as sticky states does for `onInactive`.
 *
 * @interalapi
 */
var TransitionEventType = /** @class */ (function () {
    /* tslint:disable:no-inferrable-types */
    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
        if (reverseSort === void 0) { reverseSort = false; }
        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }
        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }
        if (synchronous === void 0) { synchronous = false; }
        this.name = name;
        this.hookPhase = hookPhase;
        this.hookOrder = hookOrder;
        this.criteriaMatchPath = criteriaMatchPath;
        this.reverseSort = reverseSort;
        this.getResultHandler = getResultHandler;
        this.getErrorHandler = getErrorHandler;
        this.synchronous = synchronous;
    }
    return TransitionEventType;
}());
exports.TransitionEventType = TransitionEventType;
//# sourceMappingURL=transitionEventType.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/transitionHook.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/transitionHook.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */
/** for typedoc */
var interface_1 = __webpack_require__(/*! ./interface */ "./node_modules/@uirouter/core/lib/transition/interface.js");
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var strings_1 = __webpack_require__(/*! ../common/strings */ "./node_modules/@uirouter/core/lib/common/strings.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var trace_1 = __webpack_require__(/*! ../common/trace */ "./node_modules/@uirouter/core/lib/common/trace.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
var rejectFactory_1 = __webpack_require__(/*! ./rejectFactory */ "./node_modules/@uirouter/core/lib/transition/rejectFactory.js");
var targetState_1 = __webpack_require__(/*! ../state/targetState */ "./node_modules/@uirouter/core/lib/state/targetState.js");
var defaultOptions = {
    current: common_1.noop,
    transition: null,
    traceData: {},
    bind: null,
};
/** @hidden */
var TransitionHook = /** @class */ (function () {
    function TransitionHook(transition, stateContext, registeredHook, options) {
        var _this = this;
        this.transition = transition;
        this.stateContext = stateContext;
        this.registeredHook = registeredHook;
        this.options = options;
        this.isSuperseded = function () { return _this.type.hookPhase === interface_1.TransitionHookPhase.RUN && !_this.options.transition.isActive(); };
        this.options = common_1.defaults(options, defaultOptions);
        this.type = registeredHook.eventType;
    }
    /**
     * Chains together an array of TransitionHooks.
     *
     * Given a list of [[TransitionHook]] objects, chains them together.
     * Each hook is invoked after the previous one completes.
     *
     * #### Example:
     * ```js
     * var hooks: TransitionHook[] = getHooks();
     * let promise: Promise<any> = TransitionHook.chain(hooks);
     *
     * promise.then(handleSuccess, handleError);
     * ```
     *
     * @param hooks the list of hooks to chain together
     * @param waitFor if provided, the chain is `.then()`'ed off this promise
     * @returns a `Promise` for sequentially invoking the hooks (in order)
     */
    TransitionHook.chain = function (hooks, waitFor) {
        // Chain the next hook off the previous
        var createHookChainR = function (prev, nextHook) { return prev.then(function () { return nextHook.invokeHook(); }); };
        return hooks.reduce(createHookChainR, waitFor || coreservices_1.services.$q.when());
    };
    /**
     * Invokes all the provided TransitionHooks, in order.
     * Each hook's return value is checked.
     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.
     * If no hook returns a promise, then all hooks are processed synchronously.
     *
     * @param hooks the list of TransitionHooks to invoke
     * @param doneCallback a callback that is invoked after all the hooks have successfully completed
     *
     * @returns a promise for the async result, or the result of the callback
     */
    TransitionHook.invokeHooks = function (hooks, doneCallback) {
        for (var idx = 0; idx < hooks.length; idx++) {
            var hookResult = hooks[idx].invokeHook();
            if (predicates_1.isPromise(hookResult)) {
                var remainingHooks = hooks.slice(idx + 1);
                return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);
            }
        }
        return doneCallback();
    };
    /**
     * Run all TransitionHooks, ignoring their return value.
     */
    TransitionHook.runAllHooks = function (hooks) {
        hooks.forEach(function (hook) { return hook.invokeHook(); });
    };
    TransitionHook.prototype.logError = function (err) {
        this.transition.router.stateService.defaultErrorHandler()(err);
    };
    TransitionHook.prototype.invokeHook = function () {
        var _this = this;
        var hook = this.registeredHook;
        if (hook._deregistered)
            return;
        var notCurrent = this.getNotCurrentRejection();
        if (notCurrent)
            return notCurrent;
        var options = this.options;
        trace_1.trace.traceHookInvocation(this, this.transition, options);
        var invokeCallback = function () { return hook.callback.call(options.bind, _this.transition, _this.stateContext); };
        var normalizeErr = function (err) { return rejectFactory_1.Rejection.normalize(err).toPromise(); };
        var handleError = function (err) { return hook.eventType.getErrorHandler(_this)(err); };
        var handleResult = function (result) { return hook.eventType.getResultHandler(_this)(result); };
        try {
            var result = invokeCallback();
            if (!this.type.synchronous && predicates_1.isPromise(result)) {
                return result.catch(normalizeErr).then(handleResult, handleError);
            }
            else {
                return handleResult(result);
            }
        }
        catch (err) {
            // If callback throws (synchronously)
            return handleError(rejectFactory_1.Rejection.normalize(err));
        }
        finally {
            if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {
                hook.deregister();
            }
        }
    };
    /**
     * This method handles the return value of a Transition Hook.
     *
     * A hook can return false (cancel), a TargetState (redirect),
     * or a promise (which may later resolve to false or a redirect)
     *
     * This also handles "transition superseded" -- when a new transition
     * was started while the hook was still running
     */
    TransitionHook.prototype.handleHookResult = function (result) {
        var _this = this;
        var notCurrent = this.getNotCurrentRejection();
        if (notCurrent)
            return notCurrent;
        // Hook returned a promise
        if (predicates_1.isPromise(result)) {
            // Wait for the promise, then reprocess with the resulting value
            return result.then(function (val) { return _this.handleHookResult(val); });
        }
        trace_1.trace.traceHookResult(result, this.transition, this.options);
        // Hook returned false
        if (result === false) {
            // Abort this Transition
            return rejectFactory_1.Rejection.aborted('Hook aborted transition').toPromise();
        }
        var isTargetState = hof_1.is(targetState_1.TargetState);
        // hook returned a TargetState
        if (isTargetState(result)) {
            // Halt the current Transition and redirect (a new Transition) to the TargetState.
            return rejectFactory_1.Rejection.redirected(result).toPromise();
        }
    };
    /**
     * Return a Rejection promise if the transition is no longer current due
     * to a stopped router (disposed), or a new transition has started and superseded this one.
     */
    TransitionHook.prototype.getNotCurrentRejection = function () {
        var router = this.transition.router;
        // The router is stopped
        if (router._disposed) {
            return rejectFactory_1.Rejection.aborted("UIRouter instance #" + router.$id + " has been stopped (disposed)").toPromise();
        }
        if (this.transition._aborted) {
            return rejectFactory_1.Rejection.aborted().toPromise();
        }
        // This transition is no longer current.
        // Another transition started while this hook was still running.
        if (this.isSuperseded()) {
            // Abort this transition
            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();
        }
    };
    TransitionHook.prototype.toString = function () {
        var _a = this, options = _a.options, registeredHook = _a.registeredHook;
        var event = hof_1.parse('traceData.hookType')(options) || 'internal', context = hof_1.parse('traceData.context.state.name')(options) || hof_1.parse('traceData.context')(options) || 'unknown', name = strings_1.fnToString(registeredHook.callback);
        return event + " context: " + context + ", " + strings_1.maxLength(200, name);
    };
    /**
     * These GetResultHandler(s) are used by [[invokeHook]] below
     * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])
     */
    TransitionHook.HANDLE_RESULT = function (hook) { return function (result) {
        return hook.handleHookResult(result);
    }; };
    /**
     * If the result is a promise rejection, log it.
     * Otherwise, ignore the result.
     */
    TransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {
        predicates_1.isPromise(result) && result.catch(function (err) { return hook.logError(rejectFactory_1.Rejection.normalize(err)); });
        return undefined;
    }; };
    /**
     * These GetErrorHandler(s) are used by [[invokeHook]] below
     * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])
     */
    TransitionHook.LOG_ERROR = function (hook) { return function (error) { return hook.logError(error); }; };
    TransitionHook.REJECT_ERROR = function (hook) { return function (error) { return common_1.silentRejection(error); }; };
    TransitionHook.THROW_ERROR = function (hook) { return function (error) {
        throw error;
    }; };
    return TransitionHook;
}());
exports.TransitionHook = TransitionHook;
//# sourceMappingURL=transitionHook.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/transition/transitionService.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/transition/transitionService.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */
/** for typedoc */
var interface_1 = __webpack_require__(/*! ./interface */ "./node_modules/@uirouter/core/lib/transition/interface.js");
var transition_1 = __webpack_require__(/*! ./transition */ "./node_modules/@uirouter/core/lib/transition/transition.js");
var hookRegistry_1 = __webpack_require__(/*! ./hookRegistry */ "./node_modules/@uirouter/core/lib/transition/hookRegistry.js");
var coreResolvables_1 = __webpack_require__(/*! ../hooks/coreResolvables */ "./node_modules/@uirouter/core/lib/hooks/coreResolvables.js");
var redirectTo_1 = __webpack_require__(/*! ../hooks/redirectTo */ "./node_modules/@uirouter/core/lib/hooks/redirectTo.js");
var onEnterExitRetain_1 = __webpack_require__(/*! ../hooks/onEnterExitRetain */ "./node_modules/@uirouter/core/lib/hooks/onEnterExitRetain.js");
var resolve_1 = __webpack_require__(/*! ../hooks/resolve */ "./node_modules/@uirouter/core/lib/hooks/resolve.js");
var views_1 = __webpack_require__(/*! ../hooks/views */ "./node_modules/@uirouter/core/lib/hooks/views.js");
var updateGlobals_1 = __webpack_require__(/*! ../hooks/updateGlobals */ "./node_modules/@uirouter/core/lib/hooks/updateGlobals.js");
var url_1 = __webpack_require__(/*! ../hooks/url */ "./node_modules/@uirouter/core/lib/hooks/url.js");
var lazyLoad_1 = __webpack_require__(/*! ../hooks/lazyLoad */ "./node_modules/@uirouter/core/lib/hooks/lazyLoad.js");
var transitionEventType_1 = __webpack_require__(/*! ./transitionEventType */ "./node_modules/@uirouter/core/lib/transition/transitionEventType.js");
var transitionHook_1 = __webpack_require__(/*! ./transitionHook */ "./node_modules/@uirouter/core/lib/transition/transitionHook.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var ignoredTransition_1 = __webpack_require__(/*! ../hooks/ignoredTransition */ "./node_modules/@uirouter/core/lib/hooks/ignoredTransition.js");
var invalidTransition_1 = __webpack_require__(/*! ../hooks/invalidTransition */ "./node_modules/@uirouter/core/lib/hooks/invalidTransition.js");
/**
 * The default [[Transition]] options.
 *
 * Include this object when applying custom defaults:
 * let reloadOpts = { reload: true, notify: true }
 * let options = defaults(theirOpts, customDefaults, defaultOptions);
 */
exports.defaultTransOpts = {
    location: true,
    relative: null,
    inherit: false,
    notify: true,
    reload: false,
    custom: {},
    current: function () { return null; },
    source: 'unknown',
};
/**
 * This class provides services related to Transitions.
 *
 * - Most importantly, it allows global Transition Hooks to be registered.
 * - It allows the default transition error handler to be set.
 * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).
 *
 * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.
 */
var TransitionService = /** @class */ (function () {
    /** @hidden */
    function TransitionService(_router) {
        /** @hidden */
        this._transitionCount = 0;
        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */
        this._eventTypes = [];
        /** @hidden The registered transition hooks */
        this._registeredHooks = {};
        /** @hidden The  paths on a criteria object */
        this._criteriaPaths = {};
        this._router = _router;
        this.$view = _router.viewService;
        this._deregisterHookFns = {};
        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [
            '_definePathType',
            '_defineEvent',
            '_getPathTypes',
            '_getEvents',
            'getHooks',
        ]);
        this._defineCorePaths();
        this._defineCoreEvents();
        this._registerCoreTransitionHooks();
        _router.globals.successfulTransitions.onEvict(coreResolvables_1.treeChangesCleanup);
    }
    /**
     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.
     *
     * Registers a transition lifecycle hook, which is invoked during transition construction.
     *
     * This low level hook should only be used by plugins.
     * This can be a useful time for plugins to add resolves or mutate the transition as needed.
     * The Sticky States plugin uses this hook to modify the treechanges.
     *
     * ### Lifecycle
     *
     * `onCreate` hooks are invoked *while a transition is being constructed*.
     *
     * ### Return value
     *
     * The hook's return value is ignored
     *
     * @internalapi
     * @param criteria defines which Transitions the Hook should be invoked for.
     * @param callback the hook function which will be invoked.
     * @param options the registration options
     * @returns a function which deregisters the hook.
     */
    TransitionService.prototype.onCreate = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    TransitionService.prototype.onBefore = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    TransitionService.prototype.onStart = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    TransitionService.prototype.onExit = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    TransitionService.prototype.onRetain = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    TransitionService.prototype.onEnter = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    TransitionService.prototype.onFinish = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    TransitionService.prototype.onSuccess = function (criteria, callback, options) {
        return;
    };
    /** @inheritdoc */
    TransitionService.prototype.onError = function (criteria, callback, options) {
        return;
    };
    /**
     * dispose
     * @internalapi
     */
    TransitionService.prototype.dispose = function (router) {
        common_1.values(this._registeredHooks).forEach(function (hooksArray) {
            return hooksArray.forEach(function (hook) {
                hook._deregistered = true;
                common_1.removeFrom(hooksArray, hook);
            });
        });
    };
    /**
     * Creates a new [[Transition]] object
     *
     * This is a factory function for creating new Transition objects.
     * It is used internally by the [[StateService]] and should generally not be called by application code.
     *
     * @param fromPath the path to the current state (the from state)
     * @param targetState the target state (destination)
     * @returns a Transition
     */
    TransitionService.prototype.create = function (fromPath, targetState) {
        return new transition_1.Transition(fromPath, targetState, this._router);
    };
    /** @hidden */
    TransitionService.prototype._defineCoreEvents = function () {
        var Phase = interface_1.TransitionHookPhase;
        var TH = transitionHook_1.TransitionHook;
        var paths = this._criteriaPaths;
        var NORMAL_SORT = false, REVERSE_SORT = true;
        var SYNCHRONOUS = true;
        this._defineEvent('onCreate', Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);
        this._defineEvent('onBefore', Phase.BEFORE, 0, paths.to);
        this._defineEvent('onStart', Phase.RUN, 0, paths.to);
        this._defineEvent('onExit', Phase.RUN, 100, paths.exiting, REVERSE_SORT);
        this._defineEvent('onRetain', Phase.RUN, 200, paths.retained);
        this._defineEvent('onEnter', Phase.RUN, 300, paths.entering);
        this._defineEvent('onFinish', Phase.RUN, 400, paths.to);
        this._defineEvent('onSuccess', Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
        this._defineEvent('onError', Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
    };
    /** @hidden */
    TransitionService.prototype._defineCorePaths = function () {
        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;
        this._definePathType('to', TRANSITION);
        this._definePathType('from', TRANSITION);
        this._definePathType('exiting', STATE);
        this._definePathType('retained', STATE);
        this._definePathType('entering', STATE);
    };
    /** @hidden */
    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
        if (reverseSort === void 0) { reverseSort = false; }
        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }
        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }
        if (synchronous === void 0) { synchronous = false; }
        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);
        this._eventTypes.push(eventType);
        hookRegistry_1.makeEvent(this, this, eventType);
    };
    /** @hidden */
    // tslint:disable-next-line
    TransitionService.prototype._getEvents = function (phase) {
        var transitionHookTypes = predicates_1.isDefined(phase)
            ? this._eventTypes.filter(function (type) { return type.hookPhase === phase; })
            : this._eventTypes.slice();
        return transitionHookTypes.sort(function (l, r) {
            var cmpByPhase = l.hookPhase - r.hookPhase;
            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;
        });
    };
    /**
     * Adds a Path to be used as a criterion against a TreeChanges path
     *
     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.
     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`
     * Each state in the exiting path is checked against the criteria and returned as part of the match.
     *
     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.
     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`
     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.
     *
     * @hidden
     */
    TransitionService.prototype._definePathType = function (name, hookScope) {
        this._criteriaPaths[name] = { name: name, scope: hookScope };
    };
    /** * @hidden */
    // tslint:disable-next-line
    TransitionService.prototype._getPathTypes = function () {
        return this._criteriaPaths;
    };
    /** @hidden */
    TransitionService.prototype.getHooks = function (hookName) {
        return this._registeredHooks[hookName];
    };
    /** @hidden */
    TransitionService.prototype._registerCoreTransitionHooks = function () {
        var fns = this._deregisterHookFns;
        fns.addCoreResolves = coreResolvables_1.registerAddCoreResolvables(this);
        fns.ignored = ignoredTransition_1.registerIgnoredTransitionHook(this);
        fns.invalid = invalidTransition_1.registerInvalidTransitionHook(this);
        // Wire up redirectTo hook
        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);
        // Wire up onExit/Retain/Enter state hooks
        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);
        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);
        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);
        // Wire up Resolve hooks
        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);
        fns.lazyResolve = resolve_1.registerLazyResolveState(this);
        fns.resolveAll = resolve_1.registerResolveRemaining(this);
        // Wire up the View management hooks
        fns.loadViews = views_1.registerLoadEnteringViews(this);
        fns.activateViews = views_1.registerActivateViews(this);
        // Updates global state after a transition
        fns.updateGlobals = updateGlobals_1.registerUpdateGlobalState(this);
        // After globals.current is updated at priority: 10000
        fns.updateUrl = url_1.registerUpdateUrl(this);
        // Lazy load state trees
        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);
    };
    return TransitionService;
}());
exports.TransitionService = TransitionService;
//# sourceMappingURL=transitionService.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./urlMatcher */ "./node_modules/@uirouter/core/lib/url/urlMatcher.js"));
__export(__webpack_require__(/*! ./urlMatcherFactory */ "./node_modules/@uirouter/core/lib/url/urlMatcherFactory.js"));
__export(__webpack_require__(/*! ./urlRouter */ "./node_modules/@uirouter/core/lib/url/urlRouter.js"));
__export(__webpack_require__(/*! ./urlRule */ "./node_modules/@uirouter/core/lib/url/urlRule.js"));
__export(__webpack_require__(/*! ./urlService */ "./node_modules/@uirouter/core/lib/url/urlService.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/urlMatcher.js":
/*!***********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/urlMatcher.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module url
 */
/** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var param_1 = __webpack_require__(/*! ../params/param */ "./node_modules/@uirouter/core/lib/params/param.js");
var strings_1 = __webpack_require__(/*! ../common/strings */ "./node_modules/@uirouter/core/lib/common/strings.js");
/** @hidden */
function quoteRegExp(str, param) {
    var surroundPattern = ['', ''], result = str.replace(/[\\\[\]\^$*+?.()|{}]/g, '\\$&');
    if (!param)
        return result;
    switch (param.squash) {
        case false:
            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];
            break;
        case true:
            result = result.replace(/\/$/, '');
            surroundPattern = ['(?:/(', ')|/)?'];
            break;
        default:
            surroundPattern = ["(" + param.squash + "|", ')?'];
            break;
    }
    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];
}
/** @hidden */
var memoizeTo = function (obj, _prop, fn) { return (obj[_prop] = obj[_prop] || fn()); };
/** @hidden */
var splitOnSlash = strings_1.splitOnDelim('/');
/**
 * Matches URLs against patterns.
 *
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL.
 *
 * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)
 * parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by [[UrlMatcher.exec]].
 *
 * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)
 * or colon placeholders (`/somePath/:param`).
 *
 * - *A parameter RegExp* may be defined for a param after a colon
 * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.
 * The regexp must match for the url to be matched.
 * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].
 *
 * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.
 *   See [[UrlMatcherFactory.type]] for more information.
 *
 * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).
 *   A catch-all * parameter value will contain the remainder of the URL.
 *
 * ---
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters).
 * A path parameter matches any number of characters other than '/'. For catch-all
 * placeholders the path parameter matches any number of characters.
 *
 * Examples:
 *
 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
 * * `'/user/{id:[^/]*}'` - Same as the previous example.
 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * `'/files/*path'` - ditto.
 * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
 *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start
 *
 */
var UrlMatcher = /** @class */ (function () {
    /**
     * @param pattern The pattern to compile into a matcher.
     * @param paramTypes The [[ParamTypes]] registry
     * @param config  A configuration object
     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
     */
    function UrlMatcher(pattern, paramTypes, paramFactory, config) {
        var _this = this;
        this.config = config;
        /** @hidden */
        this._cache = { path: [this] };
        /** @hidden */
        this._children = [];
        /** @hidden */
        this._params = [];
        /** @hidden */
        this._segments = [];
        /** @hidden */
        this._compiled = [];
        this.pattern = pattern;
        this.config = common_1.defaults(this.config, {
            params: {},
            strict: true,
            caseInsensitive: false,
            paramMap: common_1.identity,
        });
        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
        //   '*' name
        //   ':' name
        //   '{' name '}'
        //   '{' name ':' regexp '}'
        // The regular expression is somewhat complicated due to the need to allow curly braces
        // inside the regular expression. The placeholder regexp breaks down as follows:
        //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
        //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
        //    [^{}\\]+                       - anything other than curly braces or backslash
        //    \\.                            - a backslash escape
        //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g;
        var searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g;
        var patterns = [];
        var last = 0, matchArray;
        var checkParamErrors = function (id) {
            if (!UrlMatcher.nameValidator.test(id))
                throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (common_1.find(_this._params, hof_1.propEq('id', id)))
                throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
        };
        // Split into static segments separated by path parameter placeholders.
        // The number of segments is always 1 more than the number of parameters.
        var matchDetails = function (m, isSearch) {
            // IE[78] returns '' for unmatched groups instead of null
            var id = m[2] || m[3];
            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\s\\S]*' : null);
            var makeRegexpType = function (str) {
                return common_1.inherit(paramTypes.type(isSearch ? 'query' : 'path'), {
                    pattern: new RegExp(str, _this.config.caseInsensitive ? 'i' : undefined),
                });
            };
            return {
                id: id,
                regexp: regexp,
                cfg: _this.config.params[id],
                segment: pattern.substring(last, m.index),
                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp),
            };
        };
        var p, segment;
        // tslint:disable-next-line:no-conditional-assignment
        while ((matchArray = placeholder.exec(pattern))) {
            p = matchDetails(matchArray, false);
            if (p.segment.indexOf('?') >= 0)
                break; // we're into the search part
            checkParamErrors(p.id);
            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));
            this._segments.push(p.segment);
            patterns.push([p.segment, common_1.tail(this._params)]);
            last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        // Find any search parameter names and remove them from the last segment
        var i = segment.indexOf('?');
        if (i >= 0) {
            var search = segment.substring(i);
            segment = segment.substring(0, i);
            if (search.length > 0) {
                last = 0;
                // tslint:disable-next-line:no-conditional-assignment
                while ((matchArray = searchPlaceholder.exec(search))) {
                    p = matchDetails(matchArray, true);
                    checkParamErrors(p.id);
                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));
                    last = placeholder.lastIndex;
                    // check if ?&
                }
            }
        }
        this._segments.push(segment);
        this._compiled = patterns.map(function (_pattern) { return quoteRegExp.apply(null, _pattern); }).concat(quoteRegExp(segment));
    }
    /** @hidden */
    UrlMatcher.encodeDashes = function (str) {
        // Replace dashes with encoded "\-"
        return encodeURIComponent(str).replace(/-/g, function (c) {
            return "%5C%" + c
                .charCodeAt(0)
                .toString(16)
                .toUpperCase();
        });
    };
    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */
    UrlMatcher.pathSegmentsAndParams = function (matcher) {
        var staticSegments = matcher._segments;
        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });
        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))
            .reduce(common_1.unnestR, [])
            .filter(function (x) { return x !== '' && predicates_1.isDefined(x); });
    };
    /** @hidden Given a matcher, return an array with the matcher's query params */
    UrlMatcher.queryParams = function (matcher) {
        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });
    };
    /**
     * Compare two UrlMatchers
     *
     * This comparison function converts a UrlMatcher into static and dynamic path segments.
     * Each static path segment is a static string between a path separator (slash character).
     * Each dynamic segment is a path parameter.
     *
     * The comparison function sorts static segments before dynamic ones.
     */
    UrlMatcher.compare = function (a, b) {
        /**
         * Turn a UrlMatcher and all its parent matchers into an array
         * of slash literals '/', string literals, and Param objects
         *
         * This example matcher matches strings like "/foo/:param/tail":
         * var matcher = $umf.compile("/foo").append($umf.compile("/:param")).append($umf.compile("/")).append($umf.compile("tail"));
         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]
         *
         * Caches the result as `matcher._cache.segments`
         */
        var segments = function (matcher) {
            return (matcher._cache.segments =
                matcher._cache.segments ||
                    matcher._cache.path
                        .map(UrlMatcher.pathSegmentsAndParams)
                        .reduce(common_1.unnestR, [])
                        .reduce(strings_1.joinNeighborsR, [])
                        .map(function (x) { return (predicates_1.isString(x) ? splitOnSlash(x) : x); })
                        .reduce(common_1.unnestR, []));
        };
        /**
         * Gets the sort weight for each segment of a UrlMatcher
         *
         * Caches the result as `matcher._cache.weights`
         */
        var weights = function (matcher) {
            return (matcher._cache.weights =
                matcher._cache.weights ||
                    segments(matcher).map(function (segment) {
                        // Sort slashes first, then static strings, the Params
                        if (segment === '/')
                            return 1;
                        if (predicates_1.isString(segment))
                            return 2;
                        if (segment instanceof param_1.Param)
                            return 3;
                    }));
        };
        /**
         * Pads shorter array in-place (mutates)
         */
        var padArrays = function (l, r, padVal) {
            var len = Math.max(l.length, r.length);
            while (l.length < len)
                l.push(padVal);
            while (r.length < len)
                r.push(padVal);
        };
        var weightsA = weights(a), weightsB = weights(b);
        padArrays(weightsA, weightsB, 0);
        var _pairs = common_1.arrayTuples(weightsA, weightsB);
        var cmp, i;
        for (i = 0; i < _pairs.length; i++) {
            cmp = _pairs[i][0] - _pairs[i][1];
            if (cmp !== 0)
                return cmp;
        }
        return 0;
    };
    /**
     * Creates a new concatenated UrlMatcher
     *
     * Builds a new UrlMatcher by appending another UrlMatcher to this one.
     *
     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.
     */
    UrlMatcher.prototype.append = function (url) {
        this._children.push(url);
        url._cache = {
            path: this._cache.path.concat(url),
            parent: this,
            pattern: null,
        };
        return url;
    };
    /** @hidden */
    UrlMatcher.prototype.isRoot = function () {
        return this._cache.path[0] === this;
    };
    /** Returns the input pattern string */
    UrlMatcher.prototype.toString = function () {
        return this.pattern;
    };
    /**
     * Tests the specified url/path against this matcher.
     *
     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured
     * parameter values.  Returns null if the path does not match.
     *
     * The returned object contains the values
     * of any search parameters that are mentioned in the pattern, but their value may be null if
     * they are not present in `search`. This means that search parameters are always treated
     * as optional.
     *
     * #### Example:
     * ```js
     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
     *   x: '1', q: 'hello'
     * });
     * // returns { id: 'bob', q: 'hello', r: null }
     * ```
     *
     * @param path    The URL path to match, e.g. `$location.path()`.
     * @param search  URL search parameters, e.g. `$location.search()`.
     * @param hash    URL hash e.g. `$location.hash()`.
     * @param options
     *
     * @returns The captured parameter values.
     */
    UrlMatcher.prototype.exec = function (path, search, hash, options) {
        var _this = this;
        if (search === void 0) { search = {}; }
        if (options === void 0) { options = {}; }
        var match = memoizeTo(this._cache, 'pattern', function () {
            return new RegExp([
                '^',
                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),
                _this.config.strict === false ? '/?' : '',
                '$',
            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);
        }).exec(path);
        if (!match)
            return null;
        // options = defaults(options, { isolate: false });
        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};
        if (nPathSegments !== match.length - 1)
            throw new Error("Unbalanced capture group in route '" + this.pattern + "'");
        function decodePathArray(paramVal) {
            var reverseString = function (str) {
                return str
                    .split('')
                    .reverse()
                    .join('');
            };
            var unquoteDashes = function (str) { return str.replace(/\\-/g, '-'); };
            var split = reverseString(paramVal).split(/-(?!\\)/);
            var allReversed = common_1.map(split, reverseString);
            return common_1.map(allReversed, unquoteDashes).reverse();
        }
        for (var i = 0; i < nPathSegments; i++) {
            var param = pathParams[i];
            var value = match[i + 1];
            // if the param value matches a pre-replace pair, replace the value before decoding.
            for (var j = 0; j < param.replace.length; j++) {
                if (param.replace[j].from === value)
                    value = param.replace[j].to;
            }
            if (value && param.array === true)
                value = decodePathArray(value);
            if (predicates_1.isDefined(value))
                value = param.type.decode(value);
            values[param.id] = param.value(value);
        }
        searchParams.forEach(function (param) {
            var value = search[param.id];
            for (var j = 0; j < param.replace.length; j++) {
                if (param.replace[j].from === value)
                    value = param.replace[j].to;
            }
            if (predicates_1.isDefined(value))
                value = param.type.decode(value);
            values[param.id] = param.value(value);
        });
        if (hash)
            values['#'] = hash;
        return values;
    };
    /**
     * @hidden
     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.
     *
     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the
     *    pattern has no parameters, an empty array is returned.
     */
    UrlMatcher.prototype.parameters = function (opts) {
        if (opts === void 0) { opts = {}; }
        if (opts.inherit === false)
            return this._params;
        return common_1.unnest(this._cache.path.map(function (matcher) { return matcher._params; }));
    };
    /**
     * @hidden
     * Returns a single parameter from this UrlMatcher by id
     *
     * @param id
     * @param opts
     * @returns {T|Param|any|boolean|UrlMatcher|null}
     */
    UrlMatcher.prototype.parameter = function (id, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var findParam = function () {
            for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {
                var param = _a[_i];
                if (param.id === id)
                    return param;
            }
        };
        var parent = this._cache.parent;
        return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;
    };
    /**
     * Validates the input parameter values against this UrlMatcher
     *
     * Checks an object hash of parameters to validate their correctness according to the parameter
     * types of this `UrlMatcher`.
     *
     * @param params The object hash of parameters to validate.
     * @returns Returns `true` if `params` validates, otherwise `false`.
     */
    UrlMatcher.prototype.validates = function (params) {
        var validParamVal = function (param, val) { return !param || param.validates(val); };
        params = params || {};
        // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher
        var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });
        return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(common_1.allTrueR, true);
    };
    /**
     * Given a set of parameter values, creates a URL from this UrlMatcher.
     *
     * Creates a URL that matches this pattern by substituting the specified values
     * for the path and search parameters.
     *
     * #### Example:
     * ```js
     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
     * // returns '/user/bob?q=yes'
     * ```
     *
     * @param values  the values to substitute for the parameters in this pattern.
     * @returns the formatted URL (path and optionally search part).
     */
    UrlMatcher.prototype.format = function (values) {
        if (values === void 0) { values = {}; }
        // Build the full path of UrlMatchers (including all parent UrlMatchers)
        var urlMatchers = this._cache.path;
        // Extract all the static segments and Params (processed as ParamDetails)
        // into an ordered array
        var pathSegmentsAndParams = urlMatchers
            .map(UrlMatcher.pathSegmentsAndParams)
            .reduce(common_1.unnestR, [])
            .map(function (x) { return (predicates_1.isString(x) ? x : getDetails(x)); });
        // Extract the query params into a separate array
        var queryParams = urlMatchers
            .map(UrlMatcher.queryParams)
            .reduce(common_1.unnestR, [])
            .map(getDetails);
        var isInvalid = function (param) { return param.isValid === false; };
        if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {
            return null;
        }
        /**
         * Given a Param, applies the parameter value, then returns detailed information about it
         */
        function getDetails(param) {
            // Normalize to typed value
            var value = param.value(values[param.id]);
            var isValid = param.validates(value);
            var isDefaultValue = param.isDefaultValue(value);
            // Check if we're in squash mode for the parameter
            var squash = isDefaultValue ? param.squash : false;
            // Allow the Parameter's Type to encode the value
            var encoded = param.type.encode(value);
            return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };
        }
        // Build up the path-portion from the list of static segments and parameters
        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {
            // The element is a static segment (a raw string); just append it
            if (predicates_1.isString(x))
                return acc + x;
            // Otherwise, it's a ParamDetails.
            var squash = x.squash, encoded = x.encoded, param = x.param;
            // If squash is === true, try to remove a slash from the path
            if (squash === true)
                return acc.match(/\/$/) ? acc.slice(0, -1) : acc;
            // If squash is a string, use the string for the param value
            if (predicates_1.isString(squash))
                return acc + squash;
            if (squash !== false)
                return acc; // ?
            if (encoded == null)
                return acc;
            // If this parameter value is an array, encode the value using encodeDashes
            if (predicates_1.isArray(encoded))
                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join('-');
            // If the parameter type is "raw", then do not encodeURIComponent
            if (param.raw)
                return acc + encoded;
            // Encode the value
            return acc + encodeURIComponent(encoded);
        }, '');
        // Build the query string by applying parameter values (array or regular)
        // then mapping to key=value, then flattening and joining using "&"
        var queryString = queryParams
            .map(function (paramDetails) {
            var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;
            if (encoded == null || (isDefaultValue && squash !== false))
                return;
            if (!predicates_1.isArray(encoded))
                encoded = [encoded];
            if (encoded.length === 0)
                return;
            if (!param.raw)
                encoded = common_1.map(encoded, encodeURIComponent);
            return encoded.map(function (val) { return param.id + "=" + val; });
        })
            .filter(common_1.identity)
            .reduce(common_1.unnestR, [])
            .join('&');
        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)
        return pathString + (queryString ? "?" + queryString : '') + (values['#'] ? '#' + values['#'] : '');
    };
    /** @hidden */
    UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;
    return UrlMatcher;
}());
exports.UrlMatcher = UrlMatcher;
//# sourceMappingURL=urlMatcher.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/urlMatcherFactory.js":
/*!******************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/urlMatcherFactory.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module url
 */ /** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var urlMatcher_1 = __webpack_require__(/*! ./urlMatcher */ "./node_modules/@uirouter/core/lib/url/urlMatcher.js");
var param_1 = __webpack_require__(/*! ../params/param */ "./node_modules/@uirouter/core/lib/params/param.js");
var paramTypes_1 = __webpack_require__(/*! ../params/paramTypes */ "./node_modules/@uirouter/core/lib/params/paramTypes.js");
/**
 * Factory for [[UrlMatcher]] instances.
 *
 * The factory is available to ng1 services as
 * `$urlMatcherFactory` or ng1 providers as `$urlMatcherFactoryProvider`.
 */
var UrlMatcherFactory = /** @class */ (function () {
    function UrlMatcherFactory() {
        var _this = this;
        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();
        /** @hidden */ this._isCaseInsensitive = false;
        /** @hidden */ this._isStrictMode = true;
        /** @hidden */ this._defaultSquashPolicy = false;
        /** @internalapi Creates a new [[Param]] for a given location (DefType) */
        this.paramFactory = {
            /** Creates a new [[Param]] from a CONFIG block */
            fromConfig: function (id, type, config) { return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this); },
            /** Creates a new [[Param]] from a url PATH */
            fromPath: function (id, type, config) { return new param_1.Param(id, type, config, param_1.DefType.PATH, _this); },
            /** Creates a new [[Param]] from a url SEARCH */
            fromSearch: function (id, type, config) { return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this); },
        };
        /** @hidden */
        this._getConfig = function (config) {
            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);
        };
        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });
    }
    /** @inheritdoc */
    UrlMatcherFactory.prototype.caseInsensitive = function (value) {
        return (this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive);
    };
    /** @inheritdoc */
    UrlMatcherFactory.prototype.strictMode = function (value) {
        return (this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode);
    };
    /** @inheritdoc */
    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {
        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
        return (this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy);
    };
    /**
     * Creates a [[UrlMatcher]] for the specified pattern.
     *
     * @param pattern  The URL pattern.
     * @param config  The config object hash.
     * @returns The UrlMatcher.
     */
    UrlMatcherFactory.prototype.compile = function (pattern, config) {
        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));
    };
    /**
     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.
     *
     * @param object  The object to perform the type check against.
     * @returns `true` if the object matches the `UrlMatcher` interface, by
     *          implementing all the same methods.
     */
    UrlMatcherFactory.prototype.isMatcher = function (object) {
        // TODO: typeof?
        if (!predicates_1.isObject(object))
            return false;
        var result = true;
        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {
            if (predicates_1.isFunction(val))
                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));
        });
        return result;
    };
    /**
     * Creates and registers a custom [[ParamType]] object
     *
     * A [[ParamType]] can be used to generate URLs with typed parameters.
     *
     * @param name  The type name.
     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.
     * @param definitionFn A function that is injected before the app runtime starts.
     *        The result of this function should be a [[ParamTypeDefinition]].
     *        The result is merged into the existing `definition`.
     *        See [[ParamType]] for information on the values accepted.
     *
     * @returns - if a type was registered: the [[UrlMatcherFactory]]
     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined
     *
     * Note: Register custom types *before using them* in a state definition.
     *
     * See [[ParamTypeDefinition]] for examples
     */
    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {
        var type = this.paramTypes.type(name, definition, definitionFn);
        return !predicates_1.isDefined(definition) ? type : this;
    };
    /** @hidden */
    UrlMatcherFactory.prototype.$get = function () {
        this.paramTypes.enqueue = false;
        this.paramTypes._flushTypeQueue();
        return this;
    };
    /** @internalapi */
    UrlMatcherFactory.prototype.dispose = function () {
        this.paramTypes.dispose();
    };
    return UrlMatcherFactory;
}());
exports.UrlMatcherFactory = UrlMatcherFactory;
//# sourceMappingURL=urlMatcherFactory.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/urlRouter.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/urlRouter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module url
 */
/** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var urlMatcher_1 = __webpack_require__(/*! ./urlMatcher */ "./node_modules/@uirouter/core/lib/url/urlMatcher.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var urlRule_1 = __webpack_require__(/*! ./urlRule */ "./node_modules/@uirouter/core/lib/url/urlRule.js");
var targetState_1 = __webpack_require__(/*! ../state/targetState */ "./node_modules/@uirouter/core/lib/state/targetState.js");
var common_2 = __webpack_require__(/*! ../common */ "./node_modules/@uirouter/core/lib/common/index.js");
/** @hidden */
function appendBasePath(url, isHtml5, absolute, baseHref) {
    if (baseHref === '/')
        return url;
    if (isHtml5)
        return common_2.stripLastPathElement(baseHref) + url;
    if (absolute)
        return baseHref.slice(1) + url;
    return url;
}
/** @hidden */
var prioritySort = function (a, b) { return (b.priority || 0) - (a.priority || 0); };
/** @hidden */
var typeSort = function (a, b) {
    var weights = { STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1 };
    return (weights[a.type] || 0) - (weights[b.type] || 0);
};
/** @hidden */
var urlMatcherSort = function (a, b) {
    return !a.urlMatcher || !b.urlMatcher ? 0 : urlMatcher_1.UrlMatcher.compare(a.urlMatcher, b.urlMatcher);
};
/** @hidden */
var idSort = function (a, b) {
    // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL
    var useMatchPriority = { STATE: true, URLMATCHER: true };
    var equal = useMatchPriority[a.type] && useMatchPriority[b.type];
    return equal ? 0 : (a.$id || 0) - (b.$id || 0);
};
/**
 * Default rule priority sorting function.
 *
 * Sorts rules by:
 *
 * - Explicit priority (set rule priority using [[UrlRulesApi.when]])
 * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)
 * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.
 * - Rule registration order (for rule types other than STATE and URLMATCHER)
 *   - Equally sorted State and UrlMatcher rules will each match the URL.
 *     Then, the *best* match is chosen based on how many parameter values were matched.
 *
 * @coreapi
 */
var defaultRuleSortFn;
defaultRuleSortFn = function (a, b) {
    var cmp = prioritySort(a, b);
    if (cmp !== 0)
        return cmp;
    cmp = typeSort(a, b);
    if (cmp !== 0)
        return cmp;
    cmp = urlMatcherSort(a, b);
    if (cmp !== 0)
        return cmp;
    return idSort(a, b);
};
/**
 * Updates URL and responds to URL changes
 *
 * ### Deprecation warning:
 * This class is now considered to be an internal API
 * Use the [[UrlService]] instead.
 * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].
 *
 * This class updates the URL when the state changes.
 * It also responds to changes in the URL.
 */
var UrlRouter = /** @class */ (function () {
    /** @hidden */
    function UrlRouter(router) {
        /** @hidden */ this._sortFn = defaultRuleSortFn;
        /** @hidden */ this._rules = [];
        /** @hidden */ this.interceptDeferred = false;
        /** @hidden */ this._id = 0;
        /** @hidden */ this._sorted = false;
        this._router = router;
        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);
        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));
    }
    /** @internalapi */
    UrlRouter.prototype.dispose = function () {
        this.listen(false);
        this._rules = [];
        delete this._otherwiseFn;
    };
    /** @inheritdoc */
    UrlRouter.prototype.sort = function (compareFn) {
        this._rules = this.stableSort(this._rules, (this._sortFn = compareFn || this._sortFn));
        this._sorted = true;
    };
    UrlRouter.prototype.ensureSorted = function () {
        this._sorted || this.sort();
    };
    UrlRouter.prototype.stableSort = function (arr, compareFn) {
        var arrOfWrapper = arr.map(function (elem, idx) { return ({ elem: elem, idx: idx }); });
        arrOfWrapper.sort(function (wrapperA, wrapperB) {
            var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);
            return cmpDiff === 0 ? wrapperA.idx - wrapperB.idx : cmpDiff;
        });
        return arrOfWrapper.map(function (wrapper) { return wrapper.elem; });
    };
    /**
     * Given a URL, check all rules and return the best [[MatchResult]]
     * @param url
     * @returns {MatchResult}
     */
    UrlRouter.prototype.match = function (url) {
        var _this = this;
        this.ensureSorted();
        url = common_1.extend({ path: '', search: {}, hash: '' }, url);
        var rules = this.rules();
        if (this._otherwiseFn)
            rules.push(this._otherwiseFn);
        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined
        var checkRule = function (rule) {
            var match = rule.match(url, _this._router);
            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };
        };
        // The rules are pre-sorted.
        // - Find the first matching rule.
        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.
        // - Choose the rule with the highest match weight.
        var best;
        for (var i = 0; i < rules.length; i++) {
            // Stop when there is a 'best' rule and the next rule sorts differently than it.
            if (best && this._sortFn(rules[i], best.rule) !== 0)
                break;
            var current = checkRule(rules[i]);
            // Pick the best MatchResult
            best = !best || (current && current.weight > best.weight) ? current : best;
        }
        return best;
    };
    /** @inheritdoc */
    UrlRouter.prototype.sync = function (evt) {
        if (evt && evt.defaultPrevented)
            return;
        var router = this._router, $url = router.urlService, $state = router.stateService;
        var url = {
            path: $url.path(),
            search: $url.search(),
            hash: $url.hash(),
        };
        var best = this.match(url);
        var applyResult = hof_1.pattern([
            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],
            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],
            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],
        ]);
        applyResult(best && best.rule.handler(best.match, url, router));
    };
    /** @inheritdoc */
    UrlRouter.prototype.listen = function (enabled) {
        var _this = this;
        if (enabled === false) {
            this._stopFn && this._stopFn();
            delete this._stopFn;
        }
        else {
            return (this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); }));
        }
    };
    /**
     * Internal API.
     * @internalapi
     */
    UrlRouter.prototype.update = function (read) {
        var $url = this._router.locationService;
        if (read) {
            this.location = $url.url();
            return;
        }
        if ($url.url() === this.location)
            return;
        $url.url(this.location, true);
    };
    /**
     * Internal API.
     *
     * Pushes a new location to the browser history.
     *
     * @internalapi
     * @param urlMatcher
     * @param params
     * @param options
     */
    UrlRouter.prototype.push = function (urlMatcher, params, options) {
        var replace = options && !!options.replace;
        this._router.urlService.url(urlMatcher.format(params || {}), replace);
    };
    /**
     * Builds and returns a URL with interpolated parameters
     *
     * #### Example:
     * ```js
     * matcher = $umf.compile("/about/:person");
     * params = { person: "bob" };
     * $bob = $urlRouter.href(matcher, params);
     * // $bob == "/about/bob";
     * ```
     *
     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.
     * @param params An object of parameter values to fill the matcher's required parameters.
     * @param options Options object. The options are:
     *
     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
     *
     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
     */
    UrlRouter.prototype.href = function (urlMatcher, params, options) {
        var url = urlMatcher.format(params);
        if (url == null)
            return null;
        options = options || { absolute: false };
        var cfg = this._router.urlService.config;
        var isHtml5 = cfg.html5Mode();
        if (!isHtml5 && url !== null) {
            url = '#' + cfg.hashPrefix() + url;
        }
        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());
        if (!options.absolute || !url) {
            return url;
        }
        var slash = !isHtml5 && url ? '/' : '';
        var cfgPort = cfg.port();
        var port = (cfgPort === 80 || cfgPort === 443 ? '' : ':' + cfgPort);
        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');
    };
    /**
     * Manually adds a URL Rule.
     *
     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].
     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).
     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.
     *
     * A rule should have a `match` function which returns truthy if the rule matched.
     * It should also have a `handler` function which is invoked if the rule is the best match.
     *
     * @return a function that deregisters the rule
     */
    UrlRouter.prototype.rule = function (rule) {
        var _this = this;
        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))
            throw new Error('invalid rule');
        rule.$id = this._id++;
        rule.priority = rule.priority || 0;
        this._rules.push(rule);
        this._sorted = false;
        return function () { return _this.removeRule(rule); };
    };
    /** @inheritdoc */
    UrlRouter.prototype.removeRule = function (rule) {
        common_1.removeFrom(this._rules, rule);
    };
    /** @inheritdoc */
    UrlRouter.prototype.rules = function () {
        this.ensureSorted();
        return this._rules.slice();
    };
    /** @inheritdoc */
    UrlRouter.prototype.otherwise = function (handler) {
        var handlerFn = getHandlerFn(handler);
        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);
        this._sorted = false;
    };
    /** @inheritdoc */
    UrlRouter.prototype.initial = function (handler) {
        var handlerFn = getHandlerFn(handler);
        var matchFn = function (urlParts, router) {
            return router.globals.transitionHistory.size() === 0 && !!/^\/?$/.exec(urlParts.path);
        };
        this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
    };
    /** @inheritdoc */
    UrlRouter.prototype.when = function (matcher, handler, options) {
        var rule = this.urlRuleFactory.create(matcher, handler);
        if (predicates_1.isDefined(options && options.priority))
            rule.priority = options.priority;
        this.rule(rule);
        return rule;
    };
    /** @inheritdoc */
    UrlRouter.prototype.deferIntercept = function (defer) {
        if (defer === undefined)
            defer = true;
        this.interceptDeferred = defer;
    };
    return UrlRouter;
}());
exports.UrlRouter = UrlRouter;
function getHandlerFn(handler) {
    if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {
        throw new Error("'handler' must be a string, function, TargetState, or have a state: 'newtarget' property");
    }
    return predicates_1.isFunction(handler) ? handler : hof_1.val(handler);
}
//# sourceMappingURL=urlRouter.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/urlRule.js":
/*!********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/urlRule.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module url
 */ /** */
var urlMatcher_1 = __webpack_require__(/*! ./urlMatcher */ "./node_modules/@uirouter/core/lib/url/urlMatcher.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
/**
 * Creates a [[UrlRule]]
 *
 * Creates a [[UrlRule]] from a:
 *
 * - `string`
 * - [[UrlMatcher]]
 * - `RegExp`
 * - [[StateObject]]
 * @internalapi
 */
var UrlRuleFactory = /** @class */ (function () {
    function UrlRuleFactory(router) {
        this.router = router;
    }
    UrlRuleFactory.prototype.compile = function (str) {
        return this.router.urlMatcherFactory.compile(str);
    };
    UrlRuleFactory.prototype.create = function (what, handler) {
        var _this = this;
        var makeRule = hof_1.pattern([
            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],
            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],
            [predicates_1.isState, function (_what) { return _this.fromState(_what, _this.router); }],
            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],
            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],
        ]);
        var rule = makeRule(what);
        if (!rule)
            throw new Error("invalid 'what' in when()");
        return rule;
    };
    /**
     * A UrlRule which matches based on a UrlMatcher
     *
     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]
     *
     * ## Handler as a function
     *
     * If `handler` is a function, the function is invoked with:
     *
     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])
     * - url: the current Url ([[UrlParts]])
     * - router: the router object ([[UIRouter]])
     *
     * #### Example:
     * ```js
     * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
     * var rule = factory.fromUrlMatcher(urlMatcher, match => "/home/" + match.fooId + "/" + match.barId);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match); // '/home/123/456'
     * ```
     *
     * ## Handler as UrlMatcher
     *
     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.
     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.
     * The url is replaced with the result.
     *
     * #### Example:
     * ```js
     * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
     * var handler = $umf.compile("/home/:fooId/:barId");
     * var rule = factory.fromUrlMatcher(urlMatcher, handler);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match); // '/home/123/456'
     * ```
     */
    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {
        var _handler = handler;
        if (predicates_1.isString(handler))
            handler = this.router.urlMatcherFactory.compile(handler);
        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))
            _handler = function (match) { return handler.format(match); };
        function matchUrlParamters(url) {
            var params = urlMatcher.exec(url.path, url.search, url.hash);
            return urlMatcher.validates(params) && params;
        }
        // Prioritize URLs, lowest to highest:
        // - Some optional URL parameters, but none matched
        // - No optional parameters in URL
        // - Some optional parameters, some matched
        // - Some optional parameters, all matched
        function matchPriority(params) {
            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });
            if (!optional.length)
                return 0.000001;
            var matched = optional.filter(function (param) { return params[param.id]; });
            return matched.length / optional.length;
        }
        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: 'URLMATCHER' };
        return common_1.extend(new BaseUrlRule(matchUrlParamters, _handler), details);
    };
    /**
     * A UrlRule which matches a state by its url
     *
     * #### Example:
     * ```js
     * var rule = factory.fromState($state.get('foo'), router);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match);
     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }
     * ```
     */
    UrlRuleFactory.prototype.fromState = function (state, router) {
        /**
         * Handles match by transitioning to matched state
         *
         * First checks if the router should start a new transition.
         * A new transition is not required if the current state's URL
         * and the new URL are already identical
         */
        var handler = function (match) {
            var $state = router.stateService;
            var globals = router.globals;
            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {
                $state.transitionTo(state, match, { inherit: true, source: 'url' });
            }
        };
        var details = { state: state, type: 'STATE' };
        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);
    };
    /**
     * A UrlRule which matches based on a regular expression
     *
     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.
     *
     * ## Handler as a function
     *
     * If `handler` is a function, the function is invoked with:
     *
     * - regexp match array (from `regexp`)
     * - url: the current Url ([[UrlParts]])
     * - router: the router object ([[UIRouter]])
     *
     * #### Example:
     * ```js
     * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, match => "/home/" + match[1])
     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
     * var result = rule.handler(match); // '/home/bar'
     * ```
     *
     * ## Handler as string
     *
     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.
     * The string is first interpolated using `string.replace()` style pattern.
     *
     * #### Example:
     * ```js
     * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, "/home/$1")
     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
     * var result = rule.handler(match); // '/home/bar'
     * ```
     */
    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {
        if (regexp.global || regexp.sticky)
            throw new Error('Rule RegExp must not be global or sticky');
        /**
         * If handler is a string, the url will be replaced by the string.
         * If the string has any String.replace() style variables in it (like `$2`),
         * they will be replaced by the captures from [[match]]
         */
        var redirectUrlTo = function (match) {
            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern
            return handler.replace(/\$(\$|\d{1,2})/, function (m, what) { return match[what === '$' ? 0 : Number(what)]; });
        };
        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;
        var matchParamsFromRegexp = function (url) { return regexp.exec(url.path); };
        var details = { regexp: regexp, type: 'REGEXP' };
        return common_1.extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details);
    };
    UrlRuleFactory.isUrlRule = function (obj) { return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); }); };
    return UrlRuleFactory;
}());
exports.UrlRuleFactory = UrlRuleFactory;
/**
 * A base rule which calls `match`
 *
 * The value from the `match` function is passed through to the `handler`.
 * @internalapi
 */
var BaseUrlRule = /** @class */ (function () {
    function BaseUrlRule(match, handler) {
        var _this = this;
        this.match = match;
        this.type = 'RAW';
        this.matchPriority = function (match) { return 0 - _this.$id; };
        this.handler = handler || common_1.identity;
    }
    return BaseUrlRule;
}());
exports.BaseUrlRule = BaseUrlRule;
//# sourceMappingURL=urlRule.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/url/urlService.js":
/*!***********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/url/urlService.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module url
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
/** @hidden */
var makeStub = function (keys) {
    return keys.reduce(function (acc, key) { return ((acc[key] = coreservices_1.notImplemented(key)), acc); }, { dispose: common_1.noop });
};
/** @hidden */
var locationServicesFns = ['url', 'path', 'search', 'hash', 'onChange'];
/** @hidden */
var locationConfigFns = ['port', 'protocol', 'host', 'baseHref', 'html5Mode', 'hashPrefix'];
/** @hidden */
var umfFns = ['type', 'caseInsensitive', 'strictMode', 'defaultSquashPolicy'];
/** @hidden */
var rulesFns = ['sort', 'when', 'initial', 'otherwise', 'rules', 'rule', 'removeRule'];
/** @hidden */
var syncFns = ['deferIntercept', 'listen', 'sync', 'match'];
/**
 * API for URL management
 */
var UrlService = /** @class */ (function () {
    /** @hidden */
    function UrlService(router, lateBind) {
        if (lateBind === void 0) { lateBind = true; }
        this.router = router;
        this.rules = {};
        this.config = {};
        // proxy function calls from UrlService to the LocationService/LocationConfig
        var locationServices = function () { return router.locationService; };
        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);
        var locationConfig = function () { return router.locationConfig; };
        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);
        var umf = function () { return router.urlMatcherFactory; };
        common_1.createProxyFunctions(umf, this.config, umf, umfFns);
        var urlRouter = function () { return router.urlRouter; };
        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);
        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);
    }
    UrlService.prototype.url = function (newurl, replace, state) {
        return;
    };
    /** @inheritdoc */
    UrlService.prototype.path = function () {
        return;
    };
    /** @inheritdoc */
    UrlService.prototype.search = function () {
        return;
    };
    /** @inheritdoc */
    UrlService.prototype.hash = function () {
        return;
    };
    /** @inheritdoc */
    UrlService.prototype.onChange = function (callback) {
        return;
    };
    /**
     * Returns the current URL parts
     *
     * This method returns the current URL components as a [[UrlParts]] object.
     *
     * @returns the current url parts
     */
    UrlService.prototype.parts = function () {
        return { path: this.path(), search: this.search(), hash: this.hash() };
    };
    UrlService.prototype.dispose = function () { };
    /** @inheritdoc */
    UrlService.prototype.sync = function (evt) {
        return;
    };
    /** @inheritdoc */
    UrlService.prototype.listen = function (enabled) {
        return;
    };
    /** @inheritdoc */
    UrlService.prototype.deferIntercept = function (defer) {
        return;
    };
    /** @inheritdoc */
    UrlService.prototype.match = function (urlParts) {
        return;
    };
    /** @hidden */
    UrlService.locationServiceStub = makeStub(locationServicesFns);
    /** @hidden */
    UrlService.locationConfigStub = makeStub(locationConfigFns);
    return UrlService;
}());
exports.UrlService = UrlService;
//# sourceMappingURL=urlService.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla.js":
/*!****************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
__export(__webpack_require__(/*! ./vanilla/index */ "./node_modules/@uirouter/core/lib/vanilla/index.js"));
//# sourceMappingURL=vanilla.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js":
/*!************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @internalapi
 * @module vanilla
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ../common */ "./node_modules/@uirouter/core/lib/common/index.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@uirouter/core/lib/vanilla/utils.js");
/** A base `LocationServices` */
var BaseLocationServices = /** @class */ (function () {
    function BaseLocationServices(router, fireAfterUpdate) {
        var _this = this;
        this.fireAfterUpdate = fireAfterUpdate;
        this._listeners = [];
        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };
        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };
        this.path = function () { return utils_1.parseUrl(_this._get()).path; };
        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };
        this._location = common_1.root.location;
        this._history = common_1.root.history;
    }
    BaseLocationServices.prototype.url = function (url, replace) {
        if (replace === void 0) { replace = true; }
        if (common_1.isDefined(url) && url !== this._get()) {
            this._set(null, null, url, replace);
            if (this.fireAfterUpdate) {
                this._listeners.forEach(function (cb) { return cb({ url: url }); });
            }
        }
        return utils_1.buildUrl(this);
    };
    BaseLocationServices.prototype.onChange = function (cb) {
        var _this = this;
        this._listeners.push(cb);
        return function () { return common_1.removeFrom(_this._listeners, cb); };
    };
    BaseLocationServices.prototype.dispose = function (router) {
        common_1.deregAll(this._listeners);
    };
    return BaseLocationServices;
}());
exports.BaseLocationServices = BaseLocationServices;
//# sourceMappingURL=baseLocationService.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/browserLocationConfig.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/browserLocationConfig.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
/** A `LocationConfig` that delegates to the browser's `location` object */
var BrowserLocationConfig = /** @class */ (function () {
    function BrowserLocationConfig(router, _isHtml5) {
        if (_isHtml5 === void 0) { _isHtml5 = false; }
        this._isHtml5 = _isHtml5;
        this._baseHref = undefined;
        this._hashPrefix = '';
    }
    BrowserLocationConfig.prototype.port = function () {
        if (location.port) {
            return Number(location.port);
        }
        return this.protocol() === 'https' ? 443 : 80;
    };
    BrowserLocationConfig.prototype.protocol = function () {
        return location.protocol.replace(/:/g, '');
    };
    BrowserLocationConfig.prototype.host = function () {
        return location.hostname;
    };
    BrowserLocationConfig.prototype.html5Mode = function () {
        return this._isHtml5;
    };
    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {
        return predicates_1.isDefined(newprefix) ? (this._hashPrefix = newprefix) : this._hashPrefix;
    };
    BrowserLocationConfig.prototype.baseHref = function (href) {
        return predicates_1.isDefined(href)
            ? (this._baseHref = href)
            : predicates_1.isDefined(this._baseHref) ? this._baseHref : this.applyDocumentBaseHref();
    };
    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {
        var baseTag = document.getElementsByTagName('base')[0];
        return (this._baseHref = baseTag ? baseTag.href.substr(location.origin.length) : location.pathname || '/');
    };
    BrowserLocationConfig.prototype.dispose = function () { };
    return BrowserLocationConfig;
}());
exports.BrowserLocationConfig = BrowserLocationConfig;
//# sourceMappingURL=browserLocationConfig.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/hashLocationService.js":
/*!************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/hashLocationService.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var common_1 = __webpack_require__(/*! ../common */ "./node_modules/@uirouter/core/lib/common/index.js");
var baseLocationService_1 = __webpack_require__(/*! ./baseLocationService */ "./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js");
/** A `LocationServices` that uses the browser hash "#" to get/set the current location */
var HashLocationService = /** @class */ (function (_super) {
    __extends(HashLocationService, _super);
    function HashLocationService(router) {
        var _this = _super.call(this, router, false) || this;
        common_1.root.addEventListener('hashchange', _this._listener, false);
        return _this;
    }
    HashLocationService.prototype._get = function () {
        return common_1.trimHashVal(this._location.hash);
    };
    HashLocationService.prototype._set = function (state, title, url, replace) {
        this._location.hash = url;
    };
    HashLocationService.prototype.dispose = function (router) {
        _super.prototype.dispose.call(this, router);
        common_1.root.removeEventListener('hashchange', this._listener);
    };
    return HashLocationService;
}(baseLocationService_1.BaseLocationServices));
exports.HashLocationService = HashLocationService;
//# sourceMappingURL=hashLocationService.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./q */ "./node_modules/@uirouter/core/lib/vanilla/q.js"));
__export(__webpack_require__(/*! ./injector */ "./node_modules/@uirouter/core/lib/vanilla/injector.js"));
__export(__webpack_require__(/*! ./baseLocationService */ "./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js"));
__export(__webpack_require__(/*! ./hashLocationService */ "./node_modules/@uirouter/core/lib/vanilla/hashLocationService.js"));
__export(__webpack_require__(/*! ./memoryLocationService */ "./node_modules/@uirouter/core/lib/vanilla/memoryLocationService.js"));
__export(__webpack_require__(/*! ./pushStateLocationService */ "./node_modules/@uirouter/core/lib/vanilla/pushStateLocationService.js"));
__export(__webpack_require__(/*! ./memoryLocationConfig */ "./node_modules/@uirouter/core/lib/vanilla/memoryLocationConfig.js"));
__export(__webpack_require__(/*! ./browserLocationConfig */ "./node_modules/@uirouter/core/lib/vanilla/browserLocationConfig.js"));
__export(__webpack_require__(/*! ./utils */ "./node_modules/@uirouter/core/lib/vanilla/utils.js"));
__export(__webpack_require__(/*! ./plugins */ "./node_modules/@uirouter/core/lib/vanilla/plugins.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/injector.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/injector.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var index_1 = __webpack_require__(/*! ../common/index */ "./node_modules/@uirouter/core/lib/common/index.js");
// globally available injectables
var globals = {};
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
var ARGUMENT_NAMES = /([^\s,]+)/g;
/**
 * A basic angular1-like injector api
 *
 * This object implements four methods similar to the
 * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)
 *
 * UI-Router evolved from an angular 1 library to a framework agnostic library.
 * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.
 *
 * This object provides a naive implementation of a globally scoped dependency injection system.
 * It supports the following DI approaches:
 *
 * ### Function parameter names
 *
 * A function's `.toString()` is called, and the parameter names are parsed.
 * This only works when the parameter names aren't "mangled" by a minifier such as UglifyJS.
 *
 * ```js
 * function injectedFunction(FooService, BarService) {
 *   // FooService and BarService are injected
 * }
 * ```
 *
 * ### Function annotation
 *
 * A function may be annotated with an array of dependency names as the `$inject` property.
 *
 * ```js
 * injectedFunction.$inject = [ 'FooService', 'BarService' ];
 * function injectedFunction(fs, bs) {
 *   // FooService and BarService are injected as fs and bs parameters
 * }
 * ```
 *
 * ### Array notation
 *
 * An array provides the names of the dependencies to inject (as strings).
 * The function is the last element of the array.
 *
 * ```js
 * [ 'FooService', 'BarService', function (fs, bs) {
 *   // FooService and BarService are injected as fs and bs parameters
 * }]
 * ```
 *
 * @type {$InjectorLike}
 */
exports.$injector = {
    /** Gets an object from DI based on a string token */
    get: function (name) { return globals[name]; },
    /** Returns true if an object named `name` exists in global DI */
    has: function (name) { return exports.$injector.get(name) != null; },
    /**
     * Injects a function
     *
     * @param fn the function to inject
     * @param context the function's `this` binding
     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`
     */
    invoke: function (fn, context, locals) {
        var all = index_1.extend({}, globals, locals || {});
        var params = exports.$injector.annotate(fn);
        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return "DI can't find injectable: '" + key + "'"; });
        var args = params.filter(ensureExist).map(function (x) { return all[x]; });
        if (index_1.isFunction(fn))
            return fn.apply(context, args);
        else
            return fn.slice(-1)[0].apply(context, args);
    },
    /**
     * Returns a function's dependencies
     *
     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.
     * @return an array of `string`s
     */
    annotate: function (fn) {
        if (!index_1.isInjectable(fn))
            throw new Error("Not an injectable function: " + fn);
        if (fn && fn.$inject)
            return fn.$inject;
        if (index_1.isArray(fn))
            return fn.slice(0, -1);
        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');
        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
        return result || [];
    },
};
//# sourceMappingURL=injector.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/memoryLocationConfig.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/memoryLocationConfig.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
/** A `LocationConfig` mock that gets/sets all config from an in-memory object */
var MemoryLocationConfig = /** @class */ (function () {
    function MemoryLocationConfig() {
        var _this = this;
        this.dispose = common_1.noop;
        this._baseHref = '';
        this._port = 80;
        this._protocol = 'http';
        this._host = 'localhost';
        this._hashPrefix = '';
        this.port = function () { return _this._port; };
        this.protocol = function () { return _this._protocol; };
        this.host = function () { return _this._host; };
        this.baseHref = function () { return _this._baseHref; };
        this.html5Mode = function () { return false; };
        this.hashPrefix = function (newval) { return (predicates_1.isDefined(newval) ? (_this._hashPrefix = newval) : _this._hashPrefix); };
    }
    return MemoryLocationConfig;
}());
exports.MemoryLocationConfig = MemoryLocationConfig;
//# sourceMappingURL=memoryLocationConfig.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/memoryLocationService.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/memoryLocationService.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var baseLocationService_1 = __webpack_require__(/*! ./baseLocationService */ "./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js");
/** A `LocationServices` that gets/sets the current location from an in-memory object */
var MemoryLocationService = /** @class */ (function (_super) {
    __extends(MemoryLocationService, _super);
    function MemoryLocationService(router) {
        return _super.call(this, router, true) || this;
    }
    MemoryLocationService.prototype._get = function () {
        return this._url;
    };
    MemoryLocationService.prototype._set = function (state, title, url, replace) {
        this._url = url;
    };
    return MemoryLocationService;
}(baseLocationService_1.BaseLocationServices));
exports.MemoryLocationService = MemoryLocationService;
//# sourceMappingURL=memoryLocationService.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/plugins.js":
/*!************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/plugins.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var browserLocationConfig_1 = __webpack_require__(/*! ./browserLocationConfig */ "./node_modules/@uirouter/core/lib/vanilla/browserLocationConfig.js");
var hashLocationService_1 = __webpack_require__(/*! ./hashLocationService */ "./node_modules/@uirouter/core/lib/vanilla/hashLocationService.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@uirouter/core/lib/vanilla/utils.js");
var pushStateLocationService_1 = __webpack_require__(/*! ./pushStateLocationService */ "./node_modules/@uirouter/core/lib/vanilla/pushStateLocationService.js");
var memoryLocationService_1 = __webpack_require__(/*! ./memoryLocationService */ "./node_modules/@uirouter/core/lib/vanilla/memoryLocationService.js");
var memoryLocationConfig_1 = __webpack_require__(/*! ./memoryLocationConfig */ "./node_modules/@uirouter/core/lib/vanilla/memoryLocationConfig.js");
var injector_1 = __webpack_require__(/*! ./injector */ "./node_modules/@uirouter/core/lib/vanilla/injector.js");
var q_1 = __webpack_require__(/*! ./q */ "./node_modules/@uirouter/core/lib/vanilla/q.js");
var coreservices_1 = __webpack_require__(/*! ../common/coreservices */ "./node_modules/@uirouter/core/lib/common/coreservices.js");
function servicesPlugin(router) {
    coreservices_1.services.$injector = injector_1.$injector;
    coreservices_1.services.$q = q_1.$q;
    return { name: 'vanilla.services', $q: q_1.$q, $injector: injector_1.$injector, dispose: function () { return null; } };
}
exports.servicesPlugin = servicesPlugin;
/** A `UIRouterPlugin` uses the browser hash to get/set the current location */
exports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);
/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */
exports.pushStateLocationPlugin = utils_1.locationPluginFactory('vanilla.pushStateLocation', true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);
/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */
exports.memoryLocationPlugin = utils_1.locationPluginFactory('vanilla.memoryLocation', false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);
//# sourceMappingURL=plugins.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/pushStateLocationService.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/pushStateLocationService.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var baseLocationService_1 = __webpack_require__(/*! ./baseLocationService */ "./node_modules/@uirouter/core/lib/vanilla/baseLocationService.js");
var common_1 = __webpack_require__(/*! ../common */ "./node_modules/@uirouter/core/lib/common/index.js");
/**
 * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis
 *
 * Uses `history.pushState` and `history.replaceState`
 */
var PushStateLocationService = /** @class */ (function (_super) {
    __extends(PushStateLocationService, _super);
    function PushStateLocationService(router) {
        var _this = _super.call(this, router, true) || this;
        _this._config = router.urlService.config;
        common_1.root.addEventListener('popstate', _this._listener, false);
        return _this;
    }
    /**
     * Gets the base prefix without:
     * - trailing slash
     * - trailing filename
     * - protocol and hostname
     *
     * If <base href='/base/'>, this returns '/base'.
     * If <base href='/foo/base/'>, this returns '/foo/base'.
     * If <base href='/base/index.html'>, this returns '/base'.
     * If <base href='http://localhost:8080/base/index.html'>, this returns '/base'.
     * If <base href='/base'>, this returns ''.
     * If <base href='http://localhost:8080'>, this returns ''.
     * If <base href='http://localhost:8080/'>, this returns ''.
     *
     * See: https://html.spec.whatwg.org/dev/semantics.html#the-base-element
     */
    PushStateLocationService.prototype._getBasePrefix = function () {
        return common_1.stripLastPathElement(this._config.baseHref());
    };
    PushStateLocationService.prototype._get = function () {
        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;
        search = common_1.splitQuery(search)[1]; // strip ? if found
        hash = common_1.splitHash(hash)[1]; // strip # if found
        var basePrefix = this._getBasePrefix();
        var exactBaseHrefMatch = pathname === this._config.baseHref();
        var startsWithBase = pathname.substr(0, basePrefix.length) === basePrefix;
        pathname = exactBaseHrefMatch ? '/' : startsWithBase ? pathname.substring(basePrefix.length) : pathname;
        return pathname + (search ? '?' + search : '') + (hash ? '#' + hash : '');
    };
    PushStateLocationService.prototype._set = function (state, title, url, replace) {
        var basePrefix = this._getBasePrefix();
        var slash = url && url[0] !== '/' ? '/' : '';
        var fullUrl = url === '' || url === '/' ? this._config.baseHref() : basePrefix + slash + url;
        if (replace) {
            this._history.replaceState(state, title, fullUrl);
        }
        else {
            this._history.pushState(state, title, fullUrl);
        }
    };
    PushStateLocationService.prototype.dispose = function (router) {
        _super.prototype.dispose.call(this, router);
        common_1.root.removeEventListener('popstate', this._listener);
    };
    return PushStateLocationService;
}(baseLocationService_1.BaseLocationServices));
exports.PushStateLocationService = PushStateLocationService;
//# sourceMappingURL=pushStateLocationService.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/q.js":
/*!******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/q.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var index_1 = __webpack_require__(/*! ../common/index */ "./node_modules/@uirouter/core/lib/common/index.js");
/**
 * An angular1-like promise api
 *
 * This object implements four methods similar to the
 * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)
 *
 * UI-Router evolved from an angular 1 library to a framework agnostic library.
 * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.
 *
 * This API provides native ES6 promise support wrapped as a $q-like API.
 * Internally, UI-Router uses this $q object to perform promise operations.
 * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.
 *
 * $q-like promise api
 */
exports.$q = {
    /** Normalizes a value as a promise */
    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },
    /** Normalizes a value as a promise rejection */
    reject: function (val) {
        return new Promise(function (resolve, reject) {
            reject(val);
        });
    },
    /** @returns a deferred object, which has `resolve` and `reject` functions */
    defer: function () {
        var deferred = {};
        deferred.promise = new Promise(function (resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        return deferred;
    },
    /** Like Promise.all(), but also supports object key/promise notation like $q */
    all: function (promises) {
        if (index_1.isArray(promises)) {
            return Promise.all(promises);
        }
        if (index_1.isObject(promises)) {
            // Convert promises map to promises array.
            // When each promise resolves, map it to a tuple { key: key, val: val }
            var chain = Object.keys(promises).map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });
            // Then wait for all promises to resolve, and convert them back to an object
            return exports.$q.all(chain).then(function (values) {
                return values.reduce(function (acc, tuple) {
                    acc[tuple.key] = tuple.val;
                    return acc;
                }, {});
            });
        }
    },
};
//# sourceMappingURL=q.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/vanilla/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/vanilla/utils.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var common_1 = __webpack_require__(/*! ../common */ "./node_modules/@uirouter/core/lib/common/index.js");
exports.keyValsToObjectR = function (accum, _a) {
    var key = _a[0], val = _a[1];
    if (!accum.hasOwnProperty(key)) {
        accum[key] = val;
    }
    else if (common_1.isArray(accum[key])) {
        accum[key].push(val);
    }
    else {
        accum[key] = [accum[key], val];
    }
    return accum;
};
exports.getParams = function (queryString) {
    return queryString
        .split('&')
        .filter(common_1.identity)
        .map(common_1.splitEqual)
        .reduce(exports.keyValsToObjectR, {});
};
function parseUrl(url) {
    var orEmptyString = function (x) { return x || ''; };
    var _a = common_1.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];
    var _b = common_1.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];
    return { path: path, search: search, hash: hash, url: url };
}
exports.parseUrl = parseUrl;
exports.buildUrl = function (loc) {
    var path = loc.path();
    var searchObject = loc.search();
    var hash = loc.hash();
    var search = Object.keys(searchObject)
        .map(function (key) {
        var param = searchObject[key];
        var vals = common_1.isArray(param) ? param : [param];
        return vals.map(function (val) { return key + '=' + val; });
    })
        .reduce(common_1.unnestR, [])
        .join('&');
    return path + (search ? '?' + search : '') + (hash ? '#' + hash : '');
};
function locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {
    return function (uiRouter) {
        var service = (uiRouter.locationService = new serviceClass(uiRouter));
        var configuration = (uiRouter.locationConfig = new configurationClass(uiRouter, isHtml5));
        function dispose(router) {
            router.dispose(service);
            router.dispose(configuration);
        }
        return { name: name, service: service, configuration: configuration, dispose: dispose };
    };
}
exports.locationPluginFactory = locationPluginFactory;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/view/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/view/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./view */ "./node_modules/@uirouter/core/lib/view/view.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@uirouter/core/lib/view/view.js":
/*!******************************************************!*\
  !*** ./node_modules/@uirouter/core/lib/view/view.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module view
 */ /** for typedoc */
var common_1 = __webpack_require__(/*! ../common/common */ "./node_modules/@uirouter/core/lib/common/common.js");
var hof_1 = __webpack_require__(/*! ../common/hof */ "./node_modules/@uirouter/core/lib/common/hof.js");
var predicates_1 = __webpack_require__(/*! ../common/predicates */ "./node_modules/@uirouter/core/lib/common/predicates.js");
var trace_1 = __webpack_require__(/*! ../common/trace */ "./node_modules/@uirouter/core/lib/common/trace.js");
/**
 * The View service
 *
 * This service pairs existing `ui-view` components (which live in the DOM)
 * with view configs (from the state declaration objects: [[StateDeclaration.views]]).
 *
 * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].
 *   The views from exited states are deactivated via [[deactivateViewConfig]].
 *   (See: the [[registerActivateViews]] Transition Hook)
 *
 * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].
 *
 * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])
 * are configured with the matching [[ViewConfig]](s)
 *
 */
var ViewService = /** @class */ (function () {
    function ViewService() {
        var _this = this;
        this._uiViews = [];
        this._viewConfigs = [];
        this._viewConfigFactories = {};
        this._listeners = [];
        this._pluginapi = {
            _rootViewContext: this._rootViewContext.bind(this),
            _viewConfigFactory: this._viewConfigFactory.bind(this),
            _registeredUIViews: function () { return _this._uiViews; },
            _activeViewConfigs: function () { return _this._viewConfigs; },
            _onSync: function (listener) {
                _this._listeners.push(listener);
                return function () { return common_1.removeFrom(_this._listeners, listener); };
            },
        };
    }
    /**
     * Normalizes a view's name from a state.views configuration block.
     *
     * This should be used by a framework implementation to calculate the values for
     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].
     *
     * @param context the context object (state declaration) that the view belongs to
     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]
     *
     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets
     */
    ViewService.normalizeUIViewTarget = function (context, rawViewName) {
        if (rawViewName === void 0) { rawViewName = ''; }
        // TODO: Validate incoming view name with a regexp to allow:
        // ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,
        // "@" , "$default@^" , "!$default.$default" , "!foo.bar"
        var viewAtContext = rawViewName.split('@');
        var uiViewName = viewAtContext[0] || '$default'; // default to unnamed view
        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : '^'; // default to parent context
        // Handle relative view-name sugar syntax.
        // Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],
        var relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
        if (relativeViewNameSugar) {
            // Clobbers existing contextAnchor (rawViewName validation will fix this)
            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to "^.^.^"
            uiViewName = relativeViewNameSugar[2]; // set view-name to "foo.bar"
        }
        if (uiViewName.charAt(0) === '!') {
            uiViewName = uiViewName.substr(1);
            uiViewContextAnchor = ''; // target absolutely from root
        }
        // handle parent relative targeting "^.^.^"
        var relativeMatch = /^(\^(?:\.\^)*)$/;
        if (relativeMatch.exec(uiViewContextAnchor)) {
            var anchorState = uiViewContextAnchor.split('.').reduce(function (anchor, x) { return anchor.parent; }, context);
            uiViewContextAnchor = anchorState.name;
        }
        else if (uiViewContextAnchor === '.') {
            uiViewContextAnchor = context.name;
        }
        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };
    };
    ViewService.prototype._rootViewContext = function (context) {
        return (this._rootContext = context || this._rootContext);
    };
    ViewService.prototype._viewConfigFactory = function (viewType, factory) {
        this._viewConfigFactories[viewType] = factory;
    };
    ViewService.prototype.createViewConfig = function (path, decl) {
        var cfgFactory = this._viewConfigFactories[decl.$type];
        if (!cfgFactory)
            throw new Error('ViewService: No view config factory registered for type ' + decl.$type);
        var cfgs = cfgFactory(path, decl);
        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];
    };
    /**
     * Deactivates a ViewConfig.
     *
     * This function deactivates a `ViewConfig`.
     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.
     *
     * @param viewConfig The ViewConfig view to deregister.
     */
    ViewService.prototype.deactivateViewConfig = function (viewConfig) {
        trace_1.trace.traceViewServiceEvent('<- Removing', viewConfig);
        common_1.removeFrom(this._viewConfigs, viewConfig);
    };
    ViewService.prototype.activateViewConfig = function (viewConfig) {
        trace_1.trace.traceViewServiceEvent('-> Registering', viewConfig);
        this._viewConfigs.push(viewConfig);
    };
    ViewService.prototype.sync = function () {
        var _this = this;
        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});
        // Return a weighted depth value for a uiView.
        // The depth is the nesting depth of ui-views (based on FQN; times 10,000)
        // plus the depth of the state that is populating the uiView
        function uiViewDepth(uiView) {
            var stateDepth = function (context) { return (context && context.parent ? stateDepth(context.parent) + 1 : 1); };
            return uiView.fqn.split('.').length * 10000 + stateDepth(uiView.creationContext);
        }
        // Return the ViewConfig's context's depth in the context tree.
        function viewConfigDepth(config) {
            var context = config.viewDecl.$context, count = 0;
            while (++count && context.parent)
                context = context.parent;
            return count;
        }
        // Given a depth function, returns a compare function which can return either ascending or descending order
        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });
        var matchingConfigPair = function (uiView) {
            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));
            if (matchingConfigs.length > 1) {
                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)
                // Sort by depth and return the match from the deepest child
                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);
                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending
            }
            return { uiView: uiView, viewConfig: matchingConfigs[0] };
        };
        var configureUIView = function (tuple) {
            // If a parent ui-view is reconfigured, it could destroy child ui-views.
            // Before configuring a child ui-view, make sure it's still in the active uiViews array.
            if (_this._uiViews.indexOf(tuple.uiView) !== -1)
                tuple.uiView.configUpdated(tuple.viewConfig);
        };
        // Sort views by FQN and state depth. Process uiviews nearest the root first.
        var uiViewTuples = this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair);
        var matchedViewConfigs = uiViewTuples.map(function (tuple) { return tuple.viewConfig; });
        var unmatchedConfigTuples = this._viewConfigs
            .filter(function (config) { return !common_1.inArray(matchedViewConfigs, config); })
            .map(function (viewConfig) { return ({ uiView: undefined, viewConfig: viewConfig }); });
        uiViewTuples.forEach(configureUIView);
        var allTuples = uiViewTuples.concat(unmatchedConfigTuples);
        this._listeners.forEach(function (cb) { return cb(allTuples); });
        trace_1.trace.traceViewSync(allTuples);
    };
    /**
     * Registers a `ui-view` component
     *
     * When a `ui-view` component is created, it uses this method to register itself.
     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].
     *
     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,
     * and what the view's state context is.
     *
     * Note: There is no corresponding `deregisterUIView`.
     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.
     *
     * @param uiView The metadata for a UIView
     * @return a de-registration function used when the view is destroyed.
     */
    ViewService.prototype.registerUIView = function (uiView) {
        trace_1.trace.traceViewServiceUIViewEvent('-> Registering', uiView);
        var uiViews = this._uiViews;
        var fqnAndTypeMatches = function (uiv) { return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type; };
        if (uiViews.filter(fqnAndTypeMatches).length)
            trace_1.trace.traceViewServiceUIViewEvent('!!!! duplicate uiView named:', uiView);
        uiViews.push(uiView);
        this.sync();
        return function () {
            var idx = uiViews.indexOf(uiView);
            if (idx === -1) {
                trace_1.trace.traceViewServiceUIViewEvent('Tried removing non-registered uiView', uiView);
                return;
            }
            trace_1.trace.traceViewServiceUIViewEvent('<- Deregistering', uiView);
            common_1.removeFrom(uiViews)(uiView);
        };
    };
    /**
     * Returns the list of views currently available on the page, by fully-qualified name.
     *
     * @return {Array} Returns an array of fully-qualified view names.
     */
    ViewService.prototype.available = function () {
        return this._uiViews.map(hof_1.prop('fqn'));
    };
    /**
     * Returns the list of views on the page containing loaded content.
     *
     * @return {Array} Returns an array of fully-qualified view names.
     */
    ViewService.prototype.active = function () {
        return this._uiViews.filter(hof_1.prop('$config')).map(hof_1.prop('name'));
    };
    /**
     * Given a ui-view and a ViewConfig, determines if they "match".
     *
     * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in
     * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.
     *
     * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or
     * can be a segmented ui-view path, describing a portion of a ui-view fqn.
     *
     * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type
     *
     * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:
     * - the ui-view's name matches the ViewConfig's target name
     * - the ui-view's context matches the ViewConfig's anchor
     *
     * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:
     * - There exists a parent ui-view where:
     *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name
     *    - the parent ui-view's context matches the ViewConfig's anchor
     * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn
     *
     * Example:
     *
     * DOM:
     * <ui-view>                        <!-- created in the root context (name: "") -->
     *   <ui-view name="foo">                <!-- created in the context named: "A"      -->
     *     <ui-view>                    <!-- created in the context named: "A.B"    -->
     *       <ui-view name="bar">            <!-- created in the context named: "A.B.C"  -->
     *       </ui-view>
     *     </ui-view>
     *   </ui-view>
     * </ui-view>
     *
     * uiViews: [
     *  { fqn: "$default",                  creationContext: { name: "" } },
     *  { fqn: "$default.foo",              creationContext: { name: "A" } },
     *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }
     *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }
     * ]
     *
     * These four view configs all match the ui-view with the fqn: "$default.foo.$default.bar":
     *
     * - ViewConfig1: { uiViewName: "bar",                       uiViewContextAnchor: "A.B.C" }
     * - ViewConfig2: { uiViewName: "$default.bar",              uiViewContextAnchor: "A.B" }
     * - ViewConfig3: { uiViewName: "foo.$default.bar",          uiViewContextAnchor: "A" }
     * - ViewConfig4: { uiViewName: "$default.foo.$default.bar", uiViewContextAnchor: "" }
     *
     * Using ViewConfig3 as an example, it matches the ui-view with fqn "$default.foo.$default.bar" because:
     * - The ViewConfig's segmented target name is: [ "foo", "$default", "bar" ]
     * - There exists a parent ui-view (which has fqn: "$default.foo") where:
     *    - the parent ui-view's name "foo" matches the first segment "foo" of the ViewConfig's target name
     *    - the parent ui-view's context "A" matches the ViewConfig's anchor context "A"
     * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig's target name match
     *   the tail of the ui-view's fqn "default.bar"
     *
     * @internalapi
     */
    ViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {
        // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc
        if (uiView.$type !== viewConfig.viewDecl.$type)
            return false;
        // Split names apart from both viewConfig and uiView into segments
        var vc = viewConfig.viewDecl;
        var vcSegments = vc.$uiViewName.split('.');
        var uivSegments = uiView.fqn.split('.');
        // Check if the tails of the segment arrays match. ex, these arrays' tails match:
        // vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]
        if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
            return false;
        // Now check if the fqn ending at the first segment of the viewConfig matches the context:
        // ["$default", "foo"].join(".") == "$default.foo", does the ui-view $default.foo context match?
        var negOffset = 1 - vcSegments.length || undefined;
        var fqnToFirstSegment = uivSegments.slice(0, negOffset).join('.');
        var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
        return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);
    }; };
    return ViewService;
}());
exports.ViewService = ViewService;
//# sourceMappingURL=view.js.map

/***/ }),

/***/ "./node_modules/angular-sanitize/angular-sanitize.js":
/*!***********************************************************!*\
  !*** ./node_modules/angular-sanitize/angular-sanitize.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @license AngularJS v1.6.10
 * (c) 2010-2018 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular) {'use strict';

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *     Any commits to this file should be reviewed with security in mind.  *
 *   Changes to this file can potentially create security vulnerabilities. *
 *          An approval from 2 Core members with history of modifying      *
 *                         this file is required.                          *
 *                                                                         *
 *  Does the change somehow allow for arbitrary javascript to be executed? *
 *    Or allows for someone to change the prototype of built-in objects?   *
 *     Or gives undesired access to variables likes document or window?    *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

var $sanitizeMinErr = angular.$$minErr('$sanitize');
var bind;
var extend;
var forEach;
var isArray;
var isDefined;
var lowercase;
var noop;
var nodeContains;
var htmlParser;
var htmlSanitizeWriter;

/**
 * @ngdoc module
 * @name ngSanitize
 * @description
 *
 * The `ngSanitize` module provides functionality to sanitize HTML.
 *
 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
 */

/**
 * @ngdoc service
 * @name $sanitize
 * @kind function
 *
 * @description
 *   Sanitizes an html string by stripping all potentially dangerous tokens.
 *
 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
 *   then serialized back to properly escaped html string. This means that no unsafe input can make
 *   it into the returned string.
 *
 *   The whitelist for URL sanitization of attribute values is configured using the functions
 *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider
 *   `$compileProvider`}.
 *
 *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.
 *
 * @param {string} html HTML input.
 * @returns {string} Sanitized HTML.
 *
 * @example
   <example module="sanitizeExample" deps="angular-sanitize.js" name="sanitize-service">
   <file name="index.html">
     <script>
         angular.module('sanitizeExample', ['ngSanitize'])
           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
             $scope.snippet =
               '<p style="color:blue">an html\n' +
               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
               'snippet</p>';
             $scope.deliberatelyTrustDangerousSnippet = function() {
               return $sce.trustAsHtml($scope.snippet);
             };
           }]);
     </script>
     <div ng-controller="ExampleController">
        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Directive</td>
           <td>How</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="bind-html-with-sanitize">
           <td>ng-bind-html</td>
           <td>Automatically uses $sanitize</td>
           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind-html="snippet"></div></td>
         </tr>
         <tr id="bind-html-with-trust">
           <td>ng-bind-html</td>
           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
           <td>
           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
&lt;/div&gt;</pre>
           </td>
           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
         </tr>
         <tr id="bind-default">
           <td>ng-bind</td>
           <td>Automatically escapes</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
       </div>
   </file>
   <file name="protractor.js" type="protractor">
     it('should sanitize the html snippet by default', function() {
       expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).
         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
     });

     it('should inline raw snippet if bound to a trusted value', function() {
       expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).
         toBe("<p style=\"color:blue\">an html\n" +
              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
              "snippet</p>");
     });

     it('should escape snippet without any filter', function() {
       expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).
         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
              "snippet&lt;/p&gt;");
     });

     it('should update', function() {
       element(by.model('snippet')).clear();
       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).
         toBe('new <b>text</b>');
       expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).toBe(
         'new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).toBe(
         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
     });
   </file>
   </example>
 */


/**
 * @ngdoc provider
 * @name $sanitizeProvider
 * @this
 *
 * @description
 * Creates and configures {@link $sanitize} instance.
 */
function $SanitizeProvider() {
  var hasBeenInstantiated = false;
  var svgEnabled = false;

  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
    hasBeenInstantiated = true;
    if (svgEnabled) {
      extend(validElements, svgElements);
    }
    return function(html) {
      var buf = [];
      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
        return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
      }));
      return buf.join('');
    };
  }];


  /**
   * @ngdoc method
   * @name $sanitizeProvider#enableSvg
   * @kind function
   *
   * @description
   * Enables a subset of svg to be supported by the sanitizer.
   *
   * <div class="alert alert-warning">
   *   <p>By enabling this setting without taking other precautions, you might expose your
   *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned
   *   outside of the containing element and be rendered over other elements on the page (e.g. a login
   *   link). Such behavior can then result in phishing incidents.</p>
   *
   *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg
   *   tags within the sanitized content:</p>
   *
   *   <br>
   *
   *   <pre><code>
   *   .rootOfTheIncludedContent svg {
   *     overflow: hidden !important;
   *   }
   *   </code></pre>
   * </div>
   *
   * @param {boolean=} flag Enable or disable SVG support in the sanitizer.
   * @returns {boolean|$sanitizeProvider} Returns the currently configured value if called
   *    without an argument or self for chaining otherwise.
   */
  this.enableSvg = function(enableSvg) {
    if (isDefined(enableSvg)) {
      svgEnabled = enableSvg;
      return this;
    } else {
      return svgEnabled;
    }
  };


  /**
   * @ngdoc method
   * @name $sanitizeProvider#addValidElements
   * @kind function
   *
   * @description
   * Extends the built-in lists of valid HTML/SVG elements, i.e. elements that are considered safe
   * and are not stripped off during sanitization. You can extend the following lists of elements:
   *
   * - `htmlElements`: A list of elements (tag names) to extend the current list of safe HTML
   *   elements. HTML elements considered safe will not be removed during sanitization. All other
   *   elements will be stripped off.
   *
   * - `htmlVoidElements`: This is similar to `htmlElements`, but marks the elements as
   *   "void elements" (similar to HTML
   *   [void elements](https://rawgit.com/w3c/html/html5.1-2/single-page.html#void-elements)). These
   *   elements have no end tag and cannot have content.
   *
   * - `svgElements`: This is similar to `htmlElements`, but for SVG elements. This list is only
   *   taken into account if SVG is {@link ngSanitize.$sanitizeProvider#enableSvg enabled} for
   *   `$sanitize`.
   *
   * <div class="alert alert-info">
   *   This method must be called during the {@link angular.Module#config config} phase. Once the
   *   `$sanitize` service has been instantiated, this method has no effect.
   * </div>
   *
   * <div class="alert alert-warning">
   *   Keep in mind that extending the built-in lists of elements may expose your app to XSS or
   *   other vulnerabilities. Be very mindful of the elements you add.
   * </div>
   *
   * @param {Array<String>|Object} elements - A list of valid HTML elements or an object with one or
   *   more of the following properties:
   *   - **htmlElements** - `{Array<String>}` - A list of elements to extend the current list of
   *     HTML elements.
   *   - **htmlVoidElements** - `{Array<String>}` - A list of elements to extend the current list of
   *     void HTML elements; i.e. elements that do not have an end tag.
   *   - **svgElements** - `{Array<String>}` - A list of elements to extend the current list of SVG
   *     elements. The list of SVG elements is only taken into account if SVG is
   *     {@link ngSanitize.$sanitizeProvider#enableSvg enabled} for `$sanitize`.
   *
   * Passing an array (`[...]`) is equivalent to passing `{htmlElements: [...]}`.
   *
   * @return {$sanitizeProvider} Returns self for chaining.
   */
  this.addValidElements = function(elements) {
    if (!hasBeenInstantiated) {
      if (isArray(elements)) {
        elements = {htmlElements: elements};
      }

      addElementsTo(svgElements, elements.svgElements);
      addElementsTo(voidElements, elements.htmlVoidElements);
      addElementsTo(validElements, elements.htmlVoidElements);
      addElementsTo(validElements, elements.htmlElements);
    }

    return this;
  };


  /**
   * @ngdoc method
   * @name $sanitizeProvider#addValidAttrs
   * @kind function
   *
   * @description
   * Extends the built-in list of valid attributes, i.e. attributes that are considered safe and are
   * not stripped off during sanitization.
   *
   * **Note**:
   * The new attributes will not be treated as URI attributes, which means their values will not be
   * sanitized as URIs using `$compileProvider`'s
   * {@link ng.$compileProvider#aHrefSanitizationWhitelist aHrefSanitizationWhitelist} and
   * {@link ng.$compileProvider#imgSrcSanitizationWhitelist imgSrcSanitizationWhitelist}.
   *
   * <div class="alert alert-info">
   *   This method must be called during the {@link angular.Module#config config} phase. Once the
   *   `$sanitize` service has been instantiated, this method has no effect.
   * </div>
   *
   * <div class="alert alert-warning">
   *   Keep in mind that extending the built-in list of attributes may expose your app to XSS or
   *   other vulnerabilities. Be very mindful of the attributes you add.
   * </div>
   *
   * @param {Array<String>} attrs - A list of valid attributes.
   *
   * @returns {$sanitizeProvider} Returns self for chaining.
   */
  this.addValidAttrs = function(attrs) {
    if (!hasBeenInstantiated) {
      extend(validAttrs, arrayToMap(attrs, true));
    }
    return this;
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////
  // Private stuff
  //////////////////////////////////////////////////////////////////////////////////////////////////

  bind = angular.bind;
  extend = angular.extend;
  forEach = angular.forEach;
  isArray = angular.isArray;
  isDefined = angular.isDefined;
  lowercase = angular.lowercase;
  noop = angular.noop;

  htmlParser = htmlParserImpl;
  htmlSanitizeWriter = htmlSanitizeWriterImpl;

  nodeContains = window.Node.prototype.contains || /** @this */ function(arg) {
    // eslint-disable-next-line no-bitwise
    return !!(this.compareDocumentPosition(arg) & 16);
  };

  // Regular Expressions for parsing tags and attributes
  var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
    // Match everything outside of normal chars and " (quote character)
    NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g;


  // Good source of info about elements and attributes
  // http://dev.w3.org/html5/spec/Overview.html#semantics
  // http://simon.html5.org/html-elements

  // Safe Void Elements - HTML5
  // http://dev.w3.org/html5/spec/Overview.html#void-elements
  var voidElements = stringToMap('area,br,col,hr,img,wbr');

  // Elements that you can, intentionally, leave open (and which close themselves)
  // http://dev.w3.org/html5/spec/Overview.html#optional-tags
  var optionalEndTagBlockElements = stringToMap('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'),
      optionalEndTagInlineElements = stringToMap('rp,rt'),
      optionalEndTagElements = extend({},
                                              optionalEndTagInlineElements,
                                              optionalEndTagBlockElements);

  // Safe Block Elements - HTML5
  var blockElements = extend({}, optionalEndTagBlockElements, stringToMap('address,article,' +
          'aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
          'h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul'));

  // Inline Elements - HTML5
  var inlineElements = extend({}, optionalEndTagInlineElements, stringToMap('a,abbr,acronym,b,' +
          'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,' +
          'samp,small,span,strike,strong,sub,sup,time,tt,u,var'));

  // SVG Elements
  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
  // Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
  // They can potentially allow for arbitrary javascript to be executed. See #11290
  var svgElements = stringToMap('circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,' +
          'hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,' +
          'radialGradient,rect,stop,svg,switch,text,title,tspan');

  // Blocked Elements (will be stripped)
  var blockedElements = stringToMap('script,style');

  var validElements = extend({},
                                     voidElements,
                                     blockElements,
                                     inlineElements,
                                     optionalEndTagElements);

  //Attributes that have href and hence need to be sanitized
  var uriAttrs = stringToMap('background,cite,href,longdesc,src,xlink:href,xml:base');

  var htmlAttrs = stringToMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
      'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
      'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
      'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
      'valign,value,vspace,width');

  // SVG attributes (without "id" and "name" attributes)
  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
  var svgAttrs = stringToMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
      'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
      'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
      'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
      'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
      'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
      'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
      'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
      'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
      'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
      'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
      'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
      'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
      'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
      'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);

  var validAttrs = extend({},
                                  uriAttrs,
                                  svgAttrs,
                                  htmlAttrs);

  function stringToMap(str, lowercaseKeys) {
    return arrayToMap(str.split(','), lowercaseKeys);
  }

  function arrayToMap(items, lowercaseKeys) {
    var obj = {}, i;
    for (i = 0; i < items.length; i++) {
      obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;
    }
    return obj;
  }

  function addElementsTo(elementsMap, newElements) {
    if (newElements && newElements.length) {
      extend(elementsMap, arrayToMap(newElements));
    }
  }

  /**
   * Create an inert document that contains the dirty HTML that needs sanitizing
   * Depending upon browser support we use one of three strategies for doing this.
   * Support: Safari 10.x -> XHR strategy
   * Support: Firefox -> DomParser strategy
   */
  var getInertBodyElement /* function(html: string): HTMLBodyElement */ = (function(window, document) {
    var inertDocument;
    if (document && document.implementation) {
      inertDocument = document.implementation.createHTMLDocument('inert');
    } else {
      throw $sanitizeMinErr('noinert', 'Can\'t create an inert html document');
    }
    var inertBodyElement = (inertDocument.documentElement || inertDocument.getDocumentElement()).querySelector('body');

    // Check for the Safari 10.1 bug - which allows JS to run inside the SVG G element
    inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>';
    if (!inertBodyElement.querySelector('svg')) {
      return getInertBodyElement_XHR;
    } else {
      // Check for the Firefox bug - which prevents the inner img JS from being sanitized
      inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">';
      if (inertBodyElement.querySelector('svg img')) {
        return getInertBodyElement_DOMParser;
      } else {
        return getInertBodyElement_InertDocument;
      }
    }

    function getInertBodyElement_XHR(html) {
      // We add this dummy element to ensure that the rest of the content is parsed as expected
      // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the `<head>` tag.
      html = '<remove></remove>' + html;
      try {
        html = encodeURI(html);
      } catch (e) {
        return undefined;
      }
      var xhr = new window.XMLHttpRequest();
      xhr.responseType = 'document';
      xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);
      xhr.send(null);
      var body = xhr.response.body;
      body.firstChild.remove();
      return body;
    }

    function getInertBodyElement_DOMParser(html) {
      // We add this dummy element to ensure that the rest of the content is parsed as expected
      // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the `<head>` tag.
      html = '<remove></remove>' + html;
      try {
        var body = new window.DOMParser().parseFromString(html, 'text/html').body;
        body.firstChild.remove();
        return body;
      } catch (e) {
        return undefined;
      }
    }

    function getInertBodyElement_InertDocument(html) {
      inertBodyElement.innerHTML = html;

      // Support: IE 9-11 only
      // strip custom-namespaced attributes on IE<=11
      if (document.documentMode) {
        stripCustomNsAttrs(inertBodyElement);
      }

      return inertBodyElement;
    }
  })(window, window.document);

  /**
   * @example
   * htmlParser(htmlString, {
   *     start: function(tag, attrs) {},
   *     end: function(tag) {},
   *     chars: function(text) {},
   *     comment: function(text) {}
   * });
   *
   * @param {string} html string
   * @param {object} handler
   */
  function htmlParserImpl(html, handler) {
    if (html === null || html === undefined) {
      html = '';
    } else if (typeof html !== 'string') {
      html = '' + html;
    }

    var inertBodyElement = getInertBodyElement(html);
    if (!inertBodyElement) return '';

    //mXSS protection
    var mXSSAttempts = 5;
    do {
      if (mXSSAttempts === 0) {
        throw $sanitizeMinErr('uinput', 'Failed to sanitize html because the input is unstable');
      }
      mXSSAttempts--;

      // trigger mXSS if it is going to happen by reading and writing the innerHTML
      html = inertBodyElement.innerHTML;
      inertBodyElement = getInertBodyElement(html);
    } while (html !== inertBodyElement.innerHTML);

    var node = inertBodyElement.firstChild;
    while (node) {
      switch (node.nodeType) {
        case 1: // ELEMENT_NODE
          handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
          break;
        case 3: // TEXT NODE
          handler.chars(node.textContent);
          break;
      }

      var nextNode;
      if (!(nextNode = node.firstChild)) {
        if (node.nodeType === 1) {
          handler.end(node.nodeName.toLowerCase());
        }
        nextNode = getNonDescendant('nextSibling', node);
        if (!nextNode) {
          while (nextNode == null) {
            node = getNonDescendant('parentNode', node);
            if (node === inertBodyElement) break;
            nextNode = getNonDescendant('nextSibling', node);
            if (node.nodeType === 1) {
              handler.end(node.nodeName.toLowerCase());
            }
          }
        }
      }
      node = nextNode;
    }

    while ((node = inertBodyElement.firstChild)) {
      inertBodyElement.removeChild(node);
    }
  }

  function attrToMap(attrs) {
    var map = {};
    for (var i = 0, ii = attrs.length; i < ii; i++) {
      var attr = attrs[i];
      map[attr.name] = attr.value;
    }
    return map;
  }


  /**
   * Escapes all potentially dangerous characters, so that the
   * resulting string can be safely inserted into attribute or
   * element text.
   * @param value
   * @returns {string} escaped text
   */
  function encodeEntities(value) {
    return value.
      replace(/&/g, '&amp;').
      replace(SURROGATE_PAIR_REGEXP, function(value) {
        var hi = value.charCodeAt(0);
        var low = value.charCodeAt(1);
        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
      }).
      replace(NON_ALPHANUMERIC_REGEXP, function(value) {
        return '&#' + value.charCodeAt(0) + ';';
      }).
      replace(/</g, '&lt;').
      replace(/>/g, '&gt;');
  }

  /**
   * create an HTML/XML writer which writes to buffer
   * @param {Array} buf use buf.join('') to get out sanitized html string
   * @returns {object} in the form of {
   *     start: function(tag, attrs) {},
   *     end: function(tag) {},
   *     chars: function(text) {},
   *     comment: function(text) {}
   * }
   */
  function htmlSanitizeWriterImpl(buf, uriValidator) {
    var ignoreCurrentElement = false;
    var out = bind(buf, buf.push);
    return {
      start: function(tag, attrs) {
        tag = lowercase(tag);
        if (!ignoreCurrentElement && blockedElements[tag]) {
          ignoreCurrentElement = tag;
        }
        if (!ignoreCurrentElement && validElements[tag] === true) {
          out('<');
          out(tag);
          forEach(attrs, function(value, key) {
            var lkey = lowercase(key);
            var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
            if (validAttrs[lkey] === true &&
              (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
              out(' ');
              out(key);
              out('="');
              out(encodeEntities(value));
              out('"');
            }
          });
          out('>');
        }
      },
      end: function(tag) {
        tag = lowercase(tag);
        if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
          out('</');
          out(tag);
          out('>');
        }
        // eslint-disable-next-line eqeqeq
        if (tag == ignoreCurrentElement) {
          ignoreCurrentElement = false;
        }
      },
      chars: function(chars) {
        if (!ignoreCurrentElement) {
          out(encodeEntities(chars));
        }
      }
    };
  }


  /**
   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare
   * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want
   * to allow any of these custom attributes. This method strips them all.
   *
   * @param node Root element to process
   */
  function stripCustomNsAttrs(node) {
    while (node) {
      if (node.nodeType === window.Node.ELEMENT_NODE) {
        var attrs = node.attributes;
        for (var i = 0, l = attrs.length; i < l; i++) {
          var attrNode = attrs[i];
          var attrName = attrNode.name.toLowerCase();
          if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {
            node.removeAttributeNode(attrNode);
            i--;
            l--;
          }
        }
      }

      var nextNode = node.firstChild;
      if (nextNode) {
        stripCustomNsAttrs(nextNode);
      }

      node = getNonDescendant('nextSibling', node);
    }
  }

  function getNonDescendant(propName, node) {
    // An element is clobbered if its `propName` property points to one of its descendants
    var nextNode = node[propName];
    if (nextNode && nodeContains.call(node, nextNode)) {
      throw $sanitizeMinErr('elclob', 'Failed to sanitize html because the element is clobbered: {0}', node.outerHTML || node.outerText);
    }
    return nextNode;
  }
}

function sanitizeText(chars) {
  var buf = [];
  var writer = htmlSanitizeWriter(buf, noop);
  writer.chars(chars);
  return buf.join('');
}


// define ngSanitize module and register $sanitize service
angular.module('ngSanitize', [])
  .provider('$sanitize', $SanitizeProvider)
  .info({ angularVersion: '1.6.10' });

/**
 * @ngdoc filter
 * @name linky
 * @kind function
 *
 * @description
 * Finds links in text input and turns them into html links. Supports `http/https/ftp/sftp/mailto` and
 * plain email address links.
 *
 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
 *
 * @param {string} text Input text.
 * @param {string} [target] Window (`_blank|_self|_parent|_top`) or named frame to open links in.
 * @param {object|function(url)} [attributes] Add custom attributes to the link element.
 *
 *    Can be one of:
 *
 *    - `object`: A map of attributes
 *    - `function`: Takes the url as a parameter and returns a map of attributes
 *
 *    If the map of attributes contains a value for `target`, it overrides the value of
 *    the target parameter.
 *
 *
 * @returns {string} Html-linkified and {@link $sanitize sanitized} text.
 *
 * @usage
   <span ng-bind-html="linky_expression | linky"></span>
 *
 * @example
   <example module="linkyExample" deps="angular-sanitize.js" name="linky-filter">
     <file name="index.html">
       <div ng-controller="ExampleController">
       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <th>Filter</th>
           <th>Source</th>
           <th>Rendered</th>
         </tr>
         <tr id="linky-filter">
           <td>linky filter</td>
           <td>
             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
           </td>
           <td>
             <div ng-bind-html="snippet | linky"></div>
           </td>
         </tr>
         <tr id="linky-target">
          <td>linky target</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithSingleURL | linky:'_blank'"></div>
          </td>
         </tr>
         <tr id="linky-custom-attributes">
          <td>linky custom attributes</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"></div>
          </td>
         </tr>
         <tr id="escaped-html">
           <td>no filter</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
     </file>
     <file name="script.js">
       angular.module('linkyExample', ['ngSanitize'])
         .controller('ExampleController', ['$scope', function($scope) {
           $scope.snippet =
             'Pretty text with some links:\n' +
             'http://angularjs.org/,\n' +
             'mailto:us@somewhere.org,\n' +
             'another@somewhere.org,\n' +
             'and one more: ftp://127.0.0.1/.';
           $scope.snippetWithSingleURL = 'http://angularjs.org/';
         }]);
     </file>
     <file name="protractor.js" type="protractor">
       it('should linkify the snippet with urls', function() {
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
       });

       it('should not linkify snippet without the linky filter', function() {
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
       });

       it('should update', function() {
         element(by.model('snippet')).clear();
         element(by.model('snippet')).sendKeys('new http://link.');
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('new http://link.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
             .toBe('new http://link.');
       });

       it('should work with the target property', function() {
        expect(element(by.id('linky-target')).
            element(by.binding("snippetWithSingleURL | linky:'_blank'")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
       });

       it('should optionally add custom attributes', function() {
        expect(element(by.id('linky-custom-attributes')).
            element(by.binding("snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');
       });
     </file>
   </example>
 */
angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
  var LINKY_URL_REGEXP =
        /((s?ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
      MAILTO_REGEXP = /^mailto:/i;

  var linkyMinErr = angular.$$minErr('linky');
  var isDefined = angular.isDefined;
  var isFunction = angular.isFunction;
  var isObject = angular.isObject;
  var isString = angular.isString;

  return function(text, target, attributes) {
    if (text == null || text === '') return text;
    if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);

    var attributesFn =
      isFunction(attributes) ? attributes :
      isObject(attributes) ? function getAttributesObject() {return attributes;} :
      function getEmptyAttributesObject() {return {};};

    var match;
    var raw = text;
    var html = [];
    var url;
    var i;
    while ((match = raw.match(LINKY_URL_REGEXP))) {
      // We can not end in these as they are sometimes found at the end of the sentence
      url = match[0];
      // if we did not match ftp/http/www/mailto then assume mailto
      if (!match[2] && !match[4]) {
        url = (match[3] ? 'http://' : 'mailto:') + url;
      }
      i = match.index;
      addText(raw.substr(0, i));
      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
      raw = raw.substring(i + match[0].length);
    }
    addText(raw);
    return $sanitize(html.join(''));

    function addText(text) {
      if (!text) {
        return;
      }
      html.push(sanitizeText(text));
    }

    function addLink(url, text) {
      var key, linkAttributes = attributesFn(url);
      html.push('<a ');

      for (key in linkAttributes) {
        html.push(key + '="' + linkAttributes[key] + '" ');
      }

      if (isDefined(target) && !('target' in linkAttributes)) {
        html.push('target="',
                  target,
                  '" ');
      }
      html.push('href="',
                url.replace(/"/g, '&quot;'),
                '">');
      addText(text);
      html.push('</a>');
    }
  };
}]);


})(window, window.angular);


/***/ }),

/***/ "./node_modules/angular-sanitize/index.js":
/*!************************************************!*\
  !*** ./node_modules/angular-sanitize/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./angular-sanitize */ "./node_modules/angular-sanitize/angular-sanitize.js");
module.exports = 'ngSanitize';


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/app/spok-weather/app.spok-weather.main.js":
/*!*******************************************************!*\
  !*** ./src/app/spok-weather/app.spok-weather.main.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// styles
__webpack_require__(/*! ./app.spok-weather.style.scss */ "./src/app/spok-weather/app.spok-weather.style.scss");

// main
var angular = __webpack_require__(/*! angular */ "angular");
var uirouter = __webpack_require__(/*! @uirouter/angularjs */ "./node_modules/@uirouter/angularjs/release/ui-router-angularjs.js").default;
var ngSanitize = __webpack_require__(/*! angular-sanitize */ "./node_modules/angular-sanitize/index.js");

routingConfig.$inject = ['$stateProvider', '$locationProvider', '$urlRouterProvider'];
function routingConfig($stateProvider, $locationProvider, $urlRouterProvider) {

    // Remove # from url
    $locationProvider.html5Mode(true);

    // Redirects
    $urlRouterProvider.when('/', '/spok/weather');

    var states = [
        {
            name: 'app',
            url: '/spok',
            abstract: true
        },
        {
            name: 'app.weather',
            url: '/weather',
            component: 'appWeatherSearch',
            params: {
                search: ''
            },
            resolve: {}
        },
        {
            name: 'app.weather.forecast',
            url: '/{search}/forecast',
            component: 'appWeatherForecast',
            resolve: {
                forecastResults: ['$stateParams','appWeatherService', function($stateParams, appWeatherService) {
                    return appWeatherService.search($stateParams.search);
                }]
            }
        }
    ];
    states.forEach(function (state) {
        $stateProvider.state(state)
    })
}

var dependencies = [uirouter, 'ngSanitize'];
var weatherApp = angular
    .module('spok-weather', dependencies)
    .config(routingConfig)
    .service("appWeatherService", __webpack_require__(/*! ./services/weather-search.service */ "./src/app/spok-weather/services/weather-search.service.js"))
    .component("appWeatherSearch", __webpack_require__(/*! ./weather-search/weather-search.component */ "./src/app/spok-weather/weather-search/weather-search.component.js"))
    .component("appWeatherForecast", __webpack_require__(/*! ./weather-forecast/weather-forecast.component */ "./src/app/spok-weather/weather-forecast/weather-forecast.component.js"))

module.exports = weatherApp.name

/***/ }),

/***/ "./src/app/spok-weather/app.spok-weather.style.scss":
/*!**********************************************************!*\
  !*** ./src/app/spok-weather/app.spok-weather.style.scss ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./src/app/spok-weather/services/weather-search.service.js":
/*!*****************************************************************!*\
  !*** ./src/app/spok-weather/services/weather-search.service.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

service.$inject = ['$http'];

function service($http) {
    var api = 'https://query.yahooapis.com/v1/public/yql?q={yql}&format=json&env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys'
    
    function search(location) {
        var yql = `select%20*%20from%20weather.forecast%20where%20woeid%20in%20(select%20woeid%20from%20geo.places(1)%20where%20text%3D%22${location}%22)`
        var url = api.replace('{yql}', yql);
        return $http.get(url)
            .then((response) => {
                return response.data.query.results.channel.item;
            });
    }

    return {
        search: search
    }
}

module.exports = service;

/***/ }),

/***/ "./src/app/spok-weather/weather-forecast/weather-forecast.component.js":
/*!*****************************************************************************!*\
  !*** ./src/app/spok-weather/weather-forecast/weather-forecast.component.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var template = __webpack_require__(/*! ./weather-forecast.template.html */ "./src/app/spok-weather/weather-forecast/weather-forecast.template.html")
var controller = __webpack_require__(/*! ./weather-forecast.controller.js */ "./src/app/spok-weather/weather-forecast/weather-forecast.controller.js")

var component = {
    template: template,
    controller: controller,
    controllerAs: '$weatherForecast',
    bindings: {
        forecastResults: '<'
    }
}

module.exports = component;

/***/ }),

/***/ "./src/app/spok-weather/weather-forecast/weather-forecast.controller.js":
/*!******************************************************************************!*\
  !*** ./src/app/spok-weather/weather-forecast/weather-forecast.controller.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

controller.$inject = [];

function controller() {
    $weatherForecast = this;
    
    $weatherForecast.$onInit = () => {
        $weatherForecast.forecast = $weatherForecast.forecastResults.description
            .replace(/(?:<!\[CDATA\[)|(?:\]\]>)/g, "");
    }
}

module.exports = controller;

/***/ }),

/***/ "./src/app/spok-weather/weather-forecast/weather-forecast.template.html":
/*!******************************************************************************!*\
  !*** ./src/app/spok-weather/weather-forecast/weather-forecast.template.html ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\r\n<div class=\"weather-forecast\">\r\n  <div ng-bind-html=\"$weatherForecast.forecast\"></div>\r\n</div>"

/***/ }),

/***/ "./src/app/spok-weather/weather-search/weather-search.component.js":
/*!*************************************************************************!*\
  !*** ./src/app/spok-weather/weather-search/weather-search.component.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var template = __webpack_require__(/*! ./weather-search.template.html */ "./src/app/spok-weather/weather-search/weather-search.template.html")
var controller = __webpack_require__(/*! ./weather-search.controller.js */ "./src/app/spok-weather/weather-search/weather-search.controller.js")

var component = {
    template: template,
    controller: controller,
    controllerAs: '$weatherSearch',
    bindings: {
    }
}

module.exports = component;

/***/ }),

/***/ "./src/app/spok-weather/weather-search/weather-search.controller.js":
/*!**************************************************************************!*\
  !*** ./src/app/spok-weather/weather-search/weather-search.controller.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

controller.$inject = ['$state', '$stateParams'];

function controller($state, $stateParams) {
    var $weatherSearch = this;

    $weatherSearch.search = function() {
        $state.go('app.weather.forecast', {search: $weatherSearch.searchText});
    }

    $weatherSearch.$onInit = function() {
        // init stuff
        $weatherSearch.searchText = $stateParams.search;
    }
}

module.exports = controller;

/***/ }),

/***/ "./src/app/spok-weather/weather-search/weather-search.template.html":
/*!**************************************************************************!*\
  !*** ./src/app/spok-weather/weather-search/weather-search.template.html ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\r\n<div class=\"jumbotron weather-search\">\r\n        <h1 class=\"display-4\">Forecast Search</h1>\r\n        <p class=\"lead\">Search Spok for your local forecast!</p>\r\n        <hr class=\"my-4\">\r\n        <p>Type in your city and state in the box below</p>\r\n        <p class=\"lead\">\r\n                <div class=\"input-group mb-3\">\r\n                    <div class=\"input-group-prepend\">\r\n                        <button class=\"btn btn-outline-primary\" type=\"button\"\r\n                        ng-click=\"$weatherSearch.search()\"\r\n                        ng-disabled=\"$weatherSearch.searchText == ''\">Search</button>\r\n                    </div>\r\n                    <input type=\"text\" ng-model=\"$weatherSearch.searchText\" class=\"form-control\" id=\"weatherSearch\" placeholder=\"Minneapolis, MN\">\r\n                </div>\r\n        </p>\r\n        \r\n        <ui-view></ui-view>\r\n</div>"

/***/ }),

/***/ "angular":
/*!**************************!*\
  !*** external "angular" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = angular;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9hbmd1bGFyanMvcmVsZWFzZS91aS1yb3V0ZXItYW5ndWxhcmpzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb3Jlc2VydmljZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vZ2xvYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9ob2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vcHJlZGljYXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9xdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9zdHJpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3RyYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2NvcmVSZXNvbHZhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2lnbm9yZWRUcmFuc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvaW52YWxpZFRyYW5zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9sYXp5TG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL29uRW50ZXJFeGl0UmV0YWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvcmVkaXJlY3RUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3Jlc29sdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy91cGRhdGVHbG9iYWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvdXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3Mvdmlld3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbVR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW1UeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9zdGF0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL3BhdGhOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGF0aC9wYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL3Jlc29sdmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZUJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZU1hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUXVldWVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVSZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3RhcmdldFN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9ob29rQnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaG9va1JlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaW50ZXJmYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9yZWplY3RGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uRXZlbnRUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsTWF0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxNYXRjaGVyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUnVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxTZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYmFzZUxvY2F0aW9uU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYnJvd3NlckxvY2F0aW9uQ29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9oYXNoTG9jYXRpb25TZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaW5qZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL21lbW9yeUxvY2F0aW9uQ29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9tZW1vcnlMb2NhdGlvblNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3BsdWdpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3B1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92aWV3L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmlldy92aWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbmd1bGFyLXNhbml0aXplL2FuZ3VsYXItc2FuaXRpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItc2FuaXRpemUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3Nwb2std2VhdGhlci9hcHAuc3Bvay13ZWF0aGVyLm1haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9zcG9rLXdlYXRoZXIvYXBwLnNwb2std2VhdGhlci5zdHlsZS5zY3NzIiwid2VicGFjazovLy8uL3NyYy9hcHAvc3Bvay13ZWF0aGVyL3NlcnZpY2VzL3dlYXRoZXItc2VhcmNoLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9zcG9rLXdlYXRoZXIvd2VhdGhlci1mb3JlY2FzdC93ZWF0aGVyLWZvcmVjYXN0LmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3Nwb2std2VhdGhlci93ZWF0aGVyLWZvcmVjYXN0L3dlYXRoZXItZm9yZWNhc3QuY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3Nwb2std2VhdGhlci93ZWF0aGVyLWZvcmVjYXN0L3dlYXRoZXItZm9yZWNhc3QudGVtcGxhdGUuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3Nwb2std2VhdGhlci93ZWF0aGVyLXNlYXJjaC93ZWF0aGVyLXNlYXJjaC5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9zcG9rLXdlYXRoZXIvd2VhdGhlci1zZWFyY2gvd2VhdGhlci1zZWFyY2guY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3Nwb2std2VhdGhlci93ZWF0aGVyLXNlYXJjaC93ZWF0aGVyLXNlYXJjaC50ZW1wbGF0ZS5odG1sIiwid2VicGFjazovLy9leHRlcm5hbCBcImFuZ3VsYXJcIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQ2dEO0FBQ2hELENBQUMsZ0RBQWdEOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlDQUF5Qyx3Q0FBd0MsRUFBRSxTQUFTO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtQ0FBbUMsRUFBRTtBQUMvRjtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQSxtQ0FBbUMsTUFBTSxjQUFjO0FBQ3ZEO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsMkNBQTJDLEVBQUUsSUFBSTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZLGtCQUFrQixLQUFLO0FBQ3hGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkRBQTJELFVBQVUsZ0JBQWdCLEVBQUUsRUFBRSxFQUFFO0FBQzNJLGlEQUFpRCwyREFBMkQsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1Q0FBdUMsc0JBQXNCLEVBQUU7QUFDOUY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQSw2QkFBNkIsT0FBTztBQUNwQyx5RUFBeUU7QUFDekUsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEYsZ0NBQWdDLDhCQUE4QjtBQUM5RDtBQUNBLDJDQUEyQyw0Q0FBNEM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDZFQUE2RSxnQkFBZ0I7QUFDN0Y7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxpQ0FBaUMsMERBQTBELEVBQUU7QUFDN0Y7QUFDQSxzQ0FBc0Msd0RBQXdELEVBQUU7QUFDaEcsZ0JBQWdCO0FBQ2hCLG1DQUFtQyxVQUFVLG1EQUFtRCxFQUFFLEVBQUU7QUFDcEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0EsdUJBQXVCLE9BQU8sZUFBZTtBQUM3QztBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0JBQStCO0FBQy9ELGdDQUFnQztBQUNoQztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsc0NBQXNDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFVBQVUsd0JBQXdCLEtBQUssRUFBRTtBQUMxSDtBQUNBO0FBQ0EsbUZBQW1GLFVBQVUsd0JBQXdCLEtBQUssRUFBRTtBQUM1SDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1REFBdUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLG1EQUFtRCxnQkFBZ0IsRUFBRSxFQUFFLEVBQUU7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVEQUF1RCxxREFBcUQsRUFBRTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1RUFBdUU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxRUFBcUUsRUFBRTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0MsRUFBRTtBQUNqRTtBQUNBLGtDQUFrQyw4QkFBOEIsRUFBRTtBQUNsRSw0Q0FBNEMseUZBQXlGLEVBQUU7QUFDdkk7QUFDQTtBQUNBLG9EQUFvRCx1RUFBdUU7QUFDM0g7QUFDQTtBQUNBLHdDQUF3QywyQ0FBMkMsb0JBQW9CLDRCQUE0QixFQUFFLEVBQUUsRUFBRTtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpQ0FBaUMsRUFBRTtBQUNsSCx1REFBdUQsOEJBQThCLEVBQUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsaUNBQWlDLEVBQUU7QUFDN0csMkNBQTJDLDJCQUEyQixFQUFFO0FBQ3hFLDRDQUE0QyxtQkFBbUIsRUFBRTtBQUNqRTtBQUNBLHVFQUF1RSxFQUFFO0FBQ3pFLGdEQUFnRCxFQUFFO0FBQ2xELHNEQUFzRCxFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEdBQUcsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0JBQXNCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQixLQUFLLG9CQUFvQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNkJBQTZCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCLEtBQUssZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxpQkFBaUI7QUFDakY7QUFDQTtBQUNBLGdFQUFnRSxpQkFBaUI7QUFDakY7QUFDQTtBQUNBLGdFQUFnRSxpQkFBaUI7QUFDakY7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGFBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsOENBQThDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSx5QkFBeUI7QUFDekIsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxvQkFBb0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsNkJBQTZCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDhDQUE4QztBQUM1RjtBQUNBLGdGQUFnRix1Q0FBdUMsRUFBRSxJQUFJO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQixLQUFLLGlCQUFpQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw4Q0FBOEM7QUFDN0c7QUFDQTtBQUNBLHVEQUF1RCxzQkFBc0IsRUFBRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsZ0RBQWdELEVBQUU7QUFDeEksa0ZBQWtGLDBDQUEwQyxFQUFFO0FBQzlIO0FBQ0E7QUFDQSxrRkFBa0YsdUNBQXVDLEVBQUU7QUFDM0g7QUFDQSx5RUFBeUUscUNBQXFDLEVBQUU7QUFDaEgsNEVBQTRFLHdDQUF3QyxFQUFFO0FBQ3RILDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0NBQWdDO0FBQ3hFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWMsRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHVDQUF1QyxFQUFFO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpRkFBaUY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2FwcC9zcG9rLXdlYXRoZXIvYXBwLnNwb2std2VhdGhlci5tYWluLmpzXCIpO1xuIiwiLyoqXG4gKiBTdGF0ZS1iYXNlZCByb3V0aW5nIGZvciBBbmd1bGFySlMgMS54XG4gKiBUaGlzIGJ1bmRsZSByZXF1aXJlcyB0aGUgdWktcm91dGVyLWNvcmUuanMgYnVuZGxlIGZyb20gdGhlIEB1aXJvdXRlci9jb3JlIHBhY2thZ2UuXG4gKiBAdmVyc2lvbiB2MS4wLjE2XG4gKiBAbGluayBodHRwczovL3VpLXJvdXRlci5naXRodWIuaW9cbiAqIEBsaWNlbnNlIE1JVCBMaWNlbnNlLCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnYW5ndWxhcicpLCByZXF1aXJlKCdAdWlyb3V0ZXIvY29yZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdhbmd1bGFyJywgJ0B1aXJvdXRlci9jb3JlJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsWydAdWlyb3V0ZXIvYW5ndWxhcmpzJ10gPSB7fSksZ2xvYmFsLmFuZ3VsYXIsZ2xvYmFsWydAdWlyb3V0ZXIvY29yZSddKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxuZ19mcm9tX2ltcG9ydCxjb3JlKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuZ19mcm9tX2dsb2JhbCA9IGFuZ3VsYXI7XG4gICAgdmFyIG5nID0gbmdfZnJvbV9pbXBvcnQgJiYgbmdfZnJvbV9pbXBvcnQubW9kdWxlID8gbmdfZnJvbV9pbXBvcnQgOiBuZ19mcm9tX2dsb2JhbDtcblxuICAgIGZ1bmN0aW9uIGdldE5nMVZpZXdDb25maWdGYWN0b3J5KCkge1xuICAgICAgICB2YXIgdGVtcGxhdGVGYWN0b3J5ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoLCB2aWV3KSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUZhY3RvcnkgPSB0ZW1wbGF0ZUZhY3RvcnkgfHwgY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IuZ2V0KCckdGVtcGxhdGVGYWN0b3J5Jyk7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBOZzFWaWV3Q29uZmlnKHBhdGgsIHZpZXcsIHRlbXBsYXRlRmFjdG9yeSldO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgaGFzQW55S2V5ID0gZnVuY3Rpb24gKGtleXMsIG9iaikgeyByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7IHJldHVybiBhY2MgfHwgY29yZS5pc0RlZmluZWQob2JqW2tleV0pOyB9LCBmYWxzZSk7IH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIFtbU3RhdGVCdWlsZGVyLmJ1aWxkZXJdXSBmdW5jdGlvbiBmb3IgYW5ndWxhcjEgYHZpZXdzYC5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcbiAgICAgKiBoYW5kbGVzIHRoZSBgdmlld3NgIHByb3BlcnR5IHdpdGggbG9naWMgc3BlY2lmaWMgdG8gQHVpcm91dGVyL2FuZ3VsYXJqcyAobmcxKS5cbiAgICAgKlxuICAgICAqIElmIG5vIGB2aWV3czoge31gIHByb3BlcnR5IGV4aXN0cyBvbiB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoZW4gaXQgY3JlYXRlcyB0aGUgYHZpZXdzYCBvYmplY3RcbiAgICAgKiBhbmQgYXBwbGllcyB0aGUgc3RhdGUtbGV2ZWwgY29uZmlndXJhdGlvbiB0byBhIHZpZXcgbmFtZWQgYCRkZWZhdWx0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZzFWaWV3c0J1aWxkZXIoc3RhdGUpIHtcbiAgICAgICAgLy8gRG8gbm90IHByb2Nlc3Mgcm9vdCBzdGF0ZVxuICAgICAgICBpZiAoIXN0YXRlLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgdmFyIHRwbEtleXMgPSBbJ3RlbXBsYXRlUHJvdmlkZXInLCAndGVtcGxhdGVVcmwnLCAndGVtcGxhdGUnLCAnbm90aWZ5JywgJ2FzeW5jJ10sIGN0cmxLZXlzID0gWydjb250cm9sbGVyJywgJ2NvbnRyb2xsZXJQcm92aWRlcicsICdjb250cm9sbGVyQXMnLCAncmVzb2x2ZUFzJ10sIGNvbXBLZXlzID0gWydjb21wb25lbnQnLCAnYmluZGluZ3MnLCAnY29tcG9uZW50UHJvdmlkZXInXSwgbm9uQ29tcEtleXMgPSB0cGxLZXlzLmNvbmNhdChjdHJsS2V5cyksIGFsbFZpZXdLZXlzID0gY29tcEtleXMuY29uY2F0KG5vbkNvbXBLZXlzKTtcbiAgICAgICAgLy8gRG8gbm90IGFsbG93IGEgc3RhdGUgdG8gaGF2ZSBib3RoIHN0YXRlLWxldmVsIHByb3BzIGFuZCBhbHNvIGEgYHZpZXdzOiB7fWAgcHJvcGVydHkuXG4gICAgICAgIC8vIEEgc3RhdGUgd2l0aG91dCBhIGB2aWV3czoge31gIHByb3BlcnR5IGNhbiBkZWNsYXJlIHByb3BlcnRpZXMgZm9yIHRoZSBgJGRlZmF1bHRgIHZpZXcgYXMgcHJvcGVydGllcyBvZiB0aGUgc3RhdGUuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBgJGRlZmF1bHRgIGFwcHJvYWNoIHNob3VsZCBub3QgYmUgbWl4ZWQgd2l0aCBhIHNlcGFyYXRlIGB2aWV3czogYCBibG9jay5cbiAgICAgICAgaWYgKGNvcmUuaXNEZWZpbmVkKHN0YXRlLnZpZXdzKSAmJiBoYXNBbnlLZXkoYWxsVmlld0tleXMsIHN0YXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgJ1wiICsgc3RhdGUubmFtZSArIFwiJyBoYXMgYSAndmlld3MnIG9iamVjdC4gXCIgK1xuICAgICAgICAgICAgICAgIFwiSXQgY2Fubm90IGFsc28gaGF2ZSBcXFwidmlldyBwcm9wZXJ0aWVzXFxcIiBhdCB0aGUgc3RhdGUgbGV2ZWwuICBcIiArXG4gICAgICAgICAgICAgICAgXCJNb3ZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbnRvIGEgdmlldyAoaW4gdGhlICd2aWV3cycgb2JqZWN0KTogXCIgK1xuICAgICAgICAgICAgICAgIChcIiBcIiArIGFsbFZpZXdLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb3JlLmlzRGVmaW5lZChzdGF0ZVtrZXldKTsgfSkuam9pbignLCAnKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3cyA9IHt9LCB2aWV3c09iamVjdCA9IHN0YXRlLnZpZXdzIHx8IHsgJGRlZmF1bHQ6IGNvcmUucGljayhzdGF0ZSwgYWxsVmlld0tleXMpIH07XG4gICAgICAgIGNvcmUuZm9yRWFjaCh2aWV3c09iamVjdCwgZnVuY3Rpb24gKGNvbmZpZywgbmFtZSkge1xuICAgICAgICAgICAgLy8gQWNjb3VudCBmb3Igdmlld3M6IHsgXCJcIjogeyB0ZW1wbGF0ZS4uLiB9IH1cbiAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8ICckZGVmYXVsdCc7XG4gICAgICAgICAgICAvLyBBY2NvdW50IGZvciB2aWV3czogeyBoZWFkZXI6IFwiaGVhZGVyQ29tcG9uZW50XCIgfVxuICAgICAgICAgICAgaWYgKGNvcmUuaXNTdHJpbmcoY29uZmlnKSlcbiAgICAgICAgICAgICAgICBjb25maWcgPSB7IGNvbXBvbmVudDogY29uZmlnIH07XG4gICAgICAgICAgICAvLyBNYWtlIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBjb25maWcgb2JqZWN0XG4gICAgICAgICAgICBjb25maWcgPSBjb3JlLmV4dGVuZCh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBhIHZpZXcgdG8gbWl4IHByb3BzIGZvciBjb21wb25lbnQtc3R5bGUgdmlldyB3aXRoIHByb3BzIGZvciB0ZW1wbGF0ZS9jb250cm9sbGVyLXN0eWxlIHZpZXdcbiAgICAgICAgICAgIGlmIChoYXNBbnlLZXkoY29tcEtleXMsIGNvbmZpZykgJiYgaGFzQW55S2V5KG5vbkNvbXBLZXlzLCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmU6IFwiICsgY29tcEtleXMuam9pbignfCcpICsgXCIgd2l0aDogXCIgKyBub25Db21wS2V5cy5qb2luKCd8JykgKyBcIiBpbiBzdGF0ZXZpZXc6ICdcIiArIG5hbWUgKyBcIkBcIiArIHN0YXRlLm5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcucmVzb2x2ZUFzID0gY29uZmlnLnJlc29sdmVBcyB8fCAnJHJlc29sdmUnO1xuICAgICAgICAgICAgY29uZmlnLiR0eXBlID0gJ25nMSc7XG4gICAgICAgICAgICBjb25maWcuJGNvbnRleHQgPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbmZpZy4kbmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9IGNvcmUuVmlld1NlcnZpY2Uubm9ybWFsaXplVUlWaWV3VGFyZ2V0KGNvbmZpZy4kY29udGV4dCwgY29uZmlnLiRuYW1lKTtcbiAgICAgICAgICAgIGNvbmZpZy4kdWlWaWV3TmFtZSA9IG5vcm1hbGl6ZWQudWlWaWV3TmFtZTtcbiAgICAgICAgICAgIGNvbmZpZy4kdWlWaWV3Q29udGV4dEFuY2hvciA9IG5vcm1hbGl6ZWQudWlWaWV3Q29udGV4dEFuY2hvcjtcbiAgICAgICAgICAgIHZpZXdzW25hbWVdID0gY29uZmlnO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZpZXdzO1xuICAgIH1cbiAgICB2YXIgaWQgPSAwO1xuICAgIHZhciBOZzFWaWV3Q29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZzFWaWV3Q29uZmlnKHBhdGgsIHZpZXdEZWNsLCBmYWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgIHRoaXMudmlld0RlY2wgPSB2aWV3RGVjbDtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgICAgICB0aGlzLiRpZCA9IGlkKys7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5nZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh1aVZpZXcsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gX3RoaXMuZmFjdG9yeS5tYWtlQ29tcG9uZW50VGVtcGxhdGUodWlWaWV3LCBjb250ZXh0LCBfdGhpcy5jb21wb25lbnQsIF90aGlzLnZpZXdEZWNsLmJpbmRpbmdzKVxuICAgICAgICAgICAgICAgICAgICA6IF90aGlzLnRlbXBsYXRlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBOZzFWaWV3Q29uZmlnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciAkcSA9IGNvcmUuc2VydmljZXMuJHE7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBjb3JlLlJlc29sdmVDb250ZXh0KHRoaXMucGF0aCk7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXRoLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7IHJldHVybiBjb3JlLmV4dGVuZChhY2MsIG5vZGUucGFyYW1WYWx1ZXMpOyB9LCB7fSk7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICRxLndoZW4odGhpcy5mYWN0b3J5LmZyb21Db25maWcodGhpcy52aWV3RGVjbCwgcGFyYW1zLCBjb250ZXh0KSksXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogJHEud2hlbih0aGlzLmdldENvbnRyb2xsZXIoY29udGV4dCkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjb3JlLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VFdmVudCgnTG9hZGVkJywgX3RoaXMpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2xsZXIgPSByZXN1bHRzLmNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgY29yZS5leHRlbmQoX3RoaXMsIHJlc3VsdHMudGVtcGxhdGUpOyAvLyBFaXRoZXIgeyB0ZW1wbGF0ZTogXCJ0cGxcIiB9IG9yIHsgY29tcG9uZW50OiBcImNtcE5hbWVcIiB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjb250cm9sbGVyIGZvciBhIHZpZXcgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufFByb21pc2UuPEZ1bmN0aW9uPn0gUmV0dXJucyBhIGNvbnRyb2xsZXIsIG9yIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgY29udHJvbGxlci5cbiAgICAgICAgICovXG4gICAgICAgIE5nMVZpZXdDb25maWcucHJvdG90eXBlLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gdGhpcy52aWV3RGVjbC5jb250cm9sbGVyUHJvdmlkZXI7XG4gICAgICAgICAgICBpZiAoIWNvcmUuaXNJbmplY3RhYmxlKHByb3ZpZGVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3RGVjbC5jb250cm9sbGVyO1xuICAgICAgICAgICAgdmFyIGRlcHMgPSBjb3JlLnNlcnZpY2VzLiRpbmplY3Rvci5hbm5vdGF0ZShwcm92aWRlcik7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXJGbiA9IGNvcmUuaXNBcnJheShwcm92aWRlcikgPyBjb3JlLnRhaWwocHJvdmlkZXIpIDogcHJvdmlkZXI7XG4gICAgICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IG5ldyBjb3JlLlJlc29sdmFibGUoJycsIHByb3ZpZGVyRm4sIGRlcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmcxVmlld0NvbmZpZztcbiAgICB9KCkpO1xuXG4gICAgLyoqIEBtb2R1bGUgdmlldyAqL1xuICAgIC8qKlxuICAgICAqIFNlcnZpY2Ugd2hpY2ggbWFuYWdlcyBsb2FkaW5nIG9mIHRlbXBsYXRlcyBmcm9tIGEgVmlld0NvbmZpZy5cbiAgICAgKi9cbiAgICB2YXIgVGVtcGxhdGVGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZUZhY3RvcnkoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fdXNlSHR0cCA9IG5nLnZlcnNpb24ubWlub3IgPCAzO1xuICAgICAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy4kZ2V0ID0gW1xuICAgICAgICAgICAgICAgICckaHR0cCcsXG4gICAgICAgICAgICAgICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICAgICAgICAgICAgICAnJGluamVjdG9yJyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJGh0dHAsICR0ZW1wbGF0ZUNhY2hlLCAkaW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuJHRlbXBsYXRlUmVxdWVzdCA9ICRpbmplY3Rvci5oYXMgJiYgJGluamVjdG9yLmhhcygnJHRlbXBsYXRlUmVxdWVzdCcpICYmICRpbmplY3Rvci5nZXQoJyR0ZW1wbGF0ZVJlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGh0dHAgPSAkaHR0cDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuJHRlbXBsYXRlQ2FjaGUgPSAkdGVtcGxhdGVDYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUudXNlSHR0cFNlcnZpY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZUh0dHAgPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHdoaWNoIHRvIGxvYWQgYSB0ZW1wbGF0ZS5cbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBzZWFyY2ggaW4gdGhlIHNwZWNpZmllZCBvcmRlciwgYW5kIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgICogdGhhdCBpcyBkZWZpbmVkIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZW1wbGF0ZTpcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAgUGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHJlc29sdmUgY29udGV4dCBhc3NvY2lhdGVkIHdpdGggdGhlIHRlbXBsYXRlJ3Mgdmlld1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd8b2JqZWN0fSAgVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3JcbiAgICAgICAgICogdGhhdCBzdHJpbmcsb3IgYG51bGxgIGlmIG5vIHRlbXBsYXRlIGlzIGNvbmZpZ3VyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY29uZmlnLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VGVtcGxhdGUgPSAnPHVpLXZpZXc+PC91aS12aWV3Pic7XG4gICAgICAgICAgICB2YXIgYXNUZW1wbGF0ZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIGNvcmUuc2VydmljZXMuJHEud2hlbihyZXN1bHQpLnRoZW4oZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gKHsgdGVtcGxhdGU6IHN0ciB9KTsgfSk7IH07XG4gICAgICAgICAgICB2YXIgYXNDb21wb25lbnQgPSBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBjb3JlLnNlcnZpY2VzLiRxLndoZW4ocmVzdWx0KS50aGVuKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuICh7IGNvbXBvbmVudDogc3RyIH0pOyB9KTsgfTtcbiAgICAgICAgICAgIHJldHVybiBjb3JlLmlzRGVmaW5lZChjb25maWcudGVtcGxhdGUpXG4gICAgICAgICAgICAgICAgPyBhc1RlbXBsYXRlKHRoaXMuZnJvbVN0cmluZyhjb25maWcudGVtcGxhdGUsIHBhcmFtcykpXG4gICAgICAgICAgICAgICAgOiBjb3JlLmlzRGVmaW5lZChjb25maWcudGVtcGxhdGVVcmwpXG4gICAgICAgICAgICAgICAgICAgID8gYXNUZW1wbGF0ZSh0aGlzLmZyb21VcmwoY29uZmlnLnRlbXBsYXRlVXJsLCBwYXJhbXMpKVxuICAgICAgICAgICAgICAgICAgICA6IGNvcmUuaXNEZWZpbmVkKGNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhc1RlbXBsYXRlKHRoaXMuZnJvbVByb3ZpZGVyKGNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyLCBwYXJhbXMsIGNvbnRleHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb3JlLmlzRGVmaW5lZChjb25maWcuY29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYXNDb21wb25lbnQoY29uZmlnLmNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvcmUuaXNEZWZpbmVkKGNvbmZpZy5jb21wb25lbnRQcm92aWRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhc0NvbXBvbmVudCh0aGlzLmZyb21Db21wb25lbnRQcm92aWRlcihjb25maWcuY29tcG9uZW50UHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXNUZW1wbGF0ZShkZWZhdWx0VGVtcGxhdGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0ZW1wbGF0ZSBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nLlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ3xvYmplY3R9IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2UgZm9yIHRoYXRcbiAgICAgICAgICogc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3JlLmlzRnVuY3Rpb24odGVtcGxhdGUpID8gdGVtcGxhdGUocGFyYW1zKSA6IHRlbXBsYXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9hZHMgYSB0ZW1wbGF0ZSBmcm9tIHRoZSBhIFVSTCB2aWEgYCRodHRwYCBhbmQgYCR0ZW1wbGF0ZUNhY2hlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHVybCB1cmwgb2YgdGhlIHRlbXBsYXRlIHRvIGxvYWQsIG9yIGEgZnVuY3Rpb25cbiAgICAgICAgICogdGhhdCByZXR1cm5zIGEgdXJsLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdXJsIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd8UHJvbWlzZS48c3RyaW5nPn0gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZVxuICAgICAgICAgKiBmb3IgdGhhdCBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLmZyb21VcmwgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChjb3JlLmlzRnVuY3Rpb24odXJsKSlcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwocGFyYW1zKTtcbiAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VIdHRwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHBcbiAgICAgICAgICAgICAgICAgICAgLmdldCh1cmwsIHsgY2FjaGU6IHRoaXMuJHRlbXBsYXRlQ2FjaGUsIGhlYWRlcnM6IHsgQWNjZXB0OiAndGV4dC9odG1sJyB9IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiR0ZW1wbGF0ZVJlcXVlc3QodXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBieSBpbnZva2luZyBhbiBpbmplY3RhYmxlIHByb3ZpZGVyIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcHJvdmlkZXIgRnVuY3Rpb24gdG8gaW52b2tlIHZpYSBgbG9jYWxzYFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbmplY3RGbiBhIGZ1bmN0aW9uIHVzZWQgdG8gaW52b2tlIHRoZSB0ZW1wbGF0ZSBwcm92aWRlclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd8UHJvbWlzZS48c3RyaW5nPn0gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZVxuICAgICAgICAgKiBmb3IgdGhhdCBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLmZyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgZGVwcyA9IGNvcmUuc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIHZhciBwcm92aWRlckZuID0gY29yZS5pc0FycmF5KHByb3ZpZGVyKSA/IGNvcmUudGFpbChwcm92aWRlcikgOiBwcm92aWRlcjtcbiAgICAgICAgICAgIHZhciByZXNvbHZhYmxlID0gbmV3IGNvcmUuUmVzb2x2YWJsZSgnJywgcHJvdmlkZXJGbiwgZGVwcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQoY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY29tcG9uZW50J3MgdGVtcGxhdGUgYnkgaW52b2tpbmcgYW4gaW5qZWN0YWJsZSBwcm92aWRlciBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHByb3ZpZGVyIEZ1bmN0aW9uIHRvIGludm9rZSB2aWEgYGxvY2Fsc2BcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW5qZWN0Rm4gYSBmdW5jdGlvbiB1c2VkIHRvIGludm9rZSB0aGUgdGVtcGxhdGUgcHJvdmlkZXJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZzogXCI8Y29tcG9uZW50LW5hbWUgaW5wdXQxPSc6OiRyZXNvbHZlLmZvbyc+PC9jb21wb25lbnQtbmFtZT5cIi5cbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUuZnJvbUNvbXBvbmVudFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBkZXBzID0gY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyRm4gPSBjb3JlLmlzQXJyYXkocHJvdmlkZXIpID8gY29yZS50YWlsKHByb3ZpZGVyKSA6IHByb3ZpZGVyO1xuICAgICAgICAgICAgdmFyIHJlc29sdmFibGUgPSBuZXcgY29yZS5SZXNvbHZhYmxlKCcnLCBwcm92aWRlckZuLCBkZXBzKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldChjb250ZXh0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgY29tcG9uZW50J3MgbmFtZVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGltcGxlbWVudHMgcm91dGUtdG8tY29tcG9uZW50LlxuICAgICAgICAgKiBJdCB3b3JrcyBieSByZXRyaWV2aW5nIHRoZSBjb21wb25lbnQgKGRpcmVjdGl2ZSkgbWV0YWRhdGEgZnJvbSB0aGUgaW5qZWN0b3IuXG4gICAgICAgICAqIEl0IGFuYWx5c2VzIHRoZSBjb21wb25lbnQncyBiaW5kaW5ncywgdGhlbiBjb25zdHJ1Y3RzIGEgdGVtcGxhdGUgdGhhdCBpbnN0YW50aWF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogVGhlIHRlbXBsYXRlIHdpcmVzIGlucHV0IGFuZCBvdXRwdXQgYmluZGluZ3MgdG8gcmVzb2x2ZXMgb3IgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVpVmlldyB7b2JqZWN0fSBUaGUgcGFyZW50IHVpLXZpZXcgKGZvciBiaW5kaW5nIG91dHB1dHMgdG8gY2FsbGJhY2tzKVxuICAgICAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgUmVzb2x2ZUNvbnRleHQgKGZvciBiaW5kaW5nIG91dHB1dHMgdG8gY2FsbGJhY2tzIHJldHVybmVkIGZyb20gcmVzb2x2ZXMpXG4gICAgICAgICAqIEBwYXJhbSBjb21wb25lbnQge3N0cmluZ30gQ29tcG9uZW50J3MgbmFtZSBpbiBjYW1lbCBjYXNlLlxuICAgICAgICAgKiBAcGFyYW0gYmluZGluZ3MgQW4gb2JqZWN0IGRlZmluaW5nIHRoZSBjb21wb25lbnQncyBiaW5kaW5nczoge2ZvbzogJzwnfVxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZW1wbGF0ZSBhcyBhIHN0cmluZzogXCI8Y29tcG9uZW50LW5hbWUgaW5wdXQxPSc6OiRyZXNvbHZlLmZvbyc+PC9jb21wb25lbnQtbmFtZT5cIi5cbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUubWFrZUNvbXBvbmVudFRlbXBsYXRlID0gZnVuY3Rpb24gKHVpVmlldywgY29udGV4dCwgY29tcG9uZW50LCBiaW5kaW5ncykge1xuICAgICAgICAgICAgYmluZGluZ3MgPSBiaW5kaW5ncyB8fCB7fTtcbiAgICAgICAgICAgIC8vIEJpbmQgb25jZSBwcmVmaXhcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBuZy52ZXJzaW9uLm1pbm9yID49IDMgPyAnOjonIDogJyc7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIGtlYm9iIG5hbWUuIEFkZCB4LSBwcmVmaXggaWYgdGhlIHN0cmluZyBzdGFydHMgd2l0aCBgeC1gIG9yIGBkYXRhLWBcbiAgICAgICAgICAgIHZhciBrZWJvYiA9IGZ1bmN0aW9uIChjYW1lbENhc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIga2Vib2JlZCA9IGNvcmUua2Vib2JTdHJpbmcoY2FtZWxDYXNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gL14oeHxkYXRhKS0vLmV4ZWMoa2Vib2JlZCkgPyBcIngtXCIgKyBrZWJvYmVkIDoga2Vib2JlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlVHBsID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpbnB1dC5uYW1lLCB0eXBlID0gaW5wdXQudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSBrZWJvYihuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdWktdmlldyBoYXMgYW4gYXR0cmlidXRlIHdoaWNoIG1hdGNoZXMgYSBiaW5kaW5nIG9uIHRoZSByb3V0ZWQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgLy8gdGhlbiBwYXNzIHRoYXQgYXR0cmlidXRlIHRocm91Z2ggdG8gdGhlIHJvdXRlZCBjb21wb25lbnQgdGVtcGxhdGUuXG4gICAgICAgICAgICAgICAgLy8gUHJlZmVyIHVpLXZpZXcgd2lyZWQgbWFwcGluZ3MgdG8gcmVzb2x2ZSBkYXRhLCB1bmxlc3MgdGhlIHJlc29sdmUgd2FzIGV4cGxpY2l0bHkgYm91bmQgdXNpbmcgYGJpbmRpbmdzOmBcbiAgICAgICAgICAgICAgICBpZiAodWlWaWV3LmF0dHIoYXR0ck5hbWUpICYmICFiaW5kaW5nc1tuYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lICsgXCI9J1wiICsgdWlWaWV3LmF0dHIoYXR0ck5hbWUpICsgXCInXCI7XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVOYW1lID0gYmluZGluZ3NbbmFtZV0gfHwgbmFtZTtcbiAgICAgICAgICAgICAgICAvLyBQcmUtZXZhbHVhdGUgdGhlIGV4cHJlc3Npb24gZm9yIFwiQFwiIGJpbmRpbmdzIGJ5IGVuY2xvc2luZyBpbiB7eyB9fVxuICAgICAgICAgICAgICAgIC8vIHNvbWUtYXR0cj1cInt7IDo6JHJlc29sdmUuc29tZVJlc29sdmVOYW1lIH19XCJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0AnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0ck5hbWUgKyBcIj0ne3tcIiArIHByZWZpeCArIFwiJHJlc29sdmUuXCIgKyByZXNvbHZlTmFtZSArIFwifX0nXCI7XG4gICAgICAgICAgICAgICAgLy8gV2lyZSBcIiZcIiBjYWxsYmFja3MgdG8gcmVzb2x2ZXMgdGhhdCByZXR1cm4gYSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVzdWx0IG9mIHRoZSByZXNvbHZlIChzaG91bGQgYmUgYSBmdW5jdGlvbikgYW5kIGFubm90YXRlIGl0IHRvIGdldCBpdHMgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIC8vIHNvbWUtYXR0cj1cIiRyZXNvbHZlLnNvbWVSZXNvbHZlUmVzdWx0TmFtZShmb28sIGJhcilcIlxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnJicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGNvbnRleHQuZ2V0UmVzb2x2YWJsZShyZXNvbHZlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHJlcyAmJiByZXMuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSAoZm4gJiYgY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUoZm4pKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgYXJyYXkgc3R5bGUgaW5qZWN0aW9uLCBpLmUuLCBbJ2ZvbycsIGZ1bmN0aW9uKGZvbykge31dXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheUlkeFN0ciA9IGNvcmUuaXNBcnJheShmbikgPyBcIltcIiArIChmbi5sZW5ndGggLSAxKSArIFwiXVwiIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZSArIFwiPSckcmVzb2x2ZS5cIiArIHJlc29sdmVOYW1lICsgYXJyYXlJZHhTdHIgKyBcIihcIiArIGFyZ3Muam9pbignLCcpICsgXCIpJ1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzb21lLWF0dHI9XCI6OiRyZXNvbHZlLnNvbWVSZXNvbHZlTmFtZVwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lICsgXCI9J1wiICsgcHJlZml4ICsgXCIkcmVzb2x2ZS5cIiArIHJlc29sdmVOYW1lICsgXCInXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gZ2V0Q29tcG9uZW50QmluZGluZ3MoY29tcG9uZW50KVxuICAgICAgICAgICAgICAgIC5tYXAoYXR0cmlidXRlVHBsKVxuICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgICAgICB2YXIga2Vib2JOYW1lID0ga2Vib2IoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHJldHVybiBcIjxcIiArIGtlYm9iTmFtZSArIFwiIFwiICsgYXR0cnMgKyBcIj48L1wiICsga2Vib2JOYW1lICsgXCI+XCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZUZhY3Rvcnk7XG4gICAgfSgpKTtcbiAgICAvLyBHZXRzIGFsbCB0aGUgZGlyZWN0aXZlKHMpJyBpbnB1dHMgKCdAJywgJz0nLCBhbmQgJzwnKSBhbmQgb3V0cHV0cyAoJyYnKVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudEJpbmRpbmdzKG5hbWUpIHtcbiAgICAgICAgdmFyIGNtcERlZnMgPSBjb3JlLnNlcnZpY2VzLiRpbmplY3Rvci5nZXQobmFtZSArICdEaXJlY3RpdmUnKTsgLy8gY291bGQgYmUgbXVsdGlwbGVcbiAgICAgICAgaWYgKCFjbXBEZWZzIHx8ICFjbXBEZWZzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGNvbXBvbmVudCBuYW1lZCAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICByZXR1cm4gY21wRGVmcy5tYXAoZ2V0QmluZGluZ3MpLnJlZHVjZShjb3JlLnVubmVzdFIsIFtdKTtcbiAgICB9XG4gICAgLy8gR2l2ZW4gYSBkaXJlY3RpdmUgZGVmaW5pdGlvbiwgZmluZCBpdHMgb2JqZWN0IGlucHV0IGF0dHJpYnV0ZXNcbiAgICAvLyBVc2UgZGlmZmVyZW50IHByb3BlcnRpZXMsIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBkaXJlY3RpdmUgKGNvbXBvbmVudCwgYmluZFRvQ29udHJvbGxlciwgbm9ybWFsKVxuICAgIHZhciBnZXRCaW5kaW5ncyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgaWYgKGNvcmUuaXNPYmplY3QoZGVmLmJpbmRUb0NvbnRyb2xsZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHNjb3BlQmluZGluZ3MoZGVmLmJpbmRUb0NvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gc2NvcGVCaW5kaW5ncyhkZWYuc2NvcGUpO1xuICAgIH07XG4gICAgLy8gZm9yIG5nIDEuMiBzdHlsZSwgcHJvY2VzcyB0aGUgc2NvcGU6IHsgaW5wdXQ6IFwiPWZvb1wiIH1cbiAgICAvLyBmb3IgbmcgMS4zIHRocm91Z2ggbmcgMS41LCBwcm9jZXNzIHRoZSBjb21wb25lbnQncyBiaW5kVG9Db250cm9sbGVyOiB7IGlucHV0OiBcIj1mb29cIiB9IG9iamVjdFxuICAgIHZhciBzY29wZUJpbmRpbmdzID0gZnVuY3Rpb24gKGJpbmRpbmdzT2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhiaW5kaW5nc09iaiB8fCB7fSlcbiAgICAgICAgICAgIC8vIFsgJ2lucHV0JywgWyAnPWZvbycsICc9JywgJ2ZvbycgXSBdXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIC9eKFs9PEAmXSlbP10/KC4qKS8uZXhlYyhiaW5kaW5nc09ialtrZXldKV07IH0pXG4gICAgICAgICAgICAvLyBza2lwIG1hbGZvcm1lZCB2YWx1ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiBjb3JlLmlzRGVmaW5lZCh0dXBsZSkgJiYgY29yZS5pc0FycmF5KHR1cGxlWzFdKTsgfSlcbiAgICAgICAgICAgIC8vIHsgbmFtZTogKCdmb28nIHx8ICdpbnB1dCcpLCB0eXBlOiAnPScgfVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuICh7IG5hbWU6IHR1cGxlWzFdWzJdIHx8IHR1cGxlWzBdLCB0eXBlOiB0dXBsZVsxXVsxXSB9KTsgfSk7XG4gICAgfTtcblxuICAgIC8qKiBAbW9kdWxlIG5nMSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbiAgICAvKipcbiAgICAgKiBUaGUgQW5ndWxhciAxIGBTdGF0ZVByb3ZpZGVyYFxuICAgICAqXG4gICAgICogVGhlIGAkc3RhdGVQcm92aWRlcmAgd29ya3Mgc2ltaWxhciB0byBBbmd1bGFyJ3MgdjEgcm91dGVyLCBidXQgaXQgZm9jdXNlcyBwdXJlbHlcbiAgICAgKiBvbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEEgc3RhdGUgY29ycmVzcG9uZHMgdG8gYSBcInBsYWNlXCIgaW4gdGhlIGFwcGxpY2F0aW9uIGluIHRlcm1zIG9mIHRoZSBvdmVyYWxsIFVJIGFuZFxuICAgICAqIG5hdmlnYXRpb24uIEEgc3RhdGUgZGVzY3JpYmVzICh2aWEgdGhlIGNvbnRyb2xsZXIgLyB0ZW1wbGF0ZSAvIHZpZXcgcHJvcGVydGllcykgd2hhdFxuICAgICAqIHRoZSBVSSBsb29rcyBsaWtlIGFuZCBkb2VzIGF0IHRoYXQgcGxhY2UuXG4gICAgICpcbiAgICAgKiBTdGF0ZXMgb2Z0ZW4gaGF2ZSB0aGluZ3MgaW4gY29tbW9uLCBhbmQgdGhlIHByaW1hcnkgd2F5IG9mIGZhY3RvcmluZyBvdXQgdGhlc2VcbiAgICAgKiBjb21tb25hbGl0aWVzIGluIHRoaXMgbW9kZWwgaXMgdmlhIHRoZSBzdGF0ZSBoaWVyYXJjaHksIGkuZS4gcGFyZW50L2NoaWxkIHN0YXRlcyBha2FcbiAgICAgKiBuZXN0ZWQgc3RhdGVzLlxuICAgICAqXG4gICAgICogVGhlIGAkc3RhdGVQcm92aWRlcmAgcHJvdmlkZXMgaW50ZXJmYWNlcyB0byBkZWNsYXJlIHRoZXNlIHN0YXRlcyBmb3IgeW91ciBhcHAuXG4gICAgICovXG4gICAgdmFyIFN0YXRlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN0YXRlUHJvdmlkZXIoc3RhdGVSZWdpc3RyeSwgc3RhdGVTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkgPSBzdGF0ZVJlZ2lzdHJ5O1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVNlcnZpY2UgPSBzdGF0ZVNlcnZpY2U7XG4gICAgICAgICAgICBjb3JlLmNyZWF0ZVByb3h5RnVuY3Rpb25zKGNvcmUudmFsKFN0YXRlUHJvdmlkZXIucHJvdG90eXBlKSwgdGhpcywgY29yZS52YWwodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvcmF0ZXMgc3RhdGVzIHdoZW4gdGhleSBhcmUgcmVnaXN0ZXJlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBBbGxvd3MgeW91IHRvIGV4dGVuZCAoY2FyZWZ1bGx5KSBvciBvdmVycmlkZSAoYXQgeW91ciBvd24gcGVyaWwpIHRoZVxuICAgICAgICAgKiBgc3RhdGVCdWlsZGVyYCBvYmplY3QgdXNlZCBpbnRlcm5hbGx5IGJ5IFtbU3RhdGVSZWdpc3RyeV1dLlxuICAgICAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGFkZCBjdXN0b20gZnVuY3Rpb25hbGl0eSB0byB1aS1yb3V0ZXIsXG4gICAgICAgICAqIGZvciBleGFtcGxlIGluZmVycmluZyB0ZW1wbGF0ZVVybCBiYXNlZCBvbiB0aGUgc3RhdGUgbmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBwYXNzaW5nIG9ubHkgYSBuYW1lLCBpdCByZXR1cm5zIHRoZSBjdXJyZW50IChvcmlnaW5hbCBvciBkZWNvcmF0ZWQpIGJ1aWxkZXJcbiAgICAgICAgICogZnVuY3Rpb24gdGhhdCBtYXRjaGVzIGBuYW1lYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGJ1aWxkZXIgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIGRlY29yYXRlZCBhcmUgbGlzdGVkIGJlbG93LiBUaG91Z2ggbm90IGFsbFxuICAgICAgICAgKiBuZWNlc3NhcmlseSBoYXZlIGEgZ29vZCB1c2UgY2FzZSBmb3IgZGVjb3JhdGlvbiwgdGhhdCBpcyB1cCB0byB5b3UgdG8gZGVjaWRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiBhZGRpdGlvbiwgdXNlcnMgY2FuIGF0dGFjaCBjdXN0b20gZGVjb3JhdG9ycywgd2hpY2ggd2lsbCBnZW5lcmF0ZSBuZXdcbiAgICAgICAgICogcHJvcGVydGllcyB3aXRoaW4gdGhlIHN0YXRlJ3MgaW50ZXJuYWwgZGVmaW5pdGlvbi4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGNsZWFyXG4gICAgICAgICAqIHVzZS1jYXNlIGZvciB0aGlzIGJleW9uZCBhY2Nlc3NpbmcgaW50ZXJuYWwgc3RhdGVzIChpLmUuICRzdGF0ZS4kY3VycmVudCksXG4gICAgICAgICAqIGhvd2V2ZXIsIGV4cGVjdCB0aGlzIHRvIGJlY29tZSBpbmNyZWFzaW5nbHkgcmVsZXZhbnQgYXMgd2UgaW50cm9kdWNlIGFkZGl0aW9uYWxcbiAgICAgICAgICogbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogKipXYXJuaW5nKio6IERlY29yYXRvcnMgc2hvdWxkIG5vdCBiZSBpbnRlcmRlcGVuZGVudCBiZWNhdXNlIHRoZSBvcmRlciBvZlxuICAgICAgICAgKiBleGVjdXRpb24gb2YgdGhlIGJ1aWxkZXIgZnVuY3Rpb25zIGluIG5vbi1kZXRlcm1pbmlzdGljLiBCdWlsZGVyIGZ1bmN0aW9uc1xuICAgICAgICAgKiBzaG91bGQgb25seSBiZSBkZXBlbmRlbnQgb24gdGhlIHN0YXRlIGRlZmluaXRpb24gb2JqZWN0IGFuZCBzdXBlciBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogRXhpc3RpbmcgYnVpbGRlciBmdW5jdGlvbnMgYW5kIGN1cnJlbnQgcmV0dXJuIHZhbHVlczpcbiAgICAgICAgICpcbiAgICAgICAgICogLSAqKnBhcmVudCoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIHRoZSBwYXJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKiAtICoqZGF0YSoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIHN0YXRlIGRhdGEsIGluY2x1ZGluZyBhbnkgaW5oZXJpdGVkIGRhdGEgdGhhdCBpcyBub3RcbiAgICAgICAgICogICBvdmVycmlkZGVuIGJ5IG93biB2YWx1ZXMgKGlmIGFueSkuXG4gICAgICAgICAqIC0gKip1cmwqKiBge29iamVjdH1gIC0gcmV0dXJucyBhIHtAbGluayB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIgVXJsTWF0Y2hlcn1cbiAgICAgICAgICogICBvciBgbnVsbGAuXG4gICAgICAgICAqIC0gKipuYXZpZ2FibGUqKiBge29iamVjdH1gIC0gcmV0dXJucyBjbG9zZXN0IGFuY2VzdG9yIHN0YXRlIHRoYXQgaGFzIGEgVVJMIChha2EgaXNcbiAgICAgICAgICogICBuYXZpZ2FibGUpLlxuICAgICAgICAgKiAtICoqcGFyYW1zKiogYHtvYmplY3R9YCAtIHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGUgcGFyYW1zIHRoYXQgYXJlIGVuc3VyZWQgdG9cbiAgICAgICAgICogICBiZSBhIHN1cGVyLXNldCBvZiBwYXJlbnQncyBwYXJhbXMuXG4gICAgICAgICAqIC0gKip2aWV3cyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGEgdmlld3Mgb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGFuIGFic29sdXRlIHZpZXdcbiAgICAgICAgICogICBuYW1lIChpLmUuIFwidmlld05hbWVAc3RhdGVOYW1lXCIpIGFuZCBlYWNoIHZhbHVlIGlzIHRoZSBjb25maWcgb2JqZWN0XG4gICAgICAgICAqICAgKHRlbXBsYXRlLCBjb250cm9sbGVyKSBmb3IgdGhlIHZpZXcuIEV2ZW4gd2hlbiB5b3UgZG9uJ3QgdXNlIHRoZSB2aWV3cyBvYmplY3RcbiAgICAgICAgICogICBleHBsaWNpdGx5IG9uIGEgc3RhdGUgY29uZmlnLCBvbmUgaXMgc3RpbGwgY3JlYXRlZCBmb3IgeW91IGludGVybmFsbHkuXG4gICAgICAgICAqICAgU28gYnkgZGVjb3JhdGluZyB0aGlzIGJ1aWxkZXIgZnVuY3Rpb24geW91IGhhdmUgYWNjZXNzIHRvIGRlY29yYXRpbmcgdGVtcGxhdGVcbiAgICAgICAgICogICBhbmQgY29udHJvbGxlciBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiAtICoqb3duUGFyYW1zKiogYHtvYmplY3R9YCAtIHJldHVybnMgYW4gYXJyYXkgb2YgcGFyYW1zIHRoYXQgYmVsb25nIHRvIHRoZSBzdGF0ZSxcbiAgICAgICAgICogICBub3QgaW5jbHVkaW5nIGFueSBwYXJhbXMgZGVmaW5lZCBieSBhbmNlc3RvciBzdGF0ZXMuXG4gICAgICAgICAqIC0gKipwYXRoKiogYHtzdHJpbmd9YCAtIHJldHVybnMgdGhlIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZS5cbiAgICAgICAgICogICBOZWVkZWQgZm9yIHN0YXRlIGFjdGl2YXRpb24uXG4gICAgICAgICAqIC0gKippbmNsdWRlcyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIGV2ZXJ5IHN0YXRlIHRoYXRcbiAgICAgICAgICogICB3b3VsZCBwYXNzIGEgYCRzdGF0ZS5pbmNsdWRlcygpYCB0ZXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICAgICAqIE92ZXJyaWRlIHRoZSBpbnRlcm5hbCAndmlld3MnIGJ1aWxkZXIgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHN0YXRlXG4gICAgICAgICAqIGRlZmluaXRpb24sIGFuZCBhIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgZnVuY3Rpb24gYmVpbmcgb3ZlcnJpZGRlbjpcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogJHN0YXRlUHJvdmlkZXIuZGVjb3JhdG9yKCd2aWV3cycsIGZ1bmN0aW9uIChzdGF0ZSwgcGFyZW50KSB7XG4gICAgICAgICAqICAgbGV0IHJlc3VsdCA9IHt9LFxuICAgICAgICAgKiAgICAgICB2aWV3cyA9IHBhcmVudChzdGF0ZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgYW5ndWxhci5mb3JFYWNoKHZpZXdzLCBmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XG4gICAgICAgICAqICAgICBsZXQgYXV0b05hbWUgPSAoc3RhdGUubmFtZSArICcuJyArIG5hbWUpLnJlcGxhY2UoJy4nLCAnLycpO1xuICAgICAgICAgKiAgICAgY29uZmlnLnRlbXBsYXRlVXJsID0gY29uZmlnLnRlbXBsYXRlVXJsIHx8ICcvcGFydGlhbHMvJyArIGF1dG9OYW1lICsgJy5odG1sJztcbiAgICAgICAgICogICAgIHJlc3VsdFtuYW1lXSA9IGNvbmZpZztcbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2hvbWUnLCB7XG4gICAgICAgICAqICAgdmlld3M6IHtcbiAgICAgICAgICogICAgICdjb250YWN0Lmxpc3QnOiB7IGNvbnRyb2xsZXI6ICdMaXN0Q29udHJvbGxlcicgfSxcbiAgICAgICAgICogICAgICdjb250YWN0Lml0ZW0nOiB7IGNvbnRyb2xsZXI6ICdJdGVtQ29udHJvbGxlcicgfVxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiAvLyBBdXRvLXBvcHVsYXRlcyBsaXN0IGFuZCBpdGVtIHZpZXdzIHdpdGggL3BhcnRpYWxzL2hvbWUvY29udGFjdC9saXN0Lmh0bWwsXG4gICAgICAgICAqIC8vIGFuZCAvcGFydGlhbHMvaG9tZS9jb250YWN0L2l0ZW0uaHRtbCwgcmVzcGVjdGl2ZWx5LlxuICAgICAgICAgKiAkc3RhdGUuZ28oJ2hvbWUnKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBidWlsZGVyIGZ1bmN0aW9uIHRvIGRlY29yYXRlLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZnVuYyBBIGZ1bmN0aW9uIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGRlY29yYXRpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAqIGJ1aWxkZXIgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0d28gcGFyYW1ldGVyczpcbiAgICAgICAgICpcbiAgICAgICAgICogICAtIGB7b2JqZWN0fWAgLSBzdGF0ZSAtIFRoZSBzdGF0ZSBjb25maWcgb2JqZWN0LlxuICAgICAgICAgKiAgIC0gYHtvYmplY3R9YCAtIHN1cGVyIC0gVGhlIG9yaWdpbmFsIGJ1aWxkZXIgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gJHN0YXRlUHJvdmlkZXIgLSAkc3RhdGVQcm92aWRlciBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgU3RhdGVQcm92aWRlci5wcm90b3R5cGUuZGVjb3JhdG9yID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKG5hbWUsIGZ1bmMpIHx8IHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFN0YXRlUHJvdmlkZXIucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChjb3JlLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZVJlZ2lzdHJ5LnJlZ2lzdGVyKGRlZmluaXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlcnMgYW4gaW52YWxpZCBzdGF0ZSBoYW5kbGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0byBbW1N0YXRlU2VydmljZS5vbkludmFsaWRdXSBmb3IgbmcxLlxuICAgICAgICAgKi9cbiAgICAgICAgU3RhdGVQcm92aWRlci5wcm90b3R5cGUub25JbnZhbGlkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVNlcnZpY2Uub25JbnZhbGlkKGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0YXRlUHJvdmlkZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKiBAbW9kdWxlIG5nMSAqLyAvKiogKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgW1tTdGF0ZUJ1aWxkZXIuYnVpbGRlcl1dIGZ1bmN0aW9uIGZvciBhbmd1bGFyMSBgb25FbnRlcmAsIGBvbkV4aXRgLFxuICAgICAqIGBvblJldGFpbmAgY2FsbGJhY2sgaG9va3Mgb24gYSBbW05nMVN0YXRlRGVjbGFyYXRpb25dXS5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcbiAgICAgKiBlbnN1cmVzIHRoYXQgdGhvc2UgaG9va3MgYXJlIGluamVjdGFibGUgZm9yIEB1aXJvdXRlci9hbmd1bGFyanMgKG5nMSkuXG4gICAgICovXG4gICAgdmFyIGdldFN0YXRlSG9va0J1aWxkZXIgPSBmdW5jdGlvbiAoaG9va05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0YXRlSG9va0J1aWxkZXIoc3RhdGVPYmplY3QsIHBhcmVudEZuKSB7XG4gICAgICAgICAgICB2YXIgaG9vayA9IHN0YXRlT2JqZWN0W2hvb2tOYW1lXTtcbiAgICAgICAgICAgIHZhciBwYXRobmFtZSA9IGhvb2tOYW1lID09PSAnb25FeGl0JyA/ICdmcm9tJyA6ICd0byc7XG4gICAgICAgICAgICBmdW5jdGlvbiBkZWNvcmF0ZWROZzFIb29rKHRyYW5zLCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlQ29udGV4dCA9IG5ldyBjb3JlLlJlc29sdmVDb250ZXh0KHRyYW5zLnRyZWVDaGFuZ2VzKHBhdGhuYW1lKSk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YkNvbnRleHQgPSByZXNvbHZlQ29udGV4dC5zdWJDb250ZXh0KHN0YXRlLiQkc3RhdGUoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FscyA9IGNvcmUuZXh0ZW5kKGdldExvY2FscyhzdWJDb250ZXh0KSwgeyAkc3RhdGUkOiBzdGF0ZSwgJHRyYW5zaXRpb24kOiB0cmFucyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IuaW52b2tlKGhvb2ssIHRoaXMsIGxvY2Fscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG9vayA/IGRlY29yYXRlZE5nMUhvb2sgOiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqIEBtb2R1bGUgbmcxXG4gICAgICovIC8qKiAqL1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgVUktUm91dGVyIExvY2F0aW9uU2VydmljZXMgYW5kIExvY2F0aW9uQ29uZmlnIHVzaW5nIEFuZ3VsYXIgMSdzICRsb2NhdGlvbiBzZXJ2aWNlXG4gICAgICovXG4gICAgdmFyIE5nMUxvY2F0aW9uU2VydmljZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nMUxvY2F0aW9uU2VydmljZXMoJGxvY2F0aW9uUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIC8vIC5vbkNoYW5nZSgpIHJlZ2lzdHJ5XG4gICAgICAgICAgICB0aGlzLl91cmxMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuJGxvY2F0aW9uUHJvdmlkZXIgPSAkbG9jYXRpb25Qcm92aWRlcjtcbiAgICAgICAgICAgIHZhciBfbHAgPSBjb3JlLnZhbCgkbG9jYXRpb25Qcm92aWRlcik7XG4gICAgICAgICAgICBjb3JlLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9scCwgdGhpcywgX2xwLCBbJ2hhc2hQcmVmaXgnXSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5cyBuZzEtc3BlY2lmaWMgcGF0aCBwYXJhbWV0ZXIgZW5jb2RpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIEFuZ3VsYXIgMSBgJGxvY2F0aW9uYCBzZXJ2aWNlIGlzIGEgYml0IHdlaXJkLlxuICAgICAgICAgKiBJdCBkb2Vzbid0IGFsbG93IHNsYXNoZXMgdG8gYmUgZW5jb2RlZC9kZWNvZGVkIGJpLWRpcmVjdGlvbmFsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSB0aGUgd3JpdGV1cCBhdCBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1yb3V0ZXIvaXNzdWVzLzI1OThcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBjb2RlIHBhdGNoZXMgdGhlIGBwYXRoYCBwYXJhbWV0ZXIgdHlwZSBzbyBpdCBlbmNvZGVkL2RlY29kZXMgc2xhc2hlcyBhcyB+MkZcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdXRlclxuICAgICAgICAgKi9cbiAgICAgICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5tb25rZXlQYXRjaFBhdGhQYXJhbWV0ZXJUeXBlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICAgICAgdmFyIHBhdGhUeXBlID0gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LnR5cGUoJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGhUeXBlLmVuY29kZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHggIT0gbnVsbCA/IHgudG9TdHJpbmcoKS5yZXBsYWNlKC8ofnxcXC8pL2csIGZ1bmN0aW9uIChtKSB7IHJldHVybiAoeyAnfic6ICd+ficsICcvJzogJ34yRicgfVttXSk7IH0pIDogeDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXRoVHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4ICE9IG51bGwgPyB4LnRvU3RyaW5nKCkucmVwbGFjZSgvKH5+fH4yRikvZywgZnVuY3Rpb24gKG0pIHsgcmV0dXJuICh7ICd+fic6ICd+JywgJ34yRic6ICcvJyB9W21dKTsgfSkgOiB4O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl91cmxMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZS5yZW1vdmVGcm9tKF90aGlzLl91cmxMaXN0ZW5lcnMpKGNhbGxiYWNrKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuaHRtbDVNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGh0bWw1TW9kZSA9IHRoaXMuJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKCk7XG4gICAgICAgICAgICBodG1sNU1vZGUgPSBjb3JlLmlzT2JqZWN0KGh0bWw1TW9kZSkgPyBodG1sNU1vZGUuZW5hYmxlZCA6IGh0bWw1TW9kZTtcbiAgICAgICAgICAgIHJldHVybiBodG1sNU1vZGUgJiYgdGhpcy4kc25pZmZlci5oaXN0b3J5O1xuICAgICAgICB9O1xuICAgICAgICBOZzFMb2NhdGlvblNlcnZpY2VzLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAobmV3VXJsLCByZXBsYWNlLCBzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHJlcGxhY2UgPT09IHZvaWQgMCkgeyByZXBsYWNlID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChjb3JlLmlzRGVmaW5lZChuZXdVcmwpKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxvY2F0aW9uLnVybChuZXdVcmwpO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2UpXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9jYXRpb24ucmVwbGFjZSgpO1xuICAgICAgICAgICAgaWYgKHN0YXRlKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxvY2F0aW9uLnN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRsb2NhdGlvbi51cmwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuX3J1bnRpbWVTZXJ2aWNlcyA9IGZ1bmN0aW9uICgkcm9vdFNjb3BlLCAkbG9jYXRpb24sICRzbmlmZmVyLCAkYnJvd3Nlcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuJGxvY2F0aW9uID0gJGxvY2F0aW9uO1xuICAgICAgICAgICAgdGhpcy4kc25pZmZlciA9ICRzbmlmZmVyO1xuICAgICAgICAgICAgLy8gQmluZCAkbG9jYXRpb25DaGFuZ2VTdWNjZXNzIHRvIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBpbiBMb2NhdGlvblNlcnZpY2Uub25DaGFuZ2VcbiAgICAgICAgICAgICRyb290U2NvcGUuJG9uKCckbG9jYXRpb25DaGFuZ2VTdWNjZXNzJywgZnVuY3Rpb24gKGV2dCkgeyByZXR1cm4gX3RoaXMuX3VybExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oZXZ0KTsgfSk7IH0pO1xuICAgICAgICAgICAgdmFyIF9sb2MgPSBjb3JlLnZhbCgkbG9jYXRpb24pO1xuICAgICAgICAgICAgdmFyIF9icm93c2VyID0gY29yZS52YWwoJGJyb3dzZXIpO1xuICAgICAgICAgICAgLy8gQmluZCB0aGVzZSBMb2NhdGlvblNlcnZpY2UgZnVuY3Rpb25zIHRvICRsb2NhdGlvblxuICAgICAgICAgICAgY29yZS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhfbG9jLCB0aGlzLCBfbG9jLCBbJ3JlcGxhY2UnLCAncGF0aCcsICdzZWFyY2gnLCAnaGFzaCddKTtcbiAgICAgICAgICAgIC8vIEJpbmQgdGhlc2UgTG9jYXRpb25Db25maWcgZnVuY3Rpb25zIHRvICRsb2NhdGlvblxuICAgICAgICAgICAgY29yZS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhfbG9jLCB0aGlzLCBfbG9jLCBbJ3BvcnQnLCAncHJvdG9jb2wnLCAnaG9zdCddKTtcbiAgICAgICAgICAgIC8vIEJpbmQgdGhlc2UgTG9jYXRpb25Db25maWcgZnVuY3Rpb25zIHRvICRicm93c2VyXG4gICAgICAgICAgICBjb3JlLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9icm93c2VyLCB0aGlzLCBfYnJvd3NlciwgWydiYXNlSHJlZiddKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nMUxvY2F0aW9uU2VydmljZXM7XG4gICAgfSgpKTtcblxuICAgIC8qKiBAbW9kdWxlIHVybCAqLyAvKiogKi9cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHJ1bGVzIGZvciBjbGllbnQtc2lkZSBVUkxcbiAgICAgKlxuICAgICAqICMjIyBEZXByZWNhdGlvbiB3YXJuaW5nOlxuICAgICAqIFRoaXMgY2xhc3MgaXMgbm93IGNvbnNpZGVyZWQgdG8gYmUgYW4gaW50ZXJuYWwgQVBJXG4gICAgICogVXNlIHRoZSBbW1VybFNlcnZpY2VdXSBpbnN0ZWFkLlxuICAgICAqIEZvciBjb25maWd1cmluZyBVUkwgcnVsZXMsIHVzZSB0aGUgW1tVcmxSdWxlc0FwaV1dIHdoaWNoIGNhbiBiZSBmb3VuZCBhcyBbW1VybFNlcnZpY2UucnVsZXNdXS5cbiAgICAgKlxuICAgICAqIFRoaXMgY2xhc3MgbWFuYWdlcyB0aGUgcm91dGVyIHJ1bGVzIGZvciB3aGF0IHRvIGRvIHdoZW4gdGhlIFVSTCBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVGhpcyBwcm92aWRlciByZW1haW5zIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgdmFyIFVybFJvdXRlclByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICBmdW5jdGlvbiBVcmxSb3V0ZXJQcm92aWRlcihyb3V0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgICAgIHRoaXMuX3VybFJvdXRlciA9IHJvdXRlci51cmxSb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgVXJsUm91dGVyUHJvdmlkZXIuaW5qZWN0YWJsZUhhbmRsZXIgPSBmdW5jdGlvbiAocm91dGVyLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBjb3JlLnNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UoaGFuZGxlciwgbnVsbCwgeyAkbWF0Y2g6IG1hdGNoLCAkc3RhdGVQYXJhbXM6IHJvdXRlci5nbG9iYWxzLnBhcmFtcyB9KTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgVXJsUm91dGVyUHJvdmlkZXIucHJvdG90eXBlLiRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXJsUm91dGVyID0gdGhpcy5fdXJsUm91dGVyO1xuICAgICAgICAgICAgdXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcbiAgICAgICAgICAgIGlmICghdXJsUm91dGVyLmludGVyY2VwdERlZmVycmVkKVxuICAgICAgICAgICAgICAgIHVybFJvdXRlci5saXN0ZW4oKTtcbiAgICAgICAgICAgIHJldHVybiB1cmxSb3V0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlcnMgYSB1cmwgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogUmVnaXN0ZXJzIGEgbG93IGxldmVsIHVybCBoYW5kbGVyIChhIGBydWxlYCkuXG4gICAgICAgICAqIEEgcnVsZSBkZXRlY3RzIHNwZWNpZmljIFVSTCBwYXR0ZXJucyBhbmQgcmV0dXJucyBhIHJlZGlyZWN0LCBvciBwZXJmb3JtcyBzb21lIGFjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBydWxlIHJldHVybnMgYSBzdHJpbmcsIHRoZSBVUkwgaXMgcmVwbGFjZWQgd2l0aCB0aGUgc3RyaW5nLCBhbmQgYWxsIHJ1bGVzIGFyZSBmaXJlZCBhZ2Fpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcbiAgICAgICAgICpcbiAgICAgICAgICogYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHVybFJvdXRlclByb3ZpZGVyKSB7XG4gICAgICAgICAqICAgLy8gSGVyZSdzIGFuIGV4YW1wbGUgb2YgaG93IHlvdSBtaWdodCBhbGxvdyBjYXNlIGluc2Vuc2l0aXZlIHVybHNcbiAgICAgICAgICogICAkdXJsUm91dGVyUHJvdmlkZXIucnVsZShmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcbiAgICAgICAgICogICAgIHZhciBwYXRoID0gJGxvY2F0aW9uLnBhdGgoKSxcbiAgICAgICAgICogICAgICAgICBub3JtYWxpemVkID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgaWYgKHBhdGggIT09IG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICogICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqICAgfSk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJ1bGVGblxuICAgICAgICAgKiBIYW5kbGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYCRpbmplY3RvcmAgYW5kIGAkbG9jYXRpb25gIHNlcnZpY2VzIGFzIGFyZ3VtZW50cy5cbiAgICAgICAgICogWW91IGNhbiB1c2UgdGhlbSB0byBkZXRlY3QgYSB1cmwgYW5kIHJldHVybiBhIGRpZmZlcmVudCB1cmwgYXMgYSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gW1tVcmxSb3V0ZXJQcm92aWRlcl1dIChgdGhpc2ApXG4gICAgICAgICAqL1xuICAgICAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUucnVsZSA9IGZ1bmN0aW9uIChydWxlRm4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWNvcmUuaXNGdW5jdGlvbihydWxlRm4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidydWxlJyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBydWxlRm4oY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IsIF90aGlzLl9yb3V0ZXIubG9jYXRpb25TZXJ2aWNlKTsgfTtcbiAgICAgICAgICAgIHZhciBydWxlID0gbmV3IGNvcmUuQmFzZVVybFJ1bGUobWF0Y2gsIGNvcmUuaWRlbnRpdHkpO1xuICAgICAgICAgICAgdGhpcy5fdXJsUm91dGVyLnJ1bGUocnVsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHBhdGggb3IgYmVoYXZpb3IgdG8gdXNlIHdoZW4gbm8gdXJsIGNhbiBiZSBtYXRjaGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXIucm91dGVyJ10pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICAgICAgICogICAvLyBpZiB0aGUgcGF0aCBkb2Vzbid0IG1hdGNoIGFueSBvZiB0aGUgdXJscyB5b3UgY29uZmlndXJlZFxuICAgICAgICAgKiAgIC8vIG90aGVyd2lzZSB3aWxsIHRha2UgY2FyZSBvZiByb3V0aW5nIHRoZSB1c2VyIHRvIHRoZVxuICAgICAgICAgKiAgIC8vIHNwZWNpZmllZCB1cmxcbiAgICAgICAgICogICAkdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKCcvaW5kZXgnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAvLyBFeGFtcGxlIG9mIHVzaW5nIGZ1bmN0aW9uIHJ1bGUgYXMgcGFyYW1cbiAgICAgICAgICogICAkdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKGZ1bmN0aW9uICgkaW5qZWN0b3IsICRsb2NhdGlvbikge1xuICAgICAgICAgKiAgICAgcmV0dXJuICcvYS92YWxpZC91cmwnO1xuICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBydWxlXG4gICAgICAgICAqIFRoZSB1cmwgcGF0aCB5b3Ugd2FudCB0byByZWRpcmVjdCB0byBvciBhIGZ1bmN0aW9uIHJ1bGUgdGhhdCByZXR1cm5zIHRoZSB1cmwgcGF0aCBvciBwZXJmb3JtcyBhIGAkc3RhdGUuZ28oKWAuXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiB2ZXJzaW9uIGlzIHBhc3NlZCB0d28gcGFyYW1zOiBgJGluamVjdG9yYCBhbmQgYCRsb2NhdGlvbmAgc2VydmljZXMsIGFuZCBzaG91bGQgcmV0dXJuIGEgdXJsIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBgJHVybFJvdXRlclByb3ZpZGVyYCAtIGAkdXJsUm91dGVyUHJvdmlkZXJgIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUub3RoZXJ3aXNlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdXJsUm91dGVyID0gdGhpcy5fdXJsUm91dGVyO1xuICAgICAgICAgICAgaWYgKGNvcmUuaXNTdHJpbmcocnVsZSkpIHtcbiAgICAgICAgICAgICAgICB1cmxSb3V0ZXIub3RoZXJ3aXNlKHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29yZS5pc0Z1bmN0aW9uKHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAgdXJsUm91dGVyLm90aGVyd2lzZShmdW5jdGlvbiAoKSB7IHJldHVybiBydWxlKGNvcmUuc2VydmljZXMuJGluamVjdG9yLCBfdGhpcy5fcm91dGVyLmxvY2F0aW9uU2VydmljZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3J1bGUnIG11c3QgYmUgYSBzdHJpbmcgb3IgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIGhhbmRsZXIgZm9yIGEgZ2l2ZW4gdXJsIG1hdGNoaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgaGFuZGxlciBpcyBhIHN0cmluZywgaXQgaXNcbiAgICAgICAgICogdHJlYXRlZCBhcyBhIHJlZGlyZWN0LCBhbmQgaXMgaW50ZXJwb2xhdGVkIGFjY29yZGluZyB0byB0aGUgc3ludGF4IG9mIG1hdGNoXG4gICAgICAgICAqIChpLmUuIGxpa2UgYFN0cmluZy5yZXBsYWNlKClgIGZvciBgUmVnRXhwYCwgb3IgbGlrZSBhIGBVcmxNYXRjaGVyYCBwYXR0ZXJuIG90aGVyd2lzZSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBoYW5kbGVyIGlzIGEgZnVuY3Rpb24sIGl0IGlzIGluamVjdGFibGUuXG4gICAgICAgICAqIEl0IGdldHMgaW52b2tlZCBpZiBgJGxvY2F0aW9uYCBtYXRjaGVzLlxuICAgICAgICAgKiBZb3UgaGF2ZSB0aGUgb3B0aW9uIG9mIGluamVjdCB0aGUgbWF0Y2ggb2JqZWN0IGFzIGAkbWF0Y2hgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgaGFuZGxlciBjYW4gcmV0dXJuXG4gICAgICAgICAqXG4gICAgICAgICAqIC0gKipmYWxzeSoqIHRvIGluZGljYXRlIHRoYXQgdGhlIHJ1bGUgZGlkbid0IG1hdGNoIGFmdGVyIGFsbCwgdGhlbiBgJHVybFJvdXRlcmBcbiAgICAgICAgICogICB3aWxsIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFub3RoZXIgb25lIHRoYXQgbWF0Y2hlcy5cbiAgICAgICAgICogLSAqKnN0cmluZyoqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSByZWRpcmVjdCBhbmQgcGFzc2VkIHRvIGAkbG9jYXRpb24udXJsKClgXG4gICAgICAgICAqIC0gKip2b2lkKiogb3IgYW55ICoqdHJ1dGh5KiogdmFsdWUgdGVsbHMgYCR1cmxSb3V0ZXJgIHRoYXQgdGhlIHVybCB3YXMgaGFuZGxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcbiAgICAgICAgICpcbiAgICAgICAgICogYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHVybFJvdXRlclByb3ZpZGVyKSB7XG4gICAgICAgICAqICAgJHVybFJvdXRlclByb3ZpZGVyLndoZW4oJHN0YXRlLnVybCwgZnVuY3Rpb24gKCRtYXRjaCwgJHN0YXRlUGFyYW1zKSB7XG4gICAgICAgICAqICAgICBpZiAoJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZSAhPT0gc3RhdGUgfHxcbiAgICAgICAgICogICAgICAgICAhZXF1YWxGb3JLZXlzKCRtYXRjaCwgJHN0YXRlUGFyYW1zKSB7XG4gICAgICAgICAqICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbyhzdGF0ZSwgJG1hdGNoLCBmYWxzZSk7XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqICAgfSk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHdoYXQgQSBwYXR0ZXJuIHN0cmluZyB0byBtYXRjaCwgY29tcGlsZWQgYXMgYSBbW1VybE1hdGNoZXJdXS5cbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgVGhlIHBhdGggKG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBhdGgpIHRoYXQgeW91IHdhbnQgdG8gcmVkaXJlY3QgeW91ciB1c2VyIHRvLlxuICAgICAgICAgKiBAcGFyYW0gcnVsZUNhbGxiYWNrIFtvcHRpb25hbF0gQSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBgcnVsZWAgcmVnaXN0ZXJlZCB3aXRoIFtbVXJsTWF0Y2hlci5ydWxlXV1cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogdGhlIGhhbmRsZXIgbWF5IGFsc28gaW52b2tlIGFyYml0cmFyeSBjb2RlLCBzdWNoIGFzIGAkc3RhdGUuZ28oKWBcbiAgICAgICAgICovXG4gICAgICAgIFVybFJvdXRlclByb3ZpZGVyLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24gKHdoYXQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChjb3JlLmlzQXJyYXkoaGFuZGxlcikgfHwgY29yZS5pc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IFVybFJvdXRlclByb3ZpZGVyLmluamVjdGFibGVIYW5kbGVyKHRoaXMuX3JvdXRlciwgaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cmxSb3V0ZXIud2hlbih3aGF0LCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgbW9uaXRvcmluZyBvZiB0aGUgVVJMLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSBVSS1Sb3V0ZXIgaGFzIGJvb3RzdHJhcHBlZC5cbiAgICAgICAgICogSXQgd2lsbCBzdG9wIFVJLVJvdXRlciBmcm9tIHBlcmZvcm1pbmcgdGhlIGluaXRpYWwgdXJsIHN5bmMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBwZXJmb3JtIHNvbWUgYXN5bmNocm9ub3VzIGluaXRpYWxpemF0aW9uIGJlZm9yZSB0aGUgcm91dGVyIHN0YXJ0cy5cbiAgICAgICAgICogT25jZSB0aGUgaW5pdGlhbGl6YXRpb24gaXMgY29tcGxldGUsIGNhbGwgW1tsaXN0ZW5dXSB0byB0ZWxsIFVJLVJvdXRlciB0byBzdGFydCB3YXRjaGluZyBhbmQgc3luY2hyb25pemluZyB0aGUgVVJMLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgICAgICAgKiAgIC8vIFByZXZlbnQgJHVybFJvdXRlciBmcm9tIGF1dG9tYXRpY2FsbHkgaW50ZXJjZXB0aW5nIFVSTCBjaGFuZ2VzO1xuICAgICAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5kZWZlckludGVyY2VwdCgpO1xuICAgICAgICAgKiB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiBhcHAucnVuKGZ1bmN0aW9uIChNeVNlcnZpY2UsICR1cmxSb3V0ZXIsICRodHRwKSB7XG4gICAgICAgICAqICAgJGh0dHAuZ2V0KFwiL3N0dWZmXCIpLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgKiAgICAgTXlTZXJ2aWNlLmRvU3R1ZmYocmVzcC5kYXRhKTtcbiAgICAgICAgICogICAgICR1cmxSb3V0ZXIubGlzdGVuKCk7XG4gICAgICAgICAqICAgICAkdXJsUm91dGVyLnN5bmMoKTtcbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGVmZXIgSW5kaWNhdGVzIHdoZXRoZXIgdG8gZGVmZXIgbG9jYXRpb24gY2hhbmdlIGludGVyY2VwdGlvbi5cbiAgICAgICAgICogICAgICAgIFBhc3Npbmcgbm8gcGFyYW1ldGVyIGlzIGVxdWl2YWxlbnQgdG8gYHRydWVgLlxuICAgICAgICAgKi9cbiAgICAgICAgVXJsUm91dGVyUHJvdmlkZXIucHJvdG90eXBlLmRlZmVySW50ZXJjZXB0ID0gZnVuY3Rpb24gKGRlZmVyKSB7XG4gICAgICAgICAgICB0aGlzLl91cmxSb3V0ZXIuZGVmZXJJbnRlcmNlcHQoZGVmZXIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVXJsUm91dGVyUHJvdmlkZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqICMgQW5ndWxhciAxIHR5cGVzXG4gICAgICpcbiAgICAgKiBVSS1Sb3V0ZXIgY29yZSBwcm92aWRlcyB2YXJpb3VzIFR5cGVzY3JpcHQgdHlwZXMgd2hpY2ggeW91IGNhbiB1c2UgZm9yIGNvZGUgY29tcGxldGlvbiBhbmQgdmFsaWRhdGluZyBwYXJhbWV0ZXIgdmFsdWVzLCBldGMuXG4gICAgICogVGhlIGN1c3RvbWl6YXRpb25zIHRvIHRoZSBjb3JlIHR5cGVzIGZvciBBbmd1bGFyIFVJLVJvdXRlciBhcmUgZG9jdW1lbnRlZCBoZXJlLlxuICAgICAqXG4gICAgICogVGhlIG9wdGlvbmFsIFtbJHJlc29sdmVdXSBzZXJ2aWNlIGlzIGFsc28gZG9jdW1lbnRlZCBoZXJlLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBuZzFcbiAgICAgKiBAcHJlZmVycmVkXG4gICAgICovXG4gICAgbmcubW9kdWxlKCd1aS5yb3V0ZXIuYW5ndWxhcjEnLCBbXSk7XG4gICAgdmFyIG1vZF9pbml0ID0gbmcubW9kdWxlKCd1aS5yb3V0ZXIuaW5pdCcsIFtdKTtcbiAgICB2YXIgbW9kX3V0aWwgPSBuZy5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJywgWyduZycsICd1aS5yb3V0ZXIuaW5pdCddKTtcbiAgICB2YXIgbW9kX3J0ciA9IG5nLm1vZHVsZSgndWkucm91dGVyLnJvdXRlcicsIFsndWkucm91dGVyLnV0aWwnXSk7XG4gICAgdmFyIG1vZF9zdGF0ZSA9IG5nLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJywgWyd1aS5yb3V0ZXIucm91dGVyJywgJ3VpLnJvdXRlci51dGlsJywgJ3VpLnJvdXRlci5hbmd1bGFyMSddKTtcbiAgICB2YXIgbW9kX21haW4gPSBuZy5tb2R1bGUoJ3VpLnJvdXRlcicsIFsndWkucm91dGVyLmluaXQnLCAndWkucm91dGVyLnN0YXRlJywgJ3VpLnJvdXRlci5hbmd1bGFyMSddKTtcbiAgICB2YXIgbW9kX2NtcHQgPSBuZy5tb2R1bGUoJ3VpLnJvdXRlci5jb21wYXQnLCBbJ3VpLnJvdXRlciddKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgIHZhciByb3V0ZXIgPSBudWxsO1xuICAgICR1aVJvdXRlclByb3ZpZGVyLiRpbmplY3QgPSBbJyRsb2NhdGlvblByb3ZpZGVyJ107XG4gICAgLyoqIFRoaXMgYW5ndWxhciAxIHByb3ZpZGVyIGluc3RhbnRpYXRlcyBhIFJvdXRlciBhbmQgZXhwb3NlcyBpdHMgc2VydmljZXMgdmlhIHRoZSBhbmd1bGFyIGluamVjdG9yICovXG4gICAgZnVuY3Rpb24gJHVpUm91dGVyUHJvdmlkZXIoJGxvY2F0aW9uUHJvdmlkZXIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBSb3V0ZXIgd2hlbiB0aGUgJHVpUm91dGVyUHJvdmlkZXIgaXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgcm91dGVyID0gdGhpcy5yb3V0ZXIgPSBuZXcgY29yZS5VSVJvdXRlcigpO1xuICAgICAgICByb3V0ZXIuc3RhdGVQcm92aWRlciA9IG5ldyBTdGF0ZVByb3ZpZGVyKHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LCByb3V0ZXIuc3RhdGVTZXJ2aWNlKTtcbiAgICAgICAgLy8gQXBwbHkgbmcxIHNwZWNpZmljIFN0YXRlQnVpbGRlciBjb2RlIGZvciBgdmlld3NgLCBgcmVzb2x2ZWAsIGFuZCBgb25FeGl0L1JldGFpbi9FbnRlcmAgcHJvcGVydGllc1xuICAgICAgICByb3V0ZXIuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IoJ3ZpZXdzJywgbmcxVmlld3NCdWlsZGVyKTtcbiAgICAgICAgcm91dGVyLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKCdvbkV4aXQnLCBnZXRTdGF0ZUhvb2tCdWlsZGVyKCdvbkV4aXQnKSk7XG4gICAgICAgIHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcignb25SZXRhaW4nLCBnZXRTdGF0ZUhvb2tCdWlsZGVyKCdvblJldGFpbicpKTtcbiAgICAgICAgcm91dGVyLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKCdvbkVudGVyJywgZ2V0U3RhdGVIb29rQnVpbGRlcignb25FbnRlcicpKTtcbiAgICAgICAgcm91dGVyLnZpZXdTZXJ2aWNlLl9wbHVnaW5hcGkuX3ZpZXdDb25maWdGYWN0b3J5KCduZzEnLCBnZXROZzFWaWV3Q29uZmlnRmFjdG9yeSgpKTtcbiAgICAgICAgdmFyIG5nMUxvY2F0aW9uU2VydmljZSA9IChyb3V0ZXIubG9jYXRpb25TZXJ2aWNlID0gcm91dGVyLmxvY2F0aW9uQ29uZmlnID0gbmV3IE5nMUxvY2F0aW9uU2VydmljZXMoJGxvY2F0aW9uUHJvdmlkZXIpKTtcbiAgICAgICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5tb25rZXlQYXRjaFBhdGhQYXJhbWV0ZXJUeXBlKHJvdXRlcik7XG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQ6IGFsc28gZXhwb3NlIHJvdXRlciBpbnN0YW5jZSBhcyAkdWlSb3V0ZXJQcm92aWRlci5yb3V0ZXJcbiAgICAgICAgcm91dGVyWydyb3V0ZXInXSA9IHJvdXRlcjtcbiAgICAgICAgcm91dGVyWyckZ2V0J10gPSAkZ2V0O1xuICAgICAgICAkZ2V0LiRpbmplY3QgPSBbJyRsb2NhdGlvbicsICckYnJvd3NlcicsICckc25pZmZlcicsICckcm9vdFNjb3BlJywgJyRodHRwJywgJyR0ZW1wbGF0ZUNhY2hlJ107XG4gICAgICAgIGZ1bmN0aW9uICRnZXQoJGxvY2F0aW9uLCAkYnJvd3NlciwgJHNuaWZmZXIsICRyb290U2NvcGUsICRodHRwLCAkdGVtcGxhdGVDYWNoZSkge1xuICAgICAgICAgICAgbmcxTG9jYXRpb25TZXJ2aWNlLl9ydW50aW1lU2VydmljZXMoJHJvb3RTY29wZSwgJGxvY2F0aW9uLCAkc25pZmZlciwgJGJyb3dzZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHJvdXRlclsncm91dGVyJ107XG4gICAgICAgICAgICBkZWxldGUgcm91dGVyWyckZ2V0J107XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfVxuICAgIHZhciBnZXRQcm92aWRlckZvciA9IGZ1bmN0aW9uIChzZXJ2aWNlTmFtZSkgeyByZXR1cm4gW1xuICAgICAgICAnJHVpUm91dGVyUHJvdmlkZXInLFxuICAgICAgICBmdW5jdGlvbiAoJHVycCkge1xuICAgICAgICAgICAgdmFyIHNlcnZpY2UgPSAkdXJwLnJvdXRlcltzZXJ2aWNlTmFtZV07XG4gICAgICAgICAgICBzZXJ2aWNlWyckZ2V0J10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2aWNlOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgICAgIH0sXG4gICAgXTsgfTtcbiAgICAvLyBUaGlzIGVmZmVjdGl2ZWx5IGNhbGxzICRnZXQoKSBvbiBgJHVpUm91dGVyUHJvdmlkZXJgIHRvIHRyaWdnZXIgaW5pdCAod2hlbiBuZyBlbnRlcnMgcnVudGltZSlcbiAgICBydW5CbG9jay4kaW5qZWN0ID0gWyckaW5qZWN0b3InLCAnJHEnLCAnJHVpUm91dGVyJ107XG4gICAgZnVuY3Rpb24gcnVuQmxvY2soJGluamVjdG9yLCAkcSwgJHVpUm91dGVyKSB7XG4gICAgICAgIGNvcmUuc2VydmljZXMuJGluamVjdG9yID0gJGluamVjdG9yO1xuICAgICAgICBjb3JlLnNlcnZpY2VzLiRxID0gJHE7XG4gICAgICAgIC8vIFRoZSAkaW5qZWN0b3IgaXMgbm93IGF2YWlsYWJsZS5cbiAgICAgICAgLy8gRmluZCBhbnkgcmVzb2x2YWJsZXMgdGhhdCBoYWQgZGVwZW5kZW5jeSBhbm5vdGF0aW9uIGRlZmVycmVkXG4gICAgICAgICR1aVJvdXRlci5zdGF0ZVJlZ2lzdHJ5XG4gICAgICAgICAgICAuZ2V0KClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguJCRzdGF0ZSgpLnJlc29sdmFibGVzOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShjb3JlLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kZXBzID09PSAnZGVmZXJyZWQnOyB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmFibGUpIHsgcmV0dXJuIChyZXNvbHZhYmxlLmRlcHMgPSAkaW5qZWN0b3IuYW5ub3RhdGUocmVzb2x2YWJsZS5yZXNvbHZlRm4sICRpbmplY3Rvci5zdHJpY3REaSkpOyB9KTtcbiAgICB9XG4gICAgLy8gJHVybFJvdXRlciBzZXJ2aWNlIGFuZCAkdXJsUm91dGVyUHJvdmlkZXJcbiAgICB2YXIgZ2V0VXJsUm91dGVyUHJvdmlkZXIgPSBmdW5jdGlvbiAodWlSb3V0ZXIpIHsgcmV0dXJuICh1aVJvdXRlci51cmxSb3V0ZXJQcm92aWRlciA9IG5ldyBVcmxSb3V0ZXJQcm92aWRlcih1aVJvdXRlcikpOyB9O1xuICAgIC8vICRzdGF0ZSBzZXJ2aWNlIGFuZCAkc3RhdGVQcm92aWRlclxuICAgIC8vICR1cmxSb3V0ZXIgc2VydmljZSBhbmQgJHVybFJvdXRlclByb3ZpZGVyXG4gICAgdmFyIGdldFN0YXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlLmV4dGVuZChyb3V0ZXIuc3RhdGVQcm92aWRlciwgeyAkZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIuc3RhdGVTZXJ2aWNlOyB9IH0pOyB9O1xuICAgIHdhdGNoRGlnZXN0cy4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJ107XG4gICAgZnVuY3Rpb24gd2F0Y2hEaWdlc3RzKCRyb290U2NvcGUpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29yZS50cmFjZS5hcHByb3hpbWF0ZURpZ2VzdHMrKztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1vZF9pbml0LnByb3ZpZGVyKCckdWlSb3V0ZXInLCAkdWlSb3V0ZXJQcm92aWRlcik7XG4gICAgbW9kX3J0ci5wcm92aWRlcignJHVybFJvdXRlcicsIFsnJHVpUm91dGVyUHJvdmlkZXInLCBnZXRVcmxSb3V0ZXJQcm92aWRlcl0pO1xuICAgIG1vZF91dGlsLnByb3ZpZGVyKCckdXJsU2VydmljZScsIGdldFByb3ZpZGVyRm9yKCd1cmxTZXJ2aWNlJykpO1xuICAgIG1vZF91dGlsLnByb3ZpZGVyKCckdXJsTWF0Y2hlckZhY3RvcnknLCBbJyR1aVJvdXRlclByb3ZpZGVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5OyB9XSk7XG4gICAgbW9kX3V0aWwucHJvdmlkZXIoJyR0ZW1wbGF0ZUZhY3RvcnknLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgVGVtcGxhdGVGYWN0b3J5KCk7IH0pO1xuICAgIG1vZF9zdGF0ZS5wcm92aWRlcignJHN0YXRlUmVnaXN0cnknLCBnZXRQcm92aWRlckZvcignc3RhdGVSZWdpc3RyeScpKTtcbiAgICBtb2Rfc3RhdGUucHJvdmlkZXIoJyR1aVJvdXRlckdsb2JhbHMnLCBnZXRQcm92aWRlckZvcignZ2xvYmFscycpKTtcbiAgICBtb2Rfc3RhdGUucHJvdmlkZXIoJyR0cmFuc2l0aW9ucycsIGdldFByb3ZpZGVyRm9yKCd0cmFuc2l0aW9uU2VydmljZScpKTtcbiAgICBtb2Rfc3RhdGUucHJvdmlkZXIoJyRzdGF0ZScsIFsnJHVpUm91dGVyUHJvdmlkZXInLCBnZXRTdGF0ZVByb3ZpZGVyXSk7XG4gICAgbW9kX3N0YXRlLmZhY3RvcnkoJyRzdGF0ZVBhcmFtcycsIFsnJHVpUm91dGVyJywgZnVuY3Rpb24gKCR1aVJvdXRlcikgeyByZXR1cm4gJHVpUm91dGVyLmdsb2JhbHMucGFyYW1zOyB9XSk7XG4gICAgbW9kX21haW4uZmFjdG9yeSgnJHZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIudmlld1NlcnZpY2U7IH0pO1xuICAgIG1vZF9tYWluLnNlcnZpY2UoJyR0cmFjZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmUudHJhY2U7IH0pO1xuICAgIG1vZF9tYWluLnJ1bih3YXRjaERpZ2VzdHMpO1xuICAgIG1vZF91dGlsLnJ1bihbJyR1cmxNYXRjaGVyRmFjdG9yeScsIGZ1bmN0aW9uICgkdXJsTWF0Y2hlckZhY3RvcnkpIHsgfV0pO1xuICAgIG1vZF9zdGF0ZS5ydW4oWyckc3RhdGUnLCBmdW5jdGlvbiAoJHN0YXRlKSB7IH1dKTtcbiAgICBtb2RfcnRyLnJ1bihbJyR1cmxSb3V0ZXInLCBmdW5jdGlvbiAoJHVybFJvdXRlcikgeyB9XSk7XG4gICAgbW9kX2luaXQucnVuKHJ1bkJsb2NrKTtcbiAgICAvKiogQGhpZGRlbiBUT0RPOiBmaW5kIGEgcGxhY2UgdG8gbW92ZSB0aGlzICovXG4gICAgdmFyIGdldExvY2FscyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGN0eC5nZXRUb2tlbnMoKS5maWx0ZXIoY29yZS5pc1N0cmluZyk7XG4gICAgICAgIHZhciB0dXBsZXMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZhYmxlID0gY3R4LmdldFJlc29sdmFibGUoa2V5KTtcbiAgICAgICAgICAgIHZhciB3YWl0UG9saWN5ID0gY3R4LmdldFBvbGljeShyZXNvbHZhYmxlKS5hc3luYztcbiAgICAgICAgICAgIHJldHVybiBba2V5LCB3YWl0UG9saWN5ID09PSAnTk9XQUlUJyA/IHJlc29sdmFibGUucHJvbWlzZSA6IHJlc29sdmFibGUuZGF0YV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHVwbGVzLnJlZHVjZShjb3JlLmFwcGx5UGFpcnMsIHt9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgKG9yIHBlbmRpbmcpIFN0YXRlIFBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEFuIGluamVjdGFibGUgZ2xvYmFsICoqU2VydmljZSBPYmplY3QqKiB3aGljaCBob2xkcyB0aGUgc3RhdGUgcGFyYW1ldGVycyBmb3IgdGhlIGxhdGVzdCAqKlNVQ0NFU1NGVUwqKiB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogVGhlIHZhbHVlcyBhcmUgbm90IHVwZGF0ZWQgdW50aWwgKmFmdGVyKiBhIGBUcmFuc2l0aW9uYCBzdWNjZXNzZnVsbHkgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogKipBbHNvOioqIGFuIGluamVjdGFibGUgKipQZXItVHJhbnNpdGlvbiBPYmplY3QqKiBvYmplY3Qgd2hpY2ggaG9sZHMgdGhlIHBlbmRpbmcgc3RhdGUgcGFyYW1ldGVycyBmb3IgdGhlIHBlbmRpbmcgYFRyYW5zaXRpb25gIGN1cnJlbnRseSBydW5uaW5nLlxuICAgICAqXG4gICAgICogIyMjIERlcHJlY2F0aW9uIHdhcm5pbmc6XG4gICAgICpcbiAgICAgKiBUaGUgdmFsdWUgaW5qZWN0ZWQgZm9yIGAkc3RhdGVQYXJhbXNgIGlzIGRpZmZlcmVudCBkZXBlbmRpbmcgb24gd2hlcmUgaXQgaXMgaW5qZWN0ZWQuXG4gICAgICpcbiAgICAgKiAtIFdoZW4gaW5qZWN0ZWQgaW50byBhbiBhbmd1bGFyIHNlcnZpY2UsIHRoZSBvYmplY3QgaW5qZWN0ZWQgaXMgdGhlIGdsb2JhbCAqKlNlcnZpY2UgT2JqZWN0Kiogd2l0aCB0aGUgcGFyYW1ldGVyIHZhbHVlcyBmb3IgdGhlIGxhdGVzdCBzdWNjZXNzZnVsIGBUcmFuc2l0aW9uYC5cbiAgICAgKiAtIFdoZW4gaW5qZWN0ZWQgaW50byB0cmFuc2l0aW9uIGhvb2tzLCByZXNvbHZlcywgb3IgdmlldyBjb250cm9sbGVycywgdGhlIG9iamVjdCBpcyB0aGUgKipQZXItVHJhbnNpdGlvbiBPYmplY3QqKiB3aXRoIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGZvciB0aGUgcnVubmluZyBgVHJhbnNpdGlvbmAuXG4gICAgICpcbiAgICAgKiBCZWNhdXNlIG9mIHRoZXNlIGNvbmZ1c2luZyBkZXRhaWxzLCB0aGlzIHNlcnZpY2UgaXMgZGVwcmVjYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBJbnN0ZWFkIG9mIHVzaW5nIHRoZSBnbG9iYWwgYCRzdGF0ZVBhcmFtc2Agc2VydmljZSBvYmplY3QsXG4gICAgICogaW5qZWN0IFtbJHVpUm91dGVyR2xvYmFsc11dIGFuZCB1c2UgW1tVSVJvdXRlckdsb2JhbHMucGFyYW1zXV1cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogTXlTZXJ2aWNlLiRpbmplY3QgPSBbJyR1aVJvdXRlckdsb2JhbHMnXTtcbiAgICAgKiBmdW5jdGlvbiBNeVNlcnZpY2UoJHVpUm91dGVyR2xvYmFscykge1xuICAgICAqICAgcmV0dXJuIHtcbiAgICAgKiAgICAgcGFyYW1WYWx1ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgICAgICByZXR1cm4gJHVpUm91dGVyR2xvYmFscy5wYXJhbXM7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgSW5zdGVhZCBvZiB1c2luZyB0aGUgcGVyLXRyYW5zaXRpb24gYCRzdGF0ZVBhcmFtc2Agb2JqZWN0LFxuICAgICAqIGluamVjdCB0aGUgY3VycmVudCBgVHJhbnNpdGlvbmAgKGFzIFtbJHRyYW5zaXRpb24kXV0pIGFuZCB1c2UgW1tUcmFuc2l0aW9uLnBhcmFtc11dXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIE15Q29udHJvbGxlci4kaW5qZWN0ID0gWyckdHJhbnNpdGlvbiQnXTtcbiAgICAgKiBmdW5jdGlvbiBNeUNvbnRyb2xsZXIoJHRyYW5zaXRpb24kKSB7XG4gICAgICogICB2YXIgdXNlcm5hbWUgPSAkdHJhbnNpdGlvbiQucGFyYW1zKCkudXNlcm5hbWU7XG4gICAgICogICAvLyAuLiBkbyBzb21ldGhpbmcgd2l0aCB1c2VybmFtZVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqXG4gICAgICogVGhpcyBvYmplY3QgY2FuIGJlIGluamVjdGVkIGludG8gb3RoZXIgc2VydmljZXMuXG4gICAgICpcbiAgICAgKiAjIyMjIERlcHJlY2F0ZWQgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIFNvbWVTZXJ2aWNlLiRpbmplY3QgPSBbJyRodHRwJywgJyRzdGF0ZVBhcmFtcyddO1xuICAgICAqIGZ1bmN0aW9uIFNvbWVTZXJ2aWNlKCRodHRwLCAkc3RhdGVQYXJhbXMpIHtcbiAgICAgKiAgIHJldHVybiB7XG4gICAgICogICAgIGdldFVzZXI6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgIHJldHVybiAkaHR0cC5nZXQoJy9hcGkvdXNlcnMvJyArICRzdGF0ZVBhcmFtcy51c2VybmFtZSk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqIGFuZ3VsYXIuc2VydmljZSgnU29tZVNlcnZpY2UnLCBTb21lU2VydmljZSk7XG4gICAgICogYGBgXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqICMgQW5ndWxhciAxIERpcmVjdGl2ZXNcbiAgICAgKlxuICAgICAqIFRoZXNlIGFyZSB0aGUgZGlyZWN0aXZlcyBpbmNsdWRlZCBpbiBVSS1Sb3V0ZXIgZm9yIEFuZ3VsYXIgMS5cbiAgICAgKiBUaGVzZSBkaXJlY3RpdmVzIGFyZSB1c2VkIGluIHRlbXBsYXRlcyB0byBjcmVhdGUgdmlld3BvcnRzIGFuZCBsaW5rL25hdmlnYXRlIHRvIHN0YXRlcy5cbiAgICAgKlxuICAgICAqIEBuZzFhcGlcbiAgICAgKiBAcHJlZmVycmVkXG4gICAgICogQG1vZHVsZSBkaXJlY3RpdmVzXG4gICAgICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZnVuY3Rpb24gcGFyc2VTdGF0ZVJlZihyZWYpIHtcbiAgICAgICAgdmFyIHBhcnNlZDtcbiAgICAgICAgdmFyIHBhcmFtc09ubHkgPSByZWYubWF0Y2goL15cXHMqKHtbXn1dKn0pXFxzKiQvKTtcbiAgICAgICAgaWYgKHBhcmFtc09ubHkpXG4gICAgICAgICAgICByZWYgPSAnKCcgKyBwYXJhbXNPbmx5WzFdICsgJyknO1xuICAgICAgICBwYXJzZWQgPSByZWYucmVwbGFjZSgvXFxuL2csICcgJykubWF0Y2goL15cXHMqKFteKF0qPylcXHMqKFxcKCguKilcXCkpP1xccyokLyk7XG4gICAgICAgIGlmICghcGFyc2VkIHx8IHBhcnNlZC5sZW5ndGggIT09IDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIHJlZiAnXCIgKyByZWYgKyBcIidcIik7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBwYXJzZWRbMV0gfHwgbnVsbCwgcGFyYW1FeHByOiBwYXJzZWRbM10gfHwgbnVsbCB9O1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIHN0YXRlQ29udGV4dChlbCkge1xuICAgICAgICB2YXIgJHVpVmlldyA9IGVsLnBhcmVudCgpLmluaGVyaXRlZERhdGEoJyR1aVZpZXcnKTtcbiAgICAgICAgdmFyIHBhdGggPSBjb3JlLnBhcnNlKCckY2ZnLnBhdGgnKSgkdWlWaWV3KTtcbiAgICAgICAgcmV0dXJuIHBhdGggPyBjb3JlLnRhaWwocGF0aCkuc3RhdGUubmFtZSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzZWREZWYoJHN0YXRlLCAkZWxlbWVudCwgZGVmKSB7XG4gICAgICAgIHZhciB1aVN0YXRlID0gZGVmLnVpU3RhdGUgfHwgJHN0YXRlLmN1cnJlbnQubmFtZTtcbiAgICAgICAgdmFyIHVpU3RhdGVPcHRzID0gY29yZS5leHRlbmQoZGVmYXVsdE9wdHMoJGVsZW1lbnQsICRzdGF0ZSksIGRlZi51aVN0YXRlT3B0cyB8fCB7fSk7XG4gICAgICAgIHZhciBocmVmID0gJHN0YXRlLmhyZWYodWlTdGF0ZSwgZGVmLnVpU3RhdGVQYXJhbXMsIHVpU3RhdGVPcHRzKTtcbiAgICAgICAgcmV0dXJuIHsgdWlTdGF0ZTogdWlTdGF0ZSwgdWlTdGF0ZVBhcmFtczogZGVmLnVpU3RhdGVQYXJhbXMsIHVpU3RhdGVPcHRzOiB1aVN0YXRlT3B0cywgaHJlZjogaHJlZiB9O1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIGdldFR5cGVJbmZvKGVsKSB7XG4gICAgICAgIC8vIFNWR0FFbGVtZW50IGRvZXMgbm90IHVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUsIGJ1dCByYXRoZXIgdGhlICd4bGlua0hyZWYnIGF0dHJpYnV0ZS5cbiAgICAgICAgdmFyIGlzU3ZnID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsLnByb3AoJ2hyZWYnKSkgPT09ICdbb2JqZWN0IFNWR0FuaW1hdGVkU3RyaW5nXSc7XG4gICAgICAgIHZhciBpc0Zvcm0gPSBlbFswXS5ub2RlTmFtZSA9PT0gJ0ZPUk0nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cjogaXNGb3JtID8gJ2FjdGlvbicgOiBpc1N2ZyA/ICd4bGluazpocmVmJyA6ICdocmVmJyxcbiAgICAgICAgICAgIGlzQW5jaG9yOiBlbC5wcm9wKCd0YWdOYW1lJykudG9VcHBlckNhc2UoKSA9PT0gJ0EnLFxuICAgICAgICAgICAgY2xpY2thYmxlOiAhaXNGb3JtLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIGNsaWNrSG9vayhlbCwgJHN0YXRlLCAkdGltZW91dCwgdHlwZSwgZ2V0RGVmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGUud2hpY2ggfHwgZS5idXR0b24sIHRhcmdldCA9IGdldERlZigpO1xuICAgICAgICAgICAgaWYgKCEoYnV0dG9uID4gMSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkgfHwgZWwuYXR0cigndGFyZ2V0JykpKSB7XG4gICAgICAgICAgICAgICAgLy8gSEFDSzogVGhpcyBpcyB0byBhbGxvdyBuZy1jbGlja3MgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBpcyBpbml0aWF0ZWQ6XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25fMSA9ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKHRhcmdldC51aVN0YXRlLCB0YXJnZXQudWlTdGF0ZVBhcmFtcywgdGFyZ2V0LnVpU3RhdGVPcHRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXRlIGhhcyBubyBVUkwsIGlnbm9yZSBvbmUgcHJldmVudERlZmF1bHQgZnJvbSB0aGUgPGE+IGRpcmVjdGl2ZS5cbiAgICAgICAgICAgICAgICB2YXIgaWdub3JlUHJldmVudERlZmF1bHRDb3VudF8xID0gdHlwZS5pc0FuY2hvciAmJiAhdGFyZ2V0LmhyZWYgPyAxIDogMDtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlUHJldmVudERlZmF1bHRDb3VudF8xLS0gPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0cmFuc2l0aW9uXzEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdE9wdHMoZWwsICRzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVsYXRpdmU6IHN0YXRlQ29udGV4dChlbCkgfHwgJHN0YXRlLiRjdXJyZW50LFxuICAgICAgICAgICAgaW5oZXJpdDogdHJ1ZSxcbiAgICAgICAgICAgIHNvdXJjZTogJ3NyZWYnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMoZWxlbWVudCwgc2NvcGUsIGhvb2tGbiwgdWlTdGF0ZU9wdHMpIHtcbiAgICAgICAgdmFyIGV2ZW50cztcbiAgICAgICAgaWYgKHVpU3RhdGVPcHRzKSB7XG4gICAgICAgICAgICBldmVudHMgPSB1aVN0YXRlT3B0cy5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb3JlLmlzQXJyYXkoZXZlbnRzKSkge1xuICAgICAgICAgICAgZXZlbnRzID0gWydjbGljayddO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbiA9IGVsZW1lbnQub24gPyAnb24nIDogJ2JpbmQnO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGV2ZW50c18xID0gZXZlbnRzOyBfaSA8IGV2ZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSBldmVudHNfMVtfaV07XG4gICAgICAgICAgICBlbGVtZW50W29uXShldmVudF8xLCBob29rRm4pO1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2ZmID0gZWxlbWVudC5vZmYgPyAnb2ZmJyA6ICd1bmJpbmQnO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBldmVudHNfMiA9IGV2ZW50czsgX2kgPCBldmVudHNfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMiA9IGV2ZW50c18yW19pXTtcbiAgICAgICAgICAgICAgICBlbGVtZW50W29mZl0oZXZlbnRfMiwgaG9va0ZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB1aS1zcmVmYDogQSBkaXJlY3RpdmUgZm9yIGxpbmtpbmcgdG8gYSBzdGF0ZVxuICAgICAqXG4gICAgICogQSBkaXJlY3RpdmUgd2hpY2ggbGlua3MgdG8gYSBzdGF0ZSAoYW5kIG9wdGlvbmFsbHksIHBhcmFtZXRlcnMpLlxuICAgICAqIFdoZW4gY2xpY2tlZCwgdGhpcyBkaXJlY3RpdmUgYWN0aXZhdGVzIHRoZSBsaW5rZWQgc3RhdGUgd2l0aCB0aGUgc3VwcGxpZWQgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICMjIyBMaW5rZWQgU3RhdGVcbiAgICAgKiBUaGUgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBgdWktc3JlZmAgaXMgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIGxpbmsgdG8uXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogVGhpcyB3aWxsIGFjdGl2YXRlIHRoZSBgaG9tZWAgc3RhdGUgd2hlbiB0aGUgbGluayBpcyBjbGlja2VkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YSB1aS1zcmVmPVwiaG9tZVwiPkhvbWU8L2E+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgUmVsYXRpdmUgTGlua3NcbiAgICAgKiBZb3UgY2FuIGFsc28gdXNlIHJlbGF0aXZlIHN0YXRlIHBhdGhzIHdpdGhpbiBgdWktc3JlZmAsIGp1c3QgbGlrZSBhIHJlbGF0aXZlIHBhdGggcGFzc2VkIHRvIGAkc3RhdGUuZ28oKWAgKFtbU3RhdGVTZXJ2aWNlLmdvXV0pLlxuICAgICAqIFlvdSBqdXN0IG5lZWQgdG8gYmUgYXdhcmUgdGhhdCB0aGUgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgc3RhdGUgdGhhdCAqY3JlYXRlZCogdGhlIGxpbmsuXG4gICAgICogVGhpcyBhbGxvd3MgYSBzdGF0ZSB0byBjcmVhdGUgYSByZWxhdGl2ZSBgdWktc3JlZmAgd2hpY2ggYWx3YXlzIHRhcmdldHMgdGhlIHNhbWUgZGVzdGluYXRpb24uXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogQm90aCB0aGVzZSBsaW5rcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCBzdGF0ZSwgZXZlbiB3aGVuIGEgY2hpbGQgc3RhdGUgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGEgdWktc3JlZj1cIi5jaGlsZDFcIj5jaGlsZCAxIHN0YXRlPC9hPlxuICAgICAqIDxhIHVpLXNyZWY9XCIuY2hpbGQyXCI+Y2hpbGQgMiBzdGF0ZTwvYT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoaXMgbGluayBhY3RpdmF0ZXMgdGhlIHBhcmVudCBzdGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGEgdWktc3JlZj1cIl5cIj5SZXR1cm48L2E+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgaHJlZnNcbiAgICAgKiBJZiB0aGUgbGlua2VkIHN0YXRlIGhhcyBhIFVSTCwgdGhlIGRpcmVjdGl2ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYW5kXG4gICAgICogdXBkYXRlIHRoZSBgaHJlZmAgYXR0cmlidXRlICh1c2luZyB0aGUgW1tTdGF0ZVNlcnZpY2UuaHJlZl1dICBtZXRob2QpLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIEFzc3VtaW5nIHRoZSBgdXNlcnNgIHN0YXRlIGhhcyBhIHVybCBvZiBgL3VzZXJzL2BcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGEgdWktc3JlZj1cInVzZXJzXCIgaHJlZj1cIi91c2Vycy9cIj5Vc2VyczwvYT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBQYXJhbWV0ZXIgVmFsdWVzXG4gICAgICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YXRlIG5hbWUsIGEgYHVpLXNyZWZgIGNhbiBpbmNsdWRlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggYXJlIGFwcGxpZWQgd2hlbiBhY3RpdmF0aW5nIHRoZSBzdGF0ZS5cbiAgICAgKiBQYXJhbSB2YWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBgdWktc3JlZmAgdmFsdWUgYWZ0ZXIgdGhlIHN0YXRlIG5hbWUsIGVuY2xvc2VkIGJ5IHBhcmVudGhlc2VzLlxuICAgICAqIFRoZSBjb250ZW50IGluc2lkZSB0aGUgcGFyZW50aGVzZXMgaXMgYW4gZXhwcmVzc2lvbiwgZXZhbHVhdGVkIHRvIHRoZSBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIFRoaXMgZXhhbXBsZSByZW5kZXJzIGEgbGlzdCBvZiBsaW5rcyB0byB1c2Vycy5cbiAgICAgKiBUaGUgc3RhdGUncyBgdXNlcklkYCBwYXJhbWV0ZXIgdmFsdWUgY29tZXMgZnJvbSBlYWNoIHVzZXIncyBgdXNlci5pZGAgcHJvcGVydHkuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxsaSBuZy1yZXBlYXQ9XCJ1c2VyIGluIHVzZXJzXCI+XG4gICAgICogICA8YSB1aS1zcmVmPVwidXNlcnMuZGV0YWlsKHsgdXNlcklkOiB1c2VyLmlkIH0pXCI+e3sgdXNlci5kaXNwbGF5TmFtZSB9fTwvYT5cbiAgICAgKiA8L2xpPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTm90ZTpcbiAgICAgKiBUaGUgcGFyYW1ldGVyIHZhbHVlcyBleHByZXNzaW9uIGlzIGAkd2F0Y2hgZWQgZm9yIHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiAjIyMgVHJhbnNpdGlvbiBPcHRpb25zXG4gICAgICogWW91IGNhbiBzcGVjaWZ5IFtbVHJhbnNpdGlvbk9wdGlvbnNdXSB0byBwYXNzIHRvIFtbU3RhdGVTZXJ2aWNlLmdvXV0gYnkgdXNpbmcgdGhlIGB1aS1zcmVmLW9wdHNgIGF0dHJpYnV0ZS5cbiAgICAgKiBPcHRpb25zIGFyZSByZXN0cmljdGVkIHRvIGBsb2NhdGlvbmAsIGBpbmhlcml0YCwgYW5kIGByZWxvYWRgLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YSB1aS1zcmVmPVwiaG9tZVwiIHVpLXNyZWYtb3B0cz1cInsgcmVsb2FkOiB0cnVlIH1cIj5Ib21lPC9hPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIE90aGVyIERPTSBFdmVudHNcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBjdXN0b21pemUgd2hpY2ggRE9NIGV2ZW50cyB0byByZXNwb25kIHRvIChpbnN0ZWFkIG9mIGBjbGlja2ApIGJ5XG4gICAgICogcHJvdmlkaW5nIGFuIGBldmVudHNgIGFycmF5IGluIHRoZSBgdWktc3JlZi1vcHRzYCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpbnB1dCB0eXBlPVwidGV4dFwiIHVpLXNyZWY9XCJjb250YWN0c1wiIHVpLXNyZWYtb3B0cz1cInsgZXZlbnRzOiBbJ2NoYW5nZScsICdibHVyJ10gfVwiPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEhpZ2hsaWdodGluZyB0aGUgYWN0aXZlIGxpbmtcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFtbdWlTcmVmQWN0aXZlXV0gdG8gaGlnaGxpZ2h0IHRoZSBhY3RpdmUgbGluay5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlc1xuICAgICAqIElmIHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGU6XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGEgdWktc3JlZj1cImhvbWVcIj5Ib21lPC9hPlxuICAgICAqIDxhIHVpLXNyZWY9XCJhYm91dFwiPkFib3V0PC9hPlxuICAgICAqIDxhIHVpLXNyZWY9XCJ7cGFnZTogMn1cIj5OZXh0IHBhZ2U8L2E+XG4gICAgICpcbiAgICAgKiA8dWw+XG4gICAgICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gICAgICogICAgICAgICA8YSB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj57eyBjb250YWN0Lm5hbWUgfX08L2E+XG4gICAgICogICAgIDwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZW4gKGFzc3VtaW5nIHRoZSBjdXJyZW50IHN0YXRlIGlzIGBjb250YWN0c2ApIHRoZSByZW5kZXJlZCBodG1sIGluY2x1ZGluZyBocmVmcyB3b3VsZCBiZTpcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YSBocmVmPVwiIy9ob21lXCIgdWktc3JlZj1cImhvbWVcIj5Ib21lPC9hPlxuICAgICAqIDxhIGhyZWY9XCIjL2Fib3V0XCIgdWktc3JlZj1cImFib3V0XCI+QWJvdXQ8L2E+XG4gICAgICogPGEgaHJlZj1cIiMvY29udGFjdHM/cGFnZT0yXCIgdWktc3JlZj1cIntwYWdlOiAyfVwiPk5leHQgcGFnZTwvYT5cbiAgICAgKlxuICAgICAqIDx1bD5cbiAgICAgKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cbiAgICAgKiAgICAgICAgIDxhIGhyZWY9XCIjL2NvbnRhY3RzLzFcIiB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj5Kb2U8L2E+XG4gICAgICogICAgIDwvbGk+XG4gICAgICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gICAgICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8yXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+QWxpY2U8L2E+XG4gICAgICogICAgIDwvbGk+XG4gICAgICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gICAgICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8zXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+Qm9iPC9hPlxuICAgICAqICAgICA8L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICpcbiAgICAgKiA8YSBocmVmPVwiIy9ob21lXCIgdWktc3JlZj1cImhvbWVcIiB1aS1zcmVmLW9wdHM9XCJ7cmVsb2FkOiB0cnVlfVwiPkhvbWU8L2E+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgTm90ZXNcbiAgICAgKlxuICAgICAqIC0gWW91IGNhbiB1c2UgYHVpLXNyZWZgIHRvIGNoYW5nZSAqKm9ubHkgdGhlIHBhcmFtZXRlciB2YWx1ZXMqKiBieSBvbWl0dGluZyB0aGUgc3RhdGUgbmFtZSBhbmQgcGFyZW50aGVzZXMuXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIFNldHMgdGhlIGBsYW5nYCBwYXJhbWV0ZXIgdG8gYGVuYCBhbmQgcmVtYWlucyBvbiB0aGUgc2FtZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YSB1aS1zcmVmPVwieyBsYW5nOiAnZW4nIH1cIj5FbmdsaXNoPC9hPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogLSBBIG1pZGRsZS1jbGljaywgcmlnaHQtY2xpY2ssIG9yIGN0cmwtY2xpY2sgaXMgaGFuZGxlZCAobmF0aXZlbHkpIGJ5IHRoZSBicm93c2VyIHRvIG9wZW4gdGhlIGhyZWYgaW4gYSBuZXcgd2luZG93LCBmb3IgZXhhbXBsZS5cbiAgICAgKlxuICAgICAqIC0gVW5saWtlIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGV4cHJlc3Npb24sIHRoZSBzdGF0ZSBuYW1lIGlzIG5vdCBgJHdhdGNoYGVkIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykuXG4gICAgICogSWYgeW91IG5lZWQgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoZSBzdGF0ZSBiZWluZyBsaW5rZWQgdG8sIHVzZSB0aGUgZnVsbHkgZHluYW1pYyBbW3VpU3RhdGVdXSBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgdmFyIHVpU3JlZkRpcmVjdGl2ZTtcbiAgICB1aVNyZWZEaXJlY3RpdmUgPSBbXG4gICAgICAgICckdWlSb3V0ZXInLFxuICAgICAgICAnJHRpbWVvdXQnLFxuICAgICAgICBmdW5jdGlvbiAkU3RhdGVSZWZEaXJlY3RpdmUoJHVpUm91dGVyLCAkdGltZW91dCkge1xuICAgICAgICAgICAgdmFyICRzdGF0ZSA9ICR1aVJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgICAgICAgICAgcmVxdWlyZTogWyc/XnVpU3JlZkFjdGl2ZScsICc/XnVpU3JlZkFjdGl2ZUVxJ10sXG4gICAgICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdWlTcmVmQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZUluZm8oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmUgPSB1aVNyZWZBY3RpdmVbMV0gfHwgdWlTcmVmQWN0aXZlWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5saW5rSW5mb0ZuID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvb2tGbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0RlZiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0RGVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvY2Vzc2VkRGVmKCRzdGF0ZSwgZWxlbWVudCwgcmF3RGVmKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IHBhcnNlU3RhdGVSZWYoYXR0cnMudWlTcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgcmF3RGVmLnVpU3RhdGUgPSByZWYuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJhd0RlZi51aVN0YXRlT3B0cyA9IGF0dHJzLnVpU3JlZk9wdHMgPyBzY29wZS4kZXZhbChhdHRycy51aVNyZWZPcHRzKSA6IHt9O1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gZ2V0RGVmKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5saW5rSW5mb0ZuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubGlua0luZm9GbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmxpbmtJbmZvRm4gPSBhY3RpdmUuJCRhZGRTdGF0ZUluZm8oZGVmLnVpU3RhdGUsIGRlZi51aVN0YXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYuaHJlZiAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLiRzZXQodHlwZS5hdHRyLCBkZWYuaHJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZi5wYXJhbUV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChyZWYucGFyYW1FeHByLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3RGVmLnVpU3RhdGVQYXJhbXMgPSBjb3JlLmV4dGVuZCh7fSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3RGVmLnVpU3RhdGVQYXJhbXMgPSBjb3JlLmV4dGVuZCh7fSwgc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnN0YXRlUmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKHVwZGF0ZSkpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZS5jbGlja2FibGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGhvb2tGbiA9IGNsaWNrSG9vayhlbGVtZW50LCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBnZXREZWYpO1xuICAgICAgICAgICAgICAgICAgICBiaW5kRXZlbnRzKGVsZW1lbnQsIHNjb3BlLCBob29rRm4sIHJhd0RlZi51aVN0YXRlT3B0cyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBgdWktc3RhdGVgOiBBIGZ1bGx5IGR5bmFtaWMgZGlyZWN0aXZlIGZvciBsaW5raW5nIHRvIGEgc3RhdGVcbiAgICAgKlxuICAgICAqIEEgZGlyZWN0aXZlIHdoaWNoIGxpbmtzIHRvIGEgc3RhdGUgKGFuZCBvcHRpb25hbGx5LCBwYXJhbWV0ZXJzKS5cbiAgICAgKiBXaGVuIGNsaWNrZWQsIHRoaXMgZGlyZWN0aXZlIGFjdGl2YXRlcyB0aGUgbGlua2VkIHN0YXRlIHdpdGggdGhlIHN1cHBsaWVkIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKlRoaXMgZGlyZWN0aXZlIGlzIHZlcnkgc2ltaWxhciB0byBbW3VpU3JlZl1dLCBidXQgaXQgYCRvYnNlcnZlYHMgYW5kIGAkd2F0Y2hgZXMvZXZhbHVhdGVzIGFsbCBpdHMgaW5wdXRzLioqXG4gICAgICpcbiAgICAgKiBBIGRpcmVjdGl2ZSB3aGljaCBsaW5rcyB0byBhIHN0YXRlIChhbmQgb3B0aW9uYWxseSwgcGFyYW1ldGVycykuXG4gICAgICogV2hlbiBjbGlja2VkLCB0aGlzIGRpcmVjdGl2ZSBhY3RpdmF0ZXMgdGhlIGxpbmtlZCBzdGF0ZSB3aXRoIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogIyMjIExpbmtlZCBTdGF0ZVxuICAgICAqIFRoZSBhdHRyaWJ1dGUgdmFsdWUgb2YgYHVpLXN0YXRlYCBpcyBhbiBleHByZXNzaW9uIHdoaWNoIGlzIGAkd2F0Y2hgZWQgYW5kIGV2YWx1YXRlZCBhcyB0aGUgc3RhdGUgdG8gbGluayB0by5cbiAgICAgKiAqKlRoaXMgaXMgaW4gY29udHJhc3Qgd2l0aCBgdWktc3JlZmAsIHdoaWNoIHRha2VzIGEgc3RhdGUgbmFtZSBhcyBhIHN0cmluZyBsaXRlcmFsLioqXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogQ3JlYXRlIGEgbGlzdCBvZiBsaW5rcy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGxpIG5nLXJlcGVhdD1cImxpbmsgaW4gbmF2bGlua3NcIj5cbiAgICAgKiAgIDxhIHVpLXN0YXRlPVwibGluay5zdGF0ZVwiPnt7IGxpbmsuZGlzcGxheU5hbWUgfX08L2E+XG4gICAgICogPC9saT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBSZWxhdGl2ZSBMaW5rc1xuICAgICAqIElmIHRoZSBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBhIHJlbGF0aXZlIHBhdGgsIGl0IGlzIHByb2Nlc3NlZCBsaWtlIFtbdWlTcmVmXV0uXG4gICAgICogWW91IGp1c3QgbmVlZCB0byBiZSBhd2FyZSB0aGF0IHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBzdGF0ZSB0aGF0ICpjcmVhdGVkKiB0aGUgbGluay5cbiAgICAgKiBUaGlzIGFsbG93cyBhIHN0YXRlIHRvIGNyZWF0ZSByZWxhdGl2ZSBgdWktc3RhdGVgIHdoaWNoIGFsd2F5cyB0YXJnZXRzIHRoZSBzYW1lIGRlc3RpbmF0aW9uLlxuICAgICAqXG4gICAgICogIyMjIGhyZWZzXG4gICAgICogSWYgdGhlIGxpbmtlZCBzdGF0ZSBoYXMgYSBVUkwsIHRoZSBkaXJlY3RpdmUgd2lsbCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGFuZFxuICAgICAqIHVwZGF0ZSB0aGUgYGhyZWZgIGF0dHJpYnV0ZSAodXNpbmcgdGhlIFtbU3RhdGVTZXJ2aWNlLmhyZWZdXSAgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqICMjIyBQYXJhbWV0ZXIgVmFsdWVzXG4gICAgICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YXRlIG5hbWUgZXhwcmVzc2lvbiwgYSBgdWktc3RhdGVgIGNhbiBpbmNsdWRlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggYXJlIGFwcGxpZWQgd2hlbiBhY3RpdmF0aW5nIHRoZSBzdGF0ZS5cbiAgICAgKiBQYXJhbSB2YWx1ZXMgc2hvdWxkIGJlIHByb3ZpZGVkIHVzaW5nIHRoZSBgdWktc3RhdGUtcGFyYW1zYCBhdHRyaWJ1dGUuXG4gICAgICogVGhlIGB1aS1zdGF0ZS1wYXJhbXNgIGF0dHJpYnV0ZSB2YWx1ZSBpcyBgJHdhdGNoYGVkIGFuZCBldmFsdWF0ZWQgYXMgYW4gZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBUaGlzIGV4YW1wbGUgcmVuZGVycyBhIGxpc3Qgb2YgbGlua3Mgd2l0aCBwYXJhbSB2YWx1ZXMuXG4gICAgICogVGhlIHN0YXRlJ3MgYHVzZXJJZGAgcGFyYW1ldGVyIHZhbHVlIGNvbWVzIGZyb20gZWFjaCB1c2VyJ3MgYHVzZXIuaWRgIHByb3BlcnR5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bGkgbmctcmVwZWF0PVwibGluayBpbiBuYXZsaW5rc1wiPlxuICAgICAqICAgPGEgdWktc3RhdGU9XCJsaW5rLnN0YXRlXCIgdWktc3RhdGUtcGFyYW1zPVwibGluay5wYXJhbXNcIj57eyBsaW5rLmRpc3BsYXlOYW1lIH19PC9hPlxuICAgICAqIDwvbGk+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgVHJhbnNpdGlvbiBPcHRpb25zXG4gICAgICogWW91IGNhbiBzcGVjaWZ5IFtbVHJhbnNpdGlvbk9wdGlvbnNdXSB0byBwYXNzIHRvIFtbU3RhdGVTZXJ2aWNlLmdvXV0gYnkgdXNpbmcgdGhlIGB1aS1zdGF0ZS1vcHRzYCBhdHRyaWJ1dGUuXG4gICAgICogT3B0aW9ucyBhcmUgcmVzdHJpY3RlZCB0byBgbG9jYXRpb25gLCBgaW5oZXJpdGAsIGFuZCBgcmVsb2FkYC5cbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIGB1aS1zdGF0ZS1vcHRzYCBpcyBgJHdhdGNoYGVkIGFuZCBldmFsdWF0ZWQgYXMgYW4gZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGEgdWktc3RhdGU9XCJyZXR1cm50by5zdGF0ZVwiIHVpLXN0YXRlLW9wdHM9XCJ7IHJlbG9hZDogdHJ1ZSB9XCI+SG9tZTwvYT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBPdGhlciBET00gRXZlbnRzXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gY3VzdG9taXplIHdoaWNoIERPTSBldmVudHMgdG8gcmVzcG9uZCB0byAoaW5zdGVhZCBvZiBgY2xpY2tgKSBieVxuICAgICAqIHByb3ZpZGluZyBhbiBgZXZlbnRzYCBhcnJheSBpbiB0aGUgYHVpLXN0YXRlLW9wdHNgIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdWktc3RhdGU9XCJjb250YWN0c1wiIHVpLXN0YXRlLW9wdHM9XCJ7IGV2ZW50czogWydjaGFuZ2UnLCAnYmx1ciddIH1cIj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBIaWdobGlnaHRpbmcgdGhlIGFjdGl2ZSBsaW5rXG4gICAgICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBbW3VpU3JlZkFjdGl2ZV1dIHRvIGhpZ2hsaWdodCB0aGUgYWN0aXZlIGxpbmsuXG4gICAgICpcbiAgICAgKiAjIyMgTm90ZXNcbiAgICAgKlxuICAgICAqIC0gWW91IGNhbiB1c2UgYHVpLXBhcmFtc2AgdG8gY2hhbmdlICoqb25seSB0aGUgcGFyYW1ldGVyIHZhbHVlcyoqIGJ5IG9taXR0aW5nIHRoZSBzdGF0ZSBuYW1lIGFuZCBzdXBwbHlpbmcgb25seSBgdWktc3RhdGUtcGFyYW1zYC5cbiAgICAgKiAgIEhvd2V2ZXIsIGl0IG1pZ2h0IGJlIHNpbXBsZXIgdG8gdXNlIFtbdWlTcmVmXV0gcGFyYW1ldGVyLW9ubHkgbGlua3MuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogU2V0cyB0aGUgYGxhbmdgIHBhcmFtZXRlciB0byBgZW5gIGFuZCByZW1haW5zIG9uIHRoZSBzYW1lIHN0YXRlLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxhIHVpLXN0YXRlPVwiXCIgdWktc3RhdGUtcGFyYW1zPVwieyBsYW5nOiAnZW4nIH1cIj5FbmdsaXNoPC9hPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogLSBBIG1pZGRsZS1jbGljaywgcmlnaHQtY2xpY2ssIG9yIGN0cmwtY2xpY2sgaXMgaGFuZGxlZCAobmF0aXZlbHkpIGJ5IHRoZSBicm93c2VyIHRvIG9wZW4gdGhlIGhyZWYgaW4gYSBuZXcgd2luZG93LCBmb3IgZXhhbXBsZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YXIgdWlTdGF0ZURpcmVjdGl2ZTtcbiAgICB1aVN0YXRlRGlyZWN0aXZlID0gW1xuICAgICAgICAnJHVpUm91dGVyJyxcbiAgICAgICAgJyR0aW1lb3V0JyxcbiAgICAgICAgZnVuY3Rpb24gJFN0YXRlUmVmRHluYW1pY0RpcmVjdGl2ZSgkdWlSb3V0ZXIsICR0aW1lb3V0KSB7XG4gICAgICAgICAgICB2YXIgJHN0YXRlID0gJHVpUm91dGVyLnN0YXRlU2VydmljZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgICAgICAgICByZXF1aXJlOiBbJz9edWlTcmVmQWN0aXZlJywgJz9edWlTcmVmQWN0aXZlRXEnXSxcbiAgICAgICAgICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCB1aVNyZWZBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlSW5mbyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IHVpU3JlZkFjdGl2ZVsxXSB8fCB1aVNyZWZBY3RpdmVbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmxpbmtJbmZvRm4gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaG9va0ZuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3RGVmID0ge307XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXREZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9jZXNzZWREZWYoJHN0YXRlLCBlbGVtZW50LCByYXdEZWYpOyB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRBdHRycyA9IFsndWlTdGF0ZScsICd1aVN0YXRlUGFyYW1zJywgJ3VpU3RhdGVPcHRzJ107XG4gICAgICAgICAgICAgICAgICAgIHZhciB3YXRjaERlcmVnRm5zID0gaW5wdXRBdHRycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cikgeyByZXR1cm4gKChhY2NbYXR0cl0gPSBjb3JlLm5vb3ApLCBhY2MpOyB9LCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBnZXREZWYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmxpbmtJbmZvRm4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5saW5rSW5mb0ZuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubGlua0luZm9GbiA9IGFjdGl2ZS4kJGFkZFN0YXRlSW5mbyhkZWYudWlTdGF0ZSwgZGVmLnVpU3RhdGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5ocmVmICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMuJHNldCh0eXBlLmF0dHIsIGRlZi5ocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnB1dEF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdEZWZbZmllbGRdID0gYXR0cnNbZmllbGRdID8gc2NvcGUuJGV2YWwoYXR0cnNbZmllbGRdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZShmaWVsZCwgZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXRjaERlcmVnRm5zW2ZpZWxkXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoRGVyZWdGbnNbZmllbGRdID0gc2NvcGUuJHdhdGNoKGV4cHIsIGZ1bmN0aW9uIChuZXd2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3RGVmW2ZpZWxkXSA9IG5ld3ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnN0YXRlUmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKHVwZGF0ZSkpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZS5jbGlja2FibGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGhvb2tGbiA9IGNsaWNrSG9vayhlbGVtZW50LCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBnZXREZWYpO1xuICAgICAgICAgICAgICAgICAgICBiaW5kRXZlbnRzKGVsZW1lbnQsIHNjb3BlLCBob29rRm4sIHJhd0RlZi51aVN0YXRlT3B0cyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBgdWktc3JlZi1hY3RpdmVgIGFuZCBgdWktc3JlZi1hY3RpdmUtZXFgOiBBIGRpcmVjdGl2ZSB0aGF0IGFkZHMgYSBDU1MgY2xhc3Mgd2hlbiBhIGB1aS1zcmVmYCBpcyBhY3RpdmVcbiAgICAgKlxuICAgICAqIEEgZGlyZWN0aXZlIHdvcmtpbmcgYWxvbmdzaWRlIFtbdWlTcmVmXV0gYW5kIFtbdWlTdGF0ZV1dIHRvIGFkZCBjbGFzc2VzIHRvIGFuIGVsZW1lbnQgd2hlbiB0aGVcbiAgICAgKiByZWxhdGVkIGRpcmVjdGl2ZSdzIHN0YXRlIGlzIGFjdGl2ZSAoYW5kIHJlbW92ZSB0aGVtIHdoZW4gaXQgaXMgaW5hY3RpdmUpLlxuICAgICAqXG4gICAgICogVGhlIHByaW1hcnkgdXNlLWNhc2UgaXMgdG8gaGlnaGxpZ2h0IHRoZSBhY3RpdmUgbGluayBpbiBuYXZpZ2F0aW9uIG1lbnVzLFxuICAgICAqIGRpc3Rpbmd1aXNoaW5nIGl0IGZyb20gdGhlIGluYWN0aXZlIG1lbnUgaXRlbXMuXG4gICAgICpcbiAgICAgKiAjIyMgTGlua2luZyB0byBhIGB1aS1zcmVmYCBvciBgdWktc3RhdGVgXG4gICAgICogYHVpLXNyZWYtYWN0aXZlYCBjYW4gbGl2ZSBvbiB0aGUgc2FtZSBlbGVtZW50IGFzIGB1aS1zcmVmYC9gdWktc3RhdGVgLCBvciBpdCBjYW4gYmUgb24gYSBwYXJlbnQgZWxlbWVudC5cbiAgICAgKiBJZiBhIGB1aS1zcmVmLWFjdGl2ZWAgaXMgYSBwYXJlbnQgdG8gbW9yZSB0aGFuIG9uZSBgdWktc3JlZmAvYHVpLXN0YXRlYCwgaXQgd2lsbCBhcHBseSB0aGUgQ1NTIGNsYXNzIHdoZW4gKiphbnkgb2YgdGhlIGxpbmtzIGFyZSBhY3RpdmUqKi5cbiAgICAgKlxuICAgICAqICMjIyBNYXRjaGluZ1xuICAgICAqXG4gICAgICogVGhlIGB1aS1zcmVmLWFjdGl2ZWAgZGlyZWN0aXZlIGFwcGxpZXMgdGhlIENTUyBjbGFzcyB3aGVuIHRoZSBgdWktc3JlZmAvYHVpLXN0YXRlYCdzIHRhcmdldCBzdGF0ZSAqKm9yIGFueSBjaGlsZCBzdGF0ZSBpcyBhY3RpdmUqKi5cbiAgICAgKiBUaGlzIGlzIGEgXCJmdXp6eSBtYXRjaFwiIHdoaWNoIHVzZXMgW1tTdGF0ZVNlcnZpY2UuaW5jbHVkZXNdXS5cbiAgICAgKlxuICAgICAqIFRoZSBgdWktc3JlZi1hY3RpdmUtZXFgIGRpcmVjdGl2ZSBhcHBsaWVzIHRoZSBDU1MgY2xhc3Mgd2hlbiB0aGUgYHVpLXNyZWZgL2B1aS1zdGF0ZWAncyB0YXJnZXQgc3RhdGUgaXMgZGlyZWN0bHkgYWN0aXZlIChub3Qgd2hlbiBjaGlsZCBzdGF0ZXMgYXJlIGFjdGl2ZSkuXG4gICAgICogVGhpcyBpcyBhbiBcImV4YWN0IG1hdGNoXCIgd2hpY2ggdXNlcyBbW1N0YXRlU2VydmljZS5pc11dLlxuICAgICAqXG4gICAgICogIyMjIFBhcmFtZXRlciB2YWx1ZXNcbiAgICAgKiBJZiB0aGUgYHVpLXNyZWZgL2B1aS1zdGF0ZWAgaW5jbHVkZXMgcGFyYW1ldGVyIHZhbHVlcywgdGhlIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcyBtdXN0IG1hdGNoIHRoZSBsaW5rJ3MgdmFsdWVzIGZvciB0aGUgbGluayB0byBiZSBoaWdobGlnaHRlZC5cbiAgICAgKiBUaGlzIGFsbG93cyBhIGxpc3Qgb2YgbGlua3MgdG8gdGhlIHNhbWUgc3RhdGUgd2l0aCBkaWZmZXJlbnQgcGFyYW1ldGVycyB0byBiZSByZW5kZXJlZCwgYW5kIHRoZSBjb3JyZWN0IG9uZSBoaWdobGlnaHRlZC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGxpIG5nLXJlcGVhdD1cInVzZXIgaW4gdXNlcnNcIiB1aS1zcmVmLWFjdGl2ZT1cImFjdGl2ZVwiPlxuICAgICAqICAgPGEgdWktc3JlZj1cInVzZXIuZGV0YWlscyh7IHVzZXJJZDogdXNlci5pZCB9KVwiPnt7IHVzZXIubGFzdE5hbWUgfX08L2E+XG4gICAgICogPC9saT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlc1xuICAgICAqXG4gICAgICogR2l2ZW4gdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZTpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBgaHRtbFxuICAgICAqIDx1bD5cbiAgICAgKiAgIDxsaSB1aS1zcmVmLWFjdGl2ZT1cImFjdGl2ZVwiIGNsYXNzPVwiaXRlbVwiPlxuICAgICAqICAgICA8YSBocmVmIHVpLXNyZWY9XCJhcHAudXNlcih7dXNlcjogJ2JpbGJvYmFnZ2lucyd9KVwiPkBiaWxib2JhZ2dpbnM8L2E+XG4gICAgICogICA8L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBhcHAgc3RhdGUgaXMgYGFwcC51c2VyYCAob3IgYW55IGNoaWxkIHN0YXRlKSxcbiAgICAgKiBhbmQgY29udGFpbnMgdGhlIHN0YXRlIHBhcmFtZXRlciBcInVzZXJcIiB3aXRoIHZhbHVlIFwiYmlsYm9iYWdnaW5zXCIsXG4gICAgICogdGhlIHJlc3VsdGluZyBIVE1MIHdpbGwgYXBwZWFyIGFzIChub3RlIHRoZSAnYWN0aXZlJyBjbGFzcyk6XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPHVsPlxuICAgICAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgY2xhc3M9XCJpdGVtIGFjdGl2ZVwiPlxuICAgICAqICAgICA8YSB1aS1zcmVmPVwiYXBwLnVzZXIoe3VzZXI6ICdiaWxib2JhZ2dpbnMnfSlcIiBocmVmPVwiL3VzZXJzL2JpbGJvYmFnZ2luc1wiPkBiaWxib2JhZ2dpbnM8L2E+XG4gICAgICogICA8L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgR2xvYiBtb2RlXG4gICAgICpcbiAgICAgKiBJdCBpcyBwb3NzaWJsZSB0byBwYXNzIGB1aS1zcmVmLWFjdGl2ZWAgYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlcyB0byBhbiBvYmplY3QuXG4gICAgICogVGhlIG9iamVjdHMga2V5cyByZXByZXNlbnQgYWN0aXZlIGNsYXNzIG5hbWVzIGFuZCB2YWx1ZXMgcmVwcmVzZW50IHRoZSByZXNwZWN0aXZlIHN0YXRlIG5hbWVzL2dsb2JzLlxuICAgICAqIGB1aS1zcmVmLWFjdGl2ZWAgd2lsbCBtYXRjaCBpZiB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUgKippbmNsdWRlcyoqIGFueSBvZlxuICAgICAqIHRoZSBzcGVjaWZpZWQgc3RhdGUgbmFtZXMvZ2xvYnMsIGV2ZW4gdGhlIGFic3RyYWN0IG9uZXMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogR2l2ZW4gdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSwgd2l0aCBcImFkbWluXCIgYmVpbmcgYW4gYWJzdHJhY3Qgc3RhdGU6XG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgdWktc3JlZi1hY3RpdmU9XCJ7J2FjdGl2ZSc6ICdhZG1pbi4qKid9XCI+XG4gICAgICogICA8YSB1aS1zcmVmLWFjdGl2ZT1cImFjdGl2ZVwiIHVpLXNyZWY9XCJhZG1pbi5yb2xlc1wiPlJvbGVzPC9hPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQXJyYXlzIGFyZSBhbHNvIHN1cHBvcnRlZCBhcyB2YWx1ZXMgaW4gdGhlIGBuZ0NsYXNzYC1saWtlIGludGVyZmFjZS5cbiAgICAgKiBUaGlzIGFsbG93cyBtdWx0aXBsZSBzdGF0ZXMgdG8gYWRkIGBhY3RpdmVgIGNsYXNzLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIEdpdmVuIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUsIHdpdGggXCJhZG1pbi5yb2xlc1wiIGJlaW5nIHRoZSBjdXJyZW50IHN0YXRlLCB0aGUgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0b286XG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgdWktc3JlZi1hY3RpdmU9XCJ7J2FjdGl2ZSc6IFsnb3duZXIuKionLCAnYWRtaW4uKionXX1cIj5cbiAgICAgKiAgIDxhIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgdWktc3JlZj1cImFkbWluLnJvbGVzXCI+Um9sZXM8L2E+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBjdXJyZW50IHN0YXRlIGlzIFwiYWRtaW4ucm9sZXNcIiB0aGUgXCJhY3RpdmVcIiBjbGFzcyB3aWxsIGJlIGFwcGxpZWQgdG8gYm90aCB0aGUgYDxkaXY+YCBhbmQgYDxhPmAgZWxlbWVudHMuXG4gICAgICogSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB0aGUgc3RhdGUgbmFtZXMvZ2xvYnMgcGFzc2VkIHRvIGB1aS1zcmVmLWFjdGl2ZWAgb3ZlcnJpZGUgYW55IHN0YXRlIHByb3ZpZGVkIGJ5IGEgbGlua2VkIGB1aS1zcmVmYC5cbiAgICAgKlxuICAgICAqICMjIyBOb3RlczpcbiAgICAgKlxuICAgICAqIC0gVGhlIGNsYXNzIG5hbWUgaXMgaW50ZXJwb2xhdGVkICoqb25jZSoqIGR1cmluZyB0aGUgZGlyZWN0aXZlcyBsaW5rIHRpbWUgKGFueSBmdXJ0aGVyIGNoYW5nZXMgdG8gdGhlXG4gICAgICogaW50ZXJwb2xhdGVkIHZhbHVlIGFyZSBpZ25vcmVkKS5cbiAgICAgKlxuICAgICAqIC0gTXVsdGlwbGUgY2xhc3NlcyBtYXkgYmUgc3BlY2lmaWVkIGluIGEgc3BhY2Utc2VwYXJhdGVkIGZvcm1hdDogYHVpLXNyZWYtYWN0aXZlPSdjbGFzczEgY2xhc3MyIGNsYXNzMydgXG4gICAgICovXG4gICAgdmFyIHVpU3JlZkFjdGl2ZURpcmVjdGl2ZTtcbiAgICB1aVNyZWZBY3RpdmVEaXJlY3RpdmUgPSBbXG4gICAgICAgICckc3RhdGUnLFxuICAgICAgICAnJHN0YXRlUGFyYW1zJyxcbiAgICAgICAgJyRpbnRlcnBvbGF0ZScsXG4gICAgICAgICckdWlSb3V0ZXInLFxuICAgICAgICBmdW5jdGlvbiAkU3RhdGVSZWZBY3RpdmVEaXJlY3RpdmUoJHN0YXRlLCAkc3RhdGVQYXJhbXMsICRpbnRlcnBvbGF0ZSwgJHVpUm91dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAgICAgICAgICAgICAnJHNjb3BlJyxcbiAgICAgICAgICAgICAgICAgICAgJyRlbGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgJyRhdHRycycsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVFcUNsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVpU3JlZkFjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIHByb2JhYmx5IGlzbid0IG11Y2ggcG9pbnQgaW4gJG9ic2VydmluZyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1aVNyZWZBY3RpdmUgYW5kIHVpU3JlZkFjdGl2ZUVxIHNoYXJlIHRoZSBzYW1lIGRpcmVjdGl2ZSBvYmplY3Qgd2l0aCBzb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbGlnaHQgZGlmZmVyZW5jZSBpbiBsb2dpYyByb3V0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVFcUNsYXNzID0gJGludGVycG9sYXRlKCRhdHRycy51aVNyZWZBY3RpdmVFcSB8fCAnJywgZmFsc2UpKCRzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpU3JlZkFjdGl2ZSA9ICRzY29wZS4kZXZhbCgkYXR0cnMudWlTcmVmQWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZy4gdWlTcmVmQWN0aXZlIGlzIG5vdCBhIHZhbGlkIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHVzaW5nICRpbnRlcnBvbGF0ZSBiZWxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdWlTcmVmQWN0aXZlID0gdWlTcmVmQWN0aXZlIHx8ICRpbnRlcnBvbGF0ZSgkYXR0cnMudWlTcmVmQWN0aXZlIHx8ICcnLCBmYWxzZSkoJHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0YXRlc0Zyb21EZWZpbml0aW9uT2JqZWN0KHVpU3JlZkFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB1aVNyZWYgdG8gY29tbXVuaWNhdGUgd2l0aCB1aVNyZWZBY3RpdmVbRXF1YWxzXVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kJGFkZFN0YXRlSW5mbyA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgbmV3UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWxyZWFkeSBnb3QgYW4gZXhwbGljaXQgc3RhdGUgcHJvdmlkZWQgYnkgdWktc3JlZi1hY3RpdmUsIHNvIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hhZG93IHRoZSBvbmUgdGhhdCBjb21lcyBmcm9tIHVpLXNyZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29yZS5pc09iamVjdCh1aVNyZWZBY3RpdmUpICYmIHN0YXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcmVnaXN0ZXIgPSBhZGRTdGF0ZShuZXdTdGF0ZSwgbmV3UGFyYW1zLCB1aVNyZWZBY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXJlZ2lzdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUFmdGVyVHJhbnNpdGlvbih0cmFucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLnByb21pc2UudGhlbih1cGRhdGUsIGNvcmUubm9vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHVpUm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUFmdGVyVHJhbnNpdGlvbigkdWlSb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcmVnaXN0ZXJTdGF0ZXNDaGFuZ2VkTGlzdGVuZXIgPSAkdWlSb3V0ZXIuc3RhdGVSZWdpc3RyeS5vblN0YXRlc0NoYW5nZWQoaGFuZGxlU3RhdGVzQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcmVnaXN0ZXJPblN0YXJ0TGlzdGVuZXIgPSAkdWlSb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgdXBkYXRlQWZ0ZXJUcmFuc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVyZWdpc3RlclN0YXRlQ2hhbmdlU3VjY2Vzc0xpc3RlbmVyID0gJHNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXJTdGF0ZXNDaGFuZ2VkTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVyZWdpc3Rlck9uU3RhcnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXJlZ2lzdGVyU3RhdGVDaGFuZ2VTdWNjZXNzTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlU3RhdGVzQ2hhbmdlZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZXNGcm9tRGVmaW5pdGlvbk9iamVjdCh1aVNyZWZBY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0U3RhdGVzRnJvbURlZmluaXRpb25PYmplY3Qoc3RhdGVzRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzT2JqZWN0KHN0YXRlc0RlZmluaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLmZvckVhY2goc3RhdGVzRGVmaW5pdGlvbiwgZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBhY3RpdmVDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFic3RyYWN0IGFkZGluZyBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRTdGF0ZUZvckNsYXNzID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBhY3RpdmVDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBwYXJzZVN0YXRlUmVmKHN0YXRlT3JOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTdGF0ZShyZWYuc3RhdGUsICRzY29wZS4kZXZhbChyZWYucGFyYW1FeHByKSwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzU3RyaW5nKHN0YXRlT3JOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHN0YXRlIGlzIHN0cmluZywganVzdCBhZGQgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3RhdGVGb3JDbGFzcyhzdGF0ZU9yTmFtZSwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29yZS5pc0FycmF5KHN0YXRlT3JOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHN0YXRlIGlzIGFuIGFycmF5LCBpdGVyYXRlIG92ZXIgaXQgYW5kIGFkZCBlYWNoIGFycmF5IGl0ZW0gaW5kaXZpZHVhbGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuZm9yRWFjaChzdGF0ZU9yTmFtZSwgZnVuY3Rpb24gKHN0YXRlT3JOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFN0YXRlRm9yQ2xhc3Moc3RhdGVPck5hbWUsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkU3RhdGUoc3RhdGVOYW1lLCBzdGF0ZVBhcmFtcywgYWN0aXZlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSAkc3RhdGUuZ2V0KHN0YXRlTmFtZSwgc3RhdGVDb250ZXh0KCRlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlIHx8IHsgbmFtZTogc3RhdGVOYW1lIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogc3RhdGVQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNsYXNzOiBhY3RpdmVDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKHN0YXRlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZVN0YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLnJlbW92ZUZyb20oc3RhdGVzKShzdGF0ZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcm91dGUgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXRDbGFzc2VzID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnNwbGl0KC9cXHMvKS5maWx0ZXIoY29yZS5pZGVudGl0eSk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldENsYXNzZXMgPSBmdW5jdGlvbiAoc3RhdGVMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZUxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguYWN0aXZlQ2xhc3M7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHNwbGl0Q2xhc3NlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoY29yZS51bm5lc3RSLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsQ2xhc3NlcyA9IGdldENsYXNzZXMoc3RhdGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHNwbGl0Q2xhc3NlcyhhY3RpdmVFcUNsYXNzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShjb3JlLnVuaXFSLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1enp5Q2xhc3NlcyA9IGdldENsYXNzZXMoc3RhdGVzLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gJHN0YXRlLmluY2x1ZGVzKHguc3RhdGUubmFtZSwgeC5wYXJhbXMpOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4YWN0bHlNYXRjaGVzQW55ID0gISFzdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiAkc3RhdGUuaXMoeC5zdGF0ZS5uYW1lLCB4LnBhcmFtcyk7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhhY3RDbGFzc2VzID0gZXhhY3RseU1hdGNoZXNBbnkgPyBzcGxpdENsYXNzZXMoYWN0aXZlRXFDbGFzcykgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkQ2xhc3NlcyA9IGZ1enp5Q2xhc3Nlcy5jb25jYXQoZXhhY3RDbGFzc2VzKS5yZWR1Y2UoY29yZS51bmlxUiwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVDbGFzc2VzID0gYWxsQ2xhc3Nlcy5maWx0ZXIoZnVuY3Rpb24gKGNscykgeyByZXR1cm4gIWNvcmUuaW5BcnJheShhZGRDbGFzc2VzLCBjbHMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiAkZWxlbWVudC5hZGRDbGFzcyhjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuICRlbGVtZW50LnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgXTtcbiAgICBuZ1xuICAgICAgICAubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKVxuICAgICAgICAuZGlyZWN0aXZlKCd1aVNyZWYnLCB1aVNyZWZEaXJlY3RpdmUpXG4gICAgICAgIC5kaXJlY3RpdmUoJ3VpU3JlZkFjdGl2ZScsIHVpU3JlZkFjdGl2ZURpcmVjdGl2ZSlcbiAgICAgICAgLmRpcmVjdGl2ZSgndWlTcmVmQWN0aXZlRXEnLCB1aVNyZWZBY3RpdmVEaXJlY3RpdmUpXG4gICAgICAgIC5kaXJlY3RpdmUoJ3VpU3RhdGUnLCB1aVN0YXRlRGlyZWN0aXZlKTtcblxuICAgIC8qKiBAbW9kdWxlIG5nMSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbiAgICAvKipcbiAgICAgKiBgaXNTdGF0ZWAgRmlsdGVyOiB0cnV0aHkgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdGhlIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogVHJhbnNsYXRlcyB0byBbW1N0YXRlU2VydmljZS5pc11dIGAkc3RhdGUuaXMoXCJzdGF0ZU5hbWVcIilgLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IG5nLWlmPVwiJ3N0YXRlTmFtZScgfCBpc1N0YXRlXCI+c2hvdyBpZiBzdGF0ZSBpcyAnc3RhdGVOYW1lJzwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgICRJc1N0YXRlRmlsdGVyLiRpbmplY3QgPSBbJyRzdGF0ZSddO1xuICAgIGZ1bmN0aW9uICRJc1N0YXRlRmlsdGVyKCRzdGF0ZSkge1xuICAgICAgICB2YXIgaXNGaWx0ZXIgPSBmdW5jdGlvbiAoc3RhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS5pcyhzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgaXNGaWx0ZXIuJHN0YXRlZnVsID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGlzRmlsdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaW5jbHVkZWRCeVN0YXRlYCBGaWx0ZXI6IHRydXRoeSBpZiB0aGUgY3VycmVudCBzdGF0ZSBpbmNsdWRlcyB0aGUgcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBUcmFuc2xhdGVzIHRvIFtbU3RhdGVTZXJ2aWNlLmluY2x1ZGVzXV1gICRzdGF0ZS5pcyhcImZ1bGxPclBhcnRpYWxTdGF0ZU5hbWVcIilgLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IG5nLWlmPVwiJ2Z1bGxPclBhcnRpYWxTdGF0ZU5hbWUnIHwgaW5jbHVkZWRCeVN0YXRlXCI+c2hvdyBpZiBzdGF0ZSBpbmNsdWRlcyAnZnVsbE9yUGFydGlhbFN0YXRlTmFtZSc8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAkSW5jbHVkZWRCeVN0YXRlRmlsdGVyLiRpbmplY3QgPSBbJyRzdGF0ZSddO1xuICAgIGZ1bmN0aW9uICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIoJHN0YXRlKSB7XG4gICAgICAgIHZhciBpbmNsdWRlc0ZpbHRlciA9IGZ1bmN0aW9uIChzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gJHN0YXRlLmluY2x1ZGVzKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBpbmNsdWRlc0ZpbHRlci4kc3RhdGVmdWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gaW5jbHVkZXNGaWx0ZXI7XG4gICAgfVxuICAgIG5nXG4gICAgICAgIC5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gICAgICAgIC5maWx0ZXIoJ2lzU3RhdGUnLCAkSXNTdGF0ZUZpbHRlcilcbiAgICAgICAgLmZpbHRlcignaW5jbHVkZWRCeVN0YXRlJywgJEluY2x1ZGVkQnlTdGF0ZUZpbHRlcik7XG5cbiAgICAvKipcbiAgICAgKiBgdWktdmlld2A6IEEgdmlld3BvcnQgZGlyZWN0aXZlIHdoaWNoIGlzIGZpbGxlZCBpbiBieSBhIHZpZXcgZnJvbSB0aGUgYWN0aXZlIHN0YXRlLlxuICAgICAqXG4gICAgICogIyMjIEF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIC0gYG5hbWVgOiAoT3B0aW9uYWwpIEEgdmlldyBuYW1lLlxuICAgICAqICAgVGhlIG5hbWUgc2hvdWxkIGJlIHVuaXF1ZSBhbW9uZ3N0IHRoZSBvdGhlciB2aWV3cyBpbiB0aGUgc2FtZSBzdGF0ZS5cbiAgICAgKiAgIFlvdSBjYW4gaGF2ZSB2aWV3cyBvZiB0aGUgc2FtZSBuYW1lIHRoYXQgbGl2ZSBpbiBkaWZmZXJlbnQgc3RhdGVzLlxuICAgICAqICAgVGhlIHVpLXZpZXcgY2FuIGJlIHRhcmdldGVkIGluIGEgVmlldyB1c2luZyB0aGUgbmFtZSAoW1tOZzFTdGF0ZURlY2xhcmF0aW9uLnZpZXdzXV0pLlxuICAgICAqXG4gICAgICogLSBgYXV0b3Njcm9sbGA6IGFuIGV4cHJlc3Npb24uIFdoZW4gaXQgZXZhbHVhdGVzIHRvIHRydWUsIHRoZSBgdWktdmlld2Agd2lsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgd2hlbiBpdCBpcyBhY3RpdmF0ZWQuXG4gICAgICogICBVc2VzIFtbJHVpVmlld1Njcm9sbF1dIHRvIGRvIHRoZSBzY3JvbGxpbmcuXG4gICAgICpcbiAgICAgKiAtIGBvbmxvYWRgOiBFeHByZXNzaW9uIHRvIGV2YWx1YXRlIHdoZW5ldmVyIHRoZSB2aWV3IHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogQSB2aWV3IGNhbiBiZSB1bm5hbWVkIG9yIG5hbWVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tIFVubmFtZWQgLS0+XG4gICAgICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICAgICAqXG4gICAgICogPCEtLSBOYW1lZCAtLT5cbiAgICAgKiA8ZGl2IHVpLXZpZXc9XCJ2aWV3TmFtZVwiPjwvZGl2PlxuICAgICAqXG4gICAgICogPCEtLSBOYW1lZCAoZGlmZmVyZW50IHN0eWxlKSAtLT5cbiAgICAgKiA8dWktdmlldyBuYW1lPVwidmlld05hbWVcIj48L3VpLXZpZXc+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9ubHkgaGF2ZSBvbmUgdW5uYW1lZCB2aWV3IHdpdGhpbiBhbnkgdGVtcGxhdGUgKG9yIHJvb3QgaHRtbCkuIElmIHlvdSBhcmUgb25seSB1c2luZyBhXG4gICAgICogc2luZ2xlIHZpZXcgYW5kIGl0IGlzIHVubmFtZWQgdGhlbiB5b3UgY2FuIHBvcHVsYXRlIGl0IGxpa2Ugc286XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICAgICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZVwiLCB7XG4gICAgICogICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgaXMgYSBjb252ZW5pZW50IHNob3J0Y3V0IGVxdWl2YWxlbnQgdG8gc3BlY2lmeWluZyB5b3VyIHZpZXcgZXhwbGljaXRseSB3aXRoIHRoZVxuICAgICAqIFtbTmcxU3RhdGVEZWNsYXJhdGlvbi52aWV3c11dIGNvbmZpZyBwcm9wZXJ0eSwgYnkgbmFtZSwgaW4gdGhpcyBjYXNlIGFuIGVtcHR5IG5hbWU6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZVwiLCB7XG4gICAgICogICB2aWV3czoge1xuICAgICAqICAgICBcIlwiOiB7XG4gICAgICogICAgICAgdGVtcGxhdGU6IFwiPGgxPkhFTExPITwvaDE+XCJcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBCdXQgdHlwaWNhbGx5IHlvdSdsbCBvbmx5IHVzZSB0aGUgdmlld3MgcHJvcGVydHkgaWYgeW91IG5hbWUgeW91ciB2aWV3IG9yIGhhdmUgbW9yZSB0aGFuIG9uZSB2aWV3XG4gICAgICogaW4gdGhlIHNhbWUgdGVtcGxhdGUuIFRoZXJlJ3Mgbm90IHJlYWxseSBhIGNvbXBlbGxpbmcgcmVhc29uIHRvIG5hbWUgYSB2aWV3IGlmIGl0cyB0aGUgb25seSBvbmUsXG4gICAgICogYnV0IHlvdSBjb3VsZCBpZiB5b3Ugd2FudGVkLCBsaWtlIHNvOlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgdWktdmlldz1cIm1haW5cIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHtcbiAgICAgKiAgIHZpZXdzOiB7XG4gICAgICogICAgIFwibWFpblwiOiB7XG4gICAgICogICAgICAgdGVtcGxhdGU6IFwiPGgxPkhFTExPITwvaDE+XCJcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBSZWFsbHkgdGhvdWdoLCB5b3UnbGwgdXNlIHZpZXdzIHRvIHNldCB1cCBtdWx0aXBsZSB2aWV3czpcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IHVpLXZpZXc+PC9kaXY+XG4gICAgICogPGRpdiB1aS12aWV3PVwiY2hhcnRcIj48L2Rpdj5cbiAgICAgKiA8ZGl2IHVpLXZpZXc9XCJkYXRhXCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZVwiLCB7XG4gICAgICogICB2aWV3czoge1xuICAgICAqICAgICBcIlwiOiB7XG4gICAgICogICAgICAgdGVtcGxhdGU6IFwiPGgxPkhFTExPITwvaDE+XCJcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgXCJjaGFydFwiOiB7XG4gICAgICogICAgICAgdGVtcGxhdGU6IFwiPGNoYXJ0X3RoaW5nLz5cIlxuICAgICAqICAgICB9LFxuICAgICAqICAgICBcImRhdGFcIjoge1xuICAgICAqICAgICAgIHRlbXBsYXRlOiBcIjxkYXRhX3RoaW5nLz5cIlxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZXMgZm9yIGBhdXRvc2Nyb2xsYDpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLSBJZiBhdXRvc2Nyb2xsIHByZXNlbnQgd2l0aCBubyBleHByZXNzaW9uLFxuICAgICAqICAgICAgdGhlbiBzY3JvbGwgdWktdmlldyBpbnRvIHZpZXcgLS0+XG4gICAgICogPHVpLXZpZXcgYXV0b3Njcm9sbC8+XG4gICAgICpcbiAgICAgKiA8IS0tIElmIGF1dG9zY3JvbGwgcHJlc2VudCB3aXRoIHZhbGlkIGV4cHJlc3Npb24sXG4gICAgICogICAgICB0aGVuIHNjcm9sbCB1aS12aWV3IGludG8gdmlldyBpZiBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlIC0tPlxuICAgICAqIDx1aS12aWV3IGF1dG9zY3JvbGw9J3RydWUnLz5cbiAgICAgKiA8dWktdmlldyBhdXRvc2Nyb2xsPSdmYWxzZScvPlxuICAgICAqIDx1aS12aWV3IGF1dG9zY3JvbGw9J3Njb3BlVmFyaWFibGUnLz5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFJlc29sdmUgZGF0YTpcbiAgICAgKlxuICAgICAqIFRoZSByZXNvbHZlZCBkYXRhIGZyb20gdGhlIHN0YXRlJ3MgYHJlc29sdmVgIGJsb2NrIGlzIHBsYWNlZCBvbiB0aGUgc2NvcGUgYXMgYCRyZXNvbHZlYCAodGhpc1xuICAgICAqIGNhbiBiZSBjdXN0b21pemVkIHVzaW5nIFtbTmcxVmlld0RlY2xhcmF0aW9uLnJlc29sdmVBc11dKS4gIFRoaXMgY2FuIGJlIHRoZW4gYWNjZXNzZWQgZnJvbSB0aGUgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2hlbiBgY29udHJvbGxlckFzYCBpcyBiZWluZyB1c2VkLCBgJHJlc29sdmVgIGlzIHNldCBvbiB0aGUgY29udHJvbGxlciBpbnN0YW5jZSAqYWZ0ZXIqIHRoZVxuICAgICAqIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkLiAgVGhlIGAkb25Jbml0KClgIGhvb2sgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiBjb2RlIHdoaWNoXG4gICAgICogZGVwZW5kcyBvbiBgJHJlc29sdmVgIGRhdGEuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZSgnaG9tZScsIHtcbiAgICAgKiAgIHRlbXBsYXRlOiAnPG15LWNvbXBvbmVudCB1c2VyPVwiJHJlc29sdmUudXNlclwiPjwvbXktY29tcG9uZW50PicsXG4gICAgICogICByZXNvbHZlOiB7XG4gICAgICogICAgIHVzZXI6IGZ1bmN0aW9uKFVzZXJTZXJ2aWNlKSB7IHJldHVybiBVc2VyU2VydmljZS5mZXRjaFVzZXIoKTsgfVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHZhciB1aVZpZXc7XG4gICAgdWlWaWV3ID0gW1xuICAgICAgICAnJHZpZXcnLFxuICAgICAgICAnJGFuaW1hdGUnLFxuICAgICAgICAnJHVpVmlld1Njcm9sbCcsXG4gICAgICAgICckaW50ZXJwb2xhdGUnLFxuICAgICAgICAnJHEnLFxuICAgICAgICBmdW5jdGlvbiAkVmlld0RpcmVjdGl2ZSgkdmlldywgJGFuaW1hdGUsICR1aVZpZXdTY3JvbGwsICRpbnRlcnBvbGF0ZSwgJHEpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFJlbmRlcmVyKGF0dHJzLCBzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAoZWxlbWVudCwgdGFyZ2V0LCBjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5nLnZlcnNpb24ubWlub3IgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoZWxlbWVudCwgbnVsbCwgdGFyZ2V0KS50aGVuKGNiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCwgY2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmcudmVyc2lvbi5taW5vciA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShlbGVtZW50KS50aGVuKGNiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhbmltYXRlLmxlYXZlKGVsZW1lbnQsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY29uZmlnc0VxdWFsKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnMSA9PT0gY29uZmlnMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb290RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAkY2ZnOiB7IHZpZXdEZWNsOiB7ICRjb250ZXh0OiAkdmlldy5fcGx1Z2luYXBpLl9yb290Vmlld0NvbnRleHQoKSB9IH0sXG4gICAgICAgICAgICAgICAgJHVpVmlldzoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IHtcbiAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXN0cmljdDogJ0VDQScsXG4gICAgICAgICAgICAgICAgdGVybWluYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IDQwMCxcbiAgICAgICAgICAgICAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXG4gICAgICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRFbGVtZW50LCB0QXR0cnMsICR0cmFuc2NsdWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsICRlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ubG9hZEV4cCA9IGF0dHJzWydvbmxvYWQnXSB8fCAnJywgYXV0b1Njcm9sbEV4cCA9IGF0dHJzWydhdXRvc2Nyb2xsJ10sIHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIoYXR0cnMsIHNjb3BlKSwgaW5oZXJpdGVkID0gJGVsZW1lbnQuaW5oZXJpdGVkRGF0YSgnJHVpVmlldycpIHx8IHJvb3REYXRhLCBuYW1lID0gJGludGVycG9sYXRlKGF0dHJzWyd1aVZpZXcnXSB8fCBhdHRyc1snbmFtZSddIHx8ICcnKShzY29wZSkgfHwgJyRkZWZhdWx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0VsLCBjdXJyZW50RWwsIGN1cnJlbnRTY29wZSwgdmlld0NvbmZpZywgdW5yZWdpc3RlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVVSVZpZXcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHR5cGU6ICduZzEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkaXJlY3RpdmUuY291bnQrKyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZxbjogaW5oZXJpdGVkLiR1aVZpZXcuZnFuID8gaW5oZXJpdGVkLiR1aVZpZXcuZnFuICsgJy4nICsgbmFtZSA6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1VwZGF0ZWQ6IGNvbmZpZ1VwZGF0ZWRDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY3JlYXRpb25Db250ZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29udGV4dCBpbiB3aGljaCB0aGlzIHVpLXZpZXcgXCJ0YWdcIiB3YXMgY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVBhcmVudFRhZ0NvbmZpZyA9IGNvcmUucGFyc2UoJyRjZmcudmlld0RlY2wuJGNvbnRleHQnKShpbmhlcml0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyA8dWktdmlldyBuYW1lPVwiZm9vXCI+PHVpLXZpZXcgbmFtZT1cImJhclwiPjwvdWktdmlldz48L3VpLXZpZXc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1yb3V0ZXIvaXNzdWVzLzMzNTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21QYXJlbnRUYWcgPSBjb3JlLnBhcnNlKCckdWlWaWV3LmNyZWF0aW9uQ29udGV4dCcpKGluaGVyaXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tUGFyZW50VGFnQ29uZmlnIHx8IGZyb21QYXJlbnRUYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ0xpbmtpbmcnLCBhY3RpdmVVSVZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY29uZmlnVXBkYXRlZENhbGxiYWNrKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcgJiYgIShjb25maWcgaW5zdGFuY2VvZiBOZzFWaWV3Q29uZmlnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdzRXF1YWwodmlld0NvbmZpZywgY29uZmlnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdDb25maWdVcGRhdGVkKGFjdGl2ZVVJVmlldywgY29uZmlnICYmIGNvbmZpZy52aWV3RGVjbCAmJiBjb25maWcudmlld0RlY2wuJGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdDb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlldyhjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuZGF0YSgnJHVpVmlldycsIHsgJHVpVmlldzogYWN0aXZlVUlWaWV3IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlciA9ICR2aWV3LnJlZ2lzdGVyVUlWaWV3KGFjdGl2ZVVJVmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdFdmVudCgnRGVzdHJveWluZy9VbnJlZ2lzdGVyaW5nJywgYWN0aXZlVUlWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFudXBMYXN0VmlldygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ1JlbW92aW5nIChwcmV2aW91cykgZWwnLCBwcmV2aW91c0VsLmRhdGEoJyR1aVZpZXcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdFdmVudCgnRGVzdHJveWluZyBzY29wZScsIGFjdGl2ZVVJVmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdmlld0RhdGFfMSA9IGN1cnJlbnRFbC5kYXRhKCckdWlWaWV3QW5pbScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ0FuaW1hdGUgb3V0JywgX3ZpZXdEYXRhXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5sZWF2ZShjdXJyZW50RWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3RGF0YV8xLiQkYW5pbUxlYXZlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNFbCA9IGN1cnJlbnRFbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVWaWV3KGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTY29wZSA9IHNjb3BlLiRuZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbUVudGVyID0gJHEuZGVmZXIoKSwgYW5pbUxlYXZlID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHVpVmlld0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRjZmc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHVpVmlldzogYWN0aXZlVUlWaWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICR1aVZpZXdBbmltID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkYW5pbUVudGVyOiBhbmltRW50ZXIucHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1MZWF2ZTogYW5pbUxlYXZlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQkYW5pbUxlYXZlOiBhbmltTGVhdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmdkb2MgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXcjJHZpZXdDb250ZW50TG9hZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudE9mIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudFR5cGUgZW1pdHMgb24gdWktdmlldyBkaXJlY3RpdmUgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEZpcmVkIG9uY2UgdGhlIHZpZXcgKipiZWdpbnMgbG9hZGluZyoqLCAqYmVmb3JlKiB0aGUgRE9NIGlzIHJlbmRlcmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld05hbWUgTmFtZSBvZiB0aGUgdmlldy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY29wZS4kZW1pdCgnJHZpZXdDb250ZW50TG9hZGluZycsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZWQgPSAkdHJhbnNjbHVkZShuZXdTY29wZSwgZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lLmRhdGEoJyR1aVZpZXdBbmltJywgJHVpVmlld0FuaW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5kYXRhKCckdWlWaWV3JywgJHVpVmlld0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5lbnRlcihjbG9uZSwgJGVsZW1lbnQsIGZ1bmN0aW9uIG9uVUlWaWV3RW50ZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltRW50ZXIucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudEFuaW1hdGlvbkVuZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvcmUuaXNEZWZpbmVkKGF1dG9TY3JvbGxFeHApICYmICFhdXRvU2Nyb2xsRXhwKSB8fCBzY29wZS4kZXZhbChhdXRvU2Nyb2xsRXhwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR1aVZpZXdTY3JvbGwoY2xvbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cExhc3RWaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsID0gY2xvbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG5ld1Njb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlldyMkdmlld0NvbnRlbnRMb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnRPZiB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnRUeXBlIGVtaXRzIG9uIHVpLXZpZXcgZGlyZWN0aXZlIHNjb3BlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRmlyZWQgb25jZSB0aGUgdmlldyBpcyAqKmxvYWRlZCoqLCAqYWZ0ZXIqIHRoZSBET00gaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZW1pdCgnJHZpZXdDb250ZW50TG9hZGVkJywgY29uZmlnIHx8IHZpZXdDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZXZhbChvbmxvYWRFeHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZTtcbiAgICAgICAgfSxcbiAgICBdO1xuICAgICRWaWV3RGlyZWN0aXZlRmlsbC4kaW5qZWN0ID0gWyckY29tcGlsZScsICckY29udHJvbGxlcicsICckdHJhbnNpdGlvbnMnLCAnJHZpZXcnLCAnJHEnLCAnJHRpbWVvdXQnXTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uICRWaWV3RGlyZWN0aXZlRmlsbCgkY29tcGlsZSwgJGNvbnRyb2xsZXIsICR0cmFuc2l0aW9ucywgJHZpZXcsICRxLCAkdGltZW91dCkge1xuICAgICAgICB2YXIgZ2V0Q29udHJvbGxlckFzID0gY29yZS5wYXJzZSgndmlld0RlY2wuY29udHJvbGxlckFzJyk7XG4gICAgICAgIHZhciBnZXRSZXNvbHZlQXMgPSBjb3JlLnBhcnNlKCd2aWV3RGVjbC5yZXNvbHZlQXMnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRUNBJyxcbiAgICAgICAgICAgIHByaW9yaXR5OiAtNDAwLFxuICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWwgPSB0RWxlbWVudC5odG1sKCk7XG4gICAgICAgICAgICAgICAgdEVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCAkZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9ICRlbGVtZW50LmRhdGEoJyR1aVZpZXcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5odG1sKGluaXRpYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNvbXBpbGUoJGVsZW1lbnQuY29udGVudHMoKSkoc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZmcgPSBkYXRhLiRjZmcgfHwgeyB2aWV3RGVjbDoge30sIGdldFRlbXBsYXRlOiBjb3JlLm5vb3AgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVDdHggPSBjZmcucGF0aCAmJiBuZXcgY29yZS5SZXNvbHZlQ29udGV4dChjZmcucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICRlbGVtZW50Lmh0bWwoY2ZnLmdldFRlbXBsYXRlKCRlbGVtZW50LCByZXNvbHZlQ3R4KSB8fCBpbml0aWFsKTtcbiAgICAgICAgICAgICAgICAgICAgY29yZS50cmFjZS50cmFjZVVJVmlld0ZpbGwoZGF0YS4kdWlWaWV3LCAkZWxlbWVudC5odG1sKCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluayA9ICRjb21waWxlKCRlbGVtZW50LmNvbnRlbnRzKCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IGNmZy5jb250cm9sbGVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlckFzID0gZ2V0Q29udHJvbGxlckFzKGNmZyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlQXMgPSBnZXRSZXNvbHZlQXMoY2ZnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FscyA9IHJlc29sdmVDdHggJiYgZ2V0TG9jYWxzKHJlc29sdmVDdHgpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZVtyZXNvbHZlQXNdID0gbG9jYWxzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJJbnN0YW5jZSA9ICRjb250cm9sbGVyKGNvbnRyb2xsZXIsIGNvcmUuZXh0ZW5kKHt9LCBsb2NhbHMsIHsgJHNjb3BlOiBzY29wZSwgJGVsZW1lbnQ6ICRlbGVtZW50IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZVtjb250cm9sbGVyQXNdID0gY29udHJvbGxlckluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlW2NvbnRyb2xsZXJBc11bcmVzb2x2ZUFzXSA9IGxvY2FscztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFVzZSAkdmlldyBzZXJ2aWNlIGFzIGEgY2VudHJhbCBwb2ludCBmb3IgcmVnaXN0ZXJpbmcgY29tcG9uZW50LWxldmVsIGhvb2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuLCB3aGVuIGEgY29tcG9uZW50IGlzIGNyZWF0ZWQsIHRlbGwgdGhlICR2aWV3IHNlcnZpY2UsIHNvIGl0IGNhbiBpbnZva2UgaG9va3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICR2aWV3LmNvbXBvbmVudExvYWRlZChjb250cm9sbGVySW5zdGFuY2UsIHsgJHNjb3BlOiBzY29wZSwgJGVsZW1lbnQ6ICRlbGVtZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NvcGUuJG9uKCckZGVzdHJveScsICgpID0+ICR2aWV3LmNvbXBvbmVudFVubG9hZGVkKGNvbnRyb2xsZXJJbnN0YW5jZSwgeyAkc2NvcGU6IHNjb3BlLCAkZWxlbWVudDogJGVsZW1lbnQgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuZGF0YSgnJG5nQ29udHJvbGxlckNvbnRyb2xsZXInLCBjb250cm9sbGVySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuY2hpbGRyZW4oKS5kYXRhKCckbmdDb250cm9sbGVyQ29udHJvbGxlcicsIGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlckNvbnRyb2xsZXJDYWxsYmFja3MoJHEsICR0cmFuc2l0aW9ucywgY29udHJvbGxlckluc3RhbmNlLCBzY29wZSwgY2ZnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgY29tcG9uZW50IHRvIGFwcGVhciBpbiB0aGUgRE9NXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzU3RyaW5nKGNmZy52aWV3RGVjbC5jb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY21wXzEgPSBjZmcudmlld0RlY2wuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtlYm9iTmFtZSA9IGNvcmUua2Vib2JTdHJpbmcoY21wXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ1JlZ2V4cF8xID0gbmV3IFJlZ0V4cChcIl4oeC18ZGF0YS0pP1wiICsga2Vib2JOYW1lICsgXCIkXCIsICdpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0Q29tcG9uZW50Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlRWwgPSBbXS5zbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FsbCgkZWxlbWVudFswXS5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsICYmIGVsLnRhZ05hbWUgJiYgdGFnUmVnZXhwXzEuZXhlYyhlbC50YWdOYW1lKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZUVsICYmIG5nLmVsZW1lbnQoZGlyZWN0aXZlRWwpLmRhdGEoXCIkXCIgKyBjbXBfMSArIFwiQ29udHJvbGxlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVyZWdpc3RlcldhdGNoXzEgPSBzY29wZS4kd2F0Y2goZ2V0Q29tcG9uZW50Q29udHJvbGxlciwgZnVuY3Rpb24gKGN0cmxJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3RybEluc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJDb250cm9sbGVyQ2FsbGJhY2tzKCRxLCAkdHJhbnNpdGlvbnMsIGN0cmxJbnN0YW5jZSwgc2NvcGUsIGNmZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVyZWdpc3RlcldhdGNoXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpbmsoc2NvcGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHZhciBoYXNDb21wb25lbnRJbXBsID0gdHlwZW9mIG5nLm1vZHVsZSgndWkucm91dGVyJylbJ2NvbXBvbmVudCddID09PSAnZnVuY3Rpb24nO1xuICAgIC8qKiBAaGlkZGVuIGluY3JlbWVudGluZyBpZCAqL1xuICAgIHZhciBfdWlDYW5FeGl0SWQgPSAwO1xuICAgIC8qKiBAaGlkZGVuIFRPRE86IG1vdmUgdGhlc2UgY2FsbGJhY2tzIHRvICR2aWV3IGFuZC9vciBgL2hvb2tzL2NvbXBvbmVudHMudHNgIG9yIHNvbWV0aGluZyAqL1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQ29udHJvbGxlckNhbGxiYWNrcygkcSwgJHRyYW5zaXRpb25zLCBjb250cm9sbGVySW5zdGFuY2UsICRzY29wZSwgY2ZnKSB7XG4gICAgICAgIC8vIENhbGwgJG9uSW5pdCgpIEFTQVBcbiAgICAgICAgaWYgKGNvcmUuaXNGdW5jdGlvbihjb250cm9sbGVySW5zdGFuY2UuJG9uSW5pdCkgJiYgIShjZmcudmlld0RlY2wuY29tcG9uZW50ICYmIGhhc0NvbXBvbmVudEltcGwpKSB7XG4gICAgICAgICAgICBjb250cm9sbGVySW5zdGFuY2UuJG9uSW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3U3RhdGUgPSBjb3JlLnRhaWwoY2ZnLnBhdGgpLnN0YXRlLnNlbGY7XG4gICAgICAgIHZhciBob29rT3B0aW9ucyA9IHsgYmluZDogY29udHJvbGxlckluc3RhbmNlIH07XG4gICAgICAgIC8vIEFkZCBjb21wb25lbnQtbGV2ZWwgaG9vayBmb3Igb25VaVBhcmFtc0NoYW5nZWRcbiAgICAgICAgaWYgKGNvcmUuaXNGdW5jdGlvbihjb250cm9sbGVySW5zdGFuY2UudWlPblBhcmFtc0NoYW5nZWQpKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZUNvbnRleHQgPSBuZXcgY29yZS5SZXNvbHZlQ29udGV4dChjZmcucGF0aCk7XG4gICAgICAgICAgICB2YXIgdmlld0NyZWF0aW9uVHJhbnNfMSA9IHJlc29sdmVDb250ZXh0LmdldFJlc29sdmFibGUoJyR0cmFuc2l0aW9uJCcpLmRhdGE7XG4gICAgICAgICAgICAvLyBGaXJlIGNhbGxiYWNrIG9uIGFueSBzdWNjZXNzZnVsIHRyYW5zaXRpb25cbiAgICAgICAgICAgIHZhciBwYXJhbXNVcGRhdGVkID0gZnVuY3Rpb24gKCR0cmFuc2l0aW9uJCkge1xuICAgICAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlICR0cmFuc2l0aW9uJCBpcyB0aGUgc2FtZSBhcyB0aGUgdmlldyB3YXMgY3JlYXRlZCB3aXRoaW4uXG4gICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgJHRyYW5zaXRpb24kIHdpbGwgZXhpdCB0aGUgc3RhdGUgdGhlIHZpZXcgaXMgZm9yLlxuICAgICAgICAgICAgICAgIGlmICgkdHJhbnNpdGlvbiQgPT09IHZpZXdDcmVhdGlvblRyYW5zXzEgfHwgJHRyYW5zaXRpb24kLmV4aXRpbmcoKS5pbmRleE9mKHZpZXdTdGF0ZSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIHRvUGFyYW1zID0gJHRyYW5zaXRpb24kLnBhcmFtcygndG8nKTtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbVBhcmFtcyA9ICR0cmFuc2l0aW9uJC5wYXJhbXMoJ2Zyb20nKTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0Tm9kZVNjaGVtYSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnBhcmFtU2NoZW1hOyB9O1xuICAgICAgICAgICAgICAgIHZhciB0b1NjaGVtYSA9ICR0cmFuc2l0aW9uJFxuICAgICAgICAgICAgICAgICAgICAudHJlZUNoYW5nZXMoJ3RvJylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChnZXROb2RlU2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGNvcmUudW5uZXN0UiwgW10pO1xuICAgICAgICAgICAgICAgIHZhciBmcm9tU2NoZW1hID0gJHRyYW5zaXRpb24kXG4gICAgICAgICAgICAgICAgICAgIC50cmVlQ2hhbmdlcygnZnJvbScpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZ2V0Tm9kZVNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShjb3JlLnVubmVzdFIsIFtdKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0byBwYXJhbXMgdGhhdCBoYXZlIGRpZmZlcmVudCB2YWx1ZXMgdGhhbiB0aGUgZnJvbSBwYXJhbXNcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZFRvUGFyYW1zID0gdG9TY2hlbWEuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZnJvbVNjaGVtYS5pbmRleE9mKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeCA9PT0gLTEgfHwgIWZyb21TY2hlbWFbaWR4XS50eXBlLmVxdWFscyh0b1BhcmFtc1twYXJhbS5pZF0sIGZyb21QYXJhbXNbcGFyYW0uaWRdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHRyaWdnZXIgY2FsbGJhY2sgaWYgYSB0byBwYXJhbSBoYXMgY2hhbmdlZCBvciBpcyBuZXdcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZFRvUGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZEtleXNfMSA9IGNoYW5nZWRUb1BhcmFtcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIHBhcmFtcyB0byBvbmx5IGNoYW5nZWQvbmV3IHRvIHBhcmFtcy4gIGAkdHJhbnNpdGlvbiQucGFyYW1zKClgIG1heSBiZSB1c2VkIHRvIGdldCBhbGwgcGFyYW1zLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWVzID0gY29yZS5maWx0ZXIodG9QYXJhbXMsIGZ1bmN0aW9uICh2YWwsIGtleSkgeyByZXR1cm4gY2hhbmdlZEtleXNfMS5pbmRleE9mKGtleSkgIT09IC0xOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlckluc3RhbmNlLnVpT25QYXJhbXNDaGFuZ2VkKG5ld1ZhbHVlcywgJHRyYW5zaXRpb24kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCAkdHJhbnNpdGlvbnMub25TdWNjZXNzKHt9LCBwYXJhbXNVcGRhdGVkLCBob29rT3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjb21wb25lbnQtbGV2ZWwgaG9vayBmb3IgdWlDYW5FeGl0XG4gICAgICAgIGlmIChjb3JlLmlzRnVuY3Rpb24oY29udHJvbGxlckluc3RhbmNlLnVpQ2FuRXhpdCkpIHtcbiAgICAgICAgICAgIHZhciBpZF8xID0gX3VpQ2FuRXhpdElkKys7XG4gICAgICAgICAgICB2YXIgY2FjaGVQcm9wXzEgPSAnX3VpQ2FuRXhpdElkcyc7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgYSByZWRpcmVjdCB0cmFuc2l0aW9uIGFscmVhZHkgYW5zd2VyZWQgdHJ1dGh5XG4gICAgICAgICAgICB2YXIgcHJldlRydXRoeUFuc3dlcl8xID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdHJhbnMgJiYgKCh0cmFuc1tjYWNoZVByb3BfMV0gJiYgdHJhbnNbY2FjaGVQcm9wXzFdW2lkXzFdID09PSB0cnVlKSB8fCBwcmV2VHJ1dGh5QW5zd2VyXzEodHJhbnMucmVkaXJlY3RlZEZyb20oKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIElmIGEgdXNlciBhbnN3ZXJlZCB5ZXMsIGJ1dCB0aGUgdHJhbnNpdGlvbiB3YXMgbGF0ZXIgcmVkaXJlY3RlZCwgZG9uJ3QgYWxzbyBhc2sgZm9yIHRoZSBuZXcgcmVkaXJlY3QgdHJhbnNpdGlvblxuICAgICAgICAgICAgdmFyIHdyYXBwZWRIb29rID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgICAgICAgdmFyIGlkcyA9ICh0cmFuc1tjYWNoZVByb3BfMV0gPSB0cmFuc1tjYWNoZVByb3BfMV0gfHwge30pO1xuICAgICAgICAgICAgICAgIGlmICghcHJldlRydXRoeUFuc3dlcl8xKHRyYW5zKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihjb250cm9sbGVySW5zdGFuY2UudWlDYW5FeGl0KHRyYW5zKSk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsKSB7IHJldHVybiAoaWRzW2lkXzFdID0gdmFsICE9PSBmYWxzZSk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY3JpdGVyaWEgPSB7IGV4aXRpbmc6IHZpZXdTdGF0ZS5uYW1lIH07XG4gICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsICR0cmFuc2l0aW9ucy5vbkJlZm9yZShjcml0ZXJpYSwgd3JhcHBlZEhvb2ssIGhvb2tPcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmcubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5kaXJlY3RpdmUoJ3VpVmlldycsIHVpVmlldyk7XG4gICAgbmcubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5kaXJlY3RpdmUoJ3VpVmlldycsICRWaWV3RGlyZWN0aXZlRmlsbCk7XG5cbiAgICAvKiogQG1vZHVsZSBuZzEgKi8gLyoqICovXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiAkVmlld1Njcm9sbFByb3ZpZGVyKCkge1xuICAgICAgICB2YXIgdXNlQW5jaG9yU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXNlQW5jaG9yU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXNlQW5jaG9yU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4kZ2V0ID0gW1xuICAgICAgICAgICAgJyRhbmNob3JTY3JvbGwnLFxuICAgICAgICAgICAgJyR0aW1lb3V0JyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgkYW5jaG9yU2Nyb2xsLCAkdGltZW91dCkge1xuICAgICAgICAgICAgICAgIGlmICh1c2VBbmNob3JTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRhbmNob3JTY3JvbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRlbGVtZW50WzBdLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbmcubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5wcm92aWRlcignJHVpVmlld1Njcm9sbCcsICRWaWV3U2Nyb2xsUHJvdmlkZXIpO1xuXG4gICAgLyoqXG4gICAgICogTWFpbiBlbnRyeSBwb2ludCBmb3IgYW5ndWxhciAxLnggYnVpbGRcbiAgICAgKiBAbW9kdWxlIG5nMVxuICAgICAqLyAvKiogKi9cbiAgICB2YXIgaW5kZXggPSAndWkucm91dGVyJztcblxuICAgIE9iamVjdC5rZXlzKGNvcmUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBjb3JlW2tleV07IH0pO1xuICAgIGV4cG9ydHMuY29yZSA9IGNvcmU7XG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gaW5kZXg7XG4gICAgZXhwb3J0cy53YXRjaERpZ2VzdHMgPSB3YXRjaERpZ2VzdHM7XG4gICAgZXhwb3J0cy5nZXRMb2NhbHMgPSBnZXRMb2NhbHM7XG4gICAgZXhwb3J0cy5nZXROZzFWaWV3Q29uZmlnRmFjdG9yeSA9IGdldE5nMVZpZXdDb25maWdGYWN0b3J5O1xuICAgIGV4cG9ydHMubmcxVmlld3NCdWlsZGVyID0gbmcxVmlld3NCdWlsZGVyO1xuICAgIGV4cG9ydHMuTmcxVmlld0NvbmZpZyA9IE5nMVZpZXdDb25maWc7XG4gICAgZXhwb3J0cy5TdGF0ZVByb3ZpZGVyID0gU3RhdGVQcm92aWRlcjtcbiAgICBleHBvcnRzLlVybFJvdXRlclByb3ZpZGVyID0gVXJsUm91dGVyUHJvdmlkZXI7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWktcm91dGVyLWFuZ3VsYXJqcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBSYW5kb20gdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBpbiB0aGUgVUktUm91dGVyIGNvZGVcbiAqXG4gKiBUaGVzZSBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkLCBidXQgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICpcbiAqIEBwcmVmZXJyZWRcbiAqIEBtb2R1bGUgY29tbW9uXG4gKi9cbi8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuL3ByZWRpY2F0ZXNcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi9ob2ZcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi9jb3Jlc2VydmljZXNcIik7XG5leHBvcnRzLnJvb3QgPSAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmKSB8fFxuICAgICh0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsKSB8fFxuICAgIHRoaXM7XG52YXIgYW5ndWxhciA9IGV4cG9ydHMucm9vdC5hbmd1bGFyIHx8IHt9O1xuZXhwb3J0cy5mcm9tSnNvbiA9IGFuZ3VsYXIuZnJvbUpzb24gfHwgSlNPTi5wYXJzZS5iaW5kKEpTT04pO1xuZXhwb3J0cy50b0pzb24gPSBhbmd1bGFyLnRvSnNvbiB8fCBKU09OLnN0cmluZ2lmeS5iaW5kKEpTT04pO1xuZXhwb3J0cy5mb3JFYWNoID0gYW5ndWxhci5mb3JFYWNoIHx8IF9mb3JFYWNoO1xuZXhwb3J0cy5leHRlbmQgPSBPYmplY3QuYXNzaWduIHx8IF9leHRlbmQ7XG5leHBvcnRzLmVxdWFscyA9IGFuZ3VsYXIuZXF1YWxzIHx8IF9lcXVhbHM7XG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG59XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG5leHBvcnRzLm5vb3AgPSBub29wO1xuLyoqXG4gKiBCdWlsZHMgcHJveHkgZnVuY3Rpb25zIG9uIHRoZSBgdG9gIG9iamVjdCB3aGljaCBwYXNzIHRocm91Z2ggdG8gdGhlIGBmcm9tYCBvYmplY3QuXG4gKlxuICogRm9yIGVhY2gga2V5IGluIGBmbk5hbWVzYCwgY3JlYXRlcyBhIHByb3h5IGZ1bmN0aW9uIG9uIHRoZSBgdG9gIG9iamVjdC5cbiAqIFRoZSBwcm94eSBmdW5jdGlvbiBjYWxscyB0aGUgcmVhbCBmdW5jdGlvbiBvbiB0aGUgYGZyb21gIG9iamVjdC5cbiAqXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYW4gbmV3IGNsYXNzIGluc3RhbmNlIHdob3NlIGZ1bmN0aW9ucyBhcmUgcHJlYm91bmQgdG8gdGhlIG5ldydkIG9iamVjdC5cbiAqIGBgYGpzXG4gKiBjbGFzcyBGb28ge1xuICogICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gKiAgICAgLy8gQmluZHMgYWxsIGZ1bmN0aW9ucyBmcm9tIEZvby5wcm90b3R5cGUgdG8gJ3RoaXMnLFxuICogICAgIC8vIHRoZW4gY29waWVzIHRoZW0gdG8gJ3RoaXMnXG4gKiAgICAgYmluZEZ1bmN0aW9ucyhGb28ucHJvdG90eXBlLCB0aGlzLCB0aGlzKTtcbiAqICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICogICB9XG4gKlxuICogICBsb2coKSB7XG4gKiAgICAgY29uc29sZS5sb2codGhpcy5kYXRhKTtcbiAqICAgfVxuICogfVxuICpcbiAqIGxldCBteUZvbyA9IG5ldyBGb28oWzEsMiwzXSk7XG4gKiB2YXIgbG9naXQgPSBteUZvby5sb2c7XG4gKiBsb2dpdCgpOyAvLyBsb2dzIFsxLCAyLCAzXSBmcm9tIHRoZSBteUZvbyAndGhpcycgaW5zdGFuY2VcbiAqIGBgYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEgYm91bmQgdmVyc2lvbiBvZiBhIHNlcnZpY2UgZnVuY3Rpb24sIGFuZCBjb3BpZXMgaXQgdG8gYW5vdGhlciBvYmplY3RcbiAqIGBgYFxuICpcbiAqIHZhciBTb21lU2VydmljZSA9IHtcbiAqICAgdGhpcy5kYXRhID0gWzMsIDQsIDVdO1xuICogICB0aGlzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAvLyBDb25zdHJ1Y3RvciBmblxuICogZnVuY3Rpb24gT3RoZXJUaGluZygpIHtcbiAqICAgLy8gQmluZHMgYWxsIGZ1bmN0aW9ucyBmcm9tIFNvbWVTZXJ2aWNlIHRvIFNvbWVTZXJ2aWNlLFxuICogICAvLyB0aGVuIGNvcGllcyB0aGVtIHRvICd0aGlzJ1xuICogICBiaW5kRnVuY3Rpb25zKFNvbWVTZXJ2aWNlLCB0aGlzLCBTb21lU2VydmljZSk7XG4gKiB9XG4gKlxuICogbGV0IG15T3RoZXJUaGluZyA9IG5ldyBPdGhlclRoaW5nKCk7XG4gKiBteU90aGVyVGhpbmcubG9nKCk7IC8vIGxvZ3MgWzMsIDQsIDVdIGZyb20gU29tZVNlcnZpY2UncyAndGhpcydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzb3VyY2UgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHNvdXJjZSBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9ucyB0byBiZSBib3VuZFxuICogQHBhcmFtIHRhcmdldCBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdCB3aGljaCB3aWxsIHJlY2VpdmUgdGhlIGJvdW5kIGZ1bmN0aW9uc1xuICogQHBhcmFtIGJpbmQgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG9iamVjdCB3aGljaCB0aGUgZnVuY3Rpb25zIHdpbGwgYmUgYm91bmQgdG9cbiAqIEBwYXJhbSBmbk5hbWVzIFRoZSBmdW5jdGlvbiBuYW1lcyB3aGljaCB3aWxsIGJlIGJvdW5kIChEZWZhdWx0cyB0byBhbGwgdGhlIGZ1bmN0aW9ucyBmb3VuZCBvbiB0aGUgJ2Zyb20nIG9iamVjdClcbiAqIEBwYXJhbSBsYXRlYmluZCBJZiB0cnVlLCB0aGUgYmluZGluZyBvZiB0aGUgZnVuY3Rpb24gaXMgZGVsYXllZCB1bnRpbCB0aGUgZmlyc3QgdGltZSBpdCdzIGludm9rZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJveHlGdW5jdGlvbnMoc291cmNlLCB0YXJnZXQsIGJpbmQsIGZuTmFtZXMsIGxhdGViaW5kKSB7XG4gICAgaWYgKGxhdGViaW5kID09PSB2b2lkIDApIHsgbGF0ZWJpbmQgPSBmYWxzZTsgfVxuICAgIHZhciBiaW5kRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm5OYW1lKSB7IHJldHVybiBzb3VyY2UoKVtmbk5hbWVdLmJpbmQoYmluZCgpKTsgfTtcbiAgICB2YXIgbWFrZUxhdGVSZWJpbmRGbiA9IGZ1bmN0aW9uIChmbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxhdGVSZWJpbmRGdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRhcmdldFtmbk5hbWVdID0gYmluZEZ1bmN0aW9uKGZuTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2ZuTmFtZV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGZuTmFtZXMgPSBmbk5hbWVzIHx8IE9iamVjdC5rZXlzKHNvdXJjZSgpKTtcbiAgICByZXR1cm4gZm5OYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbmFtZSkge1xuICAgICAgICBhY2NbbmFtZV0gPSBsYXRlYmluZCA/IG1ha2VMYXRlUmViaW5kRm4obmFtZSkgOiBiaW5kRnVuY3Rpb24obmFtZSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdGFyZ2V0KTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJveHlGdW5jdGlvbnMgPSBjcmVhdGVQcm94eUZ1bmN0aW9ucztcbi8qKlxuICogcHJvdG90eXBhbCBpbmhlcml0YW5jZSBoZWxwZXIuXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aGljaCBoYXMgYHBhcmVudGAgb2JqZWN0IGFzIGl0cyBwcm90b3R5cGUsIGFuZCB0aGVuIGNvcGllcyB0aGUgcHJvcGVydGllcyBmcm9tIGBleHRyYWAgb250byBpdFxuICovXG5leHBvcnRzLmluaGVyaXQgPSBmdW5jdGlvbiAocGFyZW50LCBleHRyYSkgeyByZXR1cm4gZXhwb3J0cy5leHRlbmQoT2JqZWN0LmNyZWF0ZShwYXJlbnQpLCBleHRyYSk7IH07XG4vKiogR2l2ZW4gYW4gYXJyYXksIHJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGZvdW5kIGluIHRoZSBhcnJheSwgKHVzaW5nIGluZGV4T2YpICovXG5leHBvcnRzLmluQXJyYXkgPSBob2ZfMS5jdXJyeShfaW5BcnJheSk7XG5mdW5jdGlvbiBfaW5BcnJheShhcnJheSwgb2JqKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2Yob2JqKSAhPT0gLTE7XG59XG5leHBvcnRzLl9pbkFycmF5ID0gX2luQXJyYXk7XG4vKipcbiAqIEdpdmVuIGFuIGFycmF5LCBhbmQgYW4gaXRlbSwgaWYgdGhlIGl0ZW0gaXMgZm91bmQgaW4gdGhlIGFycmF5LCBpdCByZW1vdmVzIGl0IChpbi1wbGFjZSkuXG4gKiBUaGUgc2FtZSBhcnJheSBpcyByZXR1cm5lZFxuICovXG5leHBvcnRzLnJlbW92ZUZyb20gPSBob2ZfMS5jdXJyeShfcmVtb3ZlRnJvbSk7XG5mdW5jdGlvbiBfcmVtb3ZlRnJvbShhcnJheSwgb2JqKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5LmluZGV4T2Yob2JqKTtcbiAgICBpZiAoaWR4ID49IDApXG4gICAgICAgIGFycmF5LnNwbGljZShpZHgsIDEpO1xuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuX3JlbW92ZUZyb20gPSBfcmVtb3ZlRnJvbTtcbi8qKiBwdXNoZXMgYSB2YWx1ZXMgdG8gYW4gYXJyYXkgYW5kIHJldHVybnMgdGhlIHZhbHVlICovXG5leHBvcnRzLnB1c2hUbyA9IGhvZl8xLmN1cnJ5KF9wdXNoVG8pO1xuZnVuY3Rpb24gX3B1c2hUbyhhcnIsIHZhbCkge1xuICAgIHJldHVybiBhcnIucHVzaCh2YWwpLCB2YWw7XG59XG5leHBvcnRzLl9wdXNoVG8gPSBfcHVzaFRvO1xuLyoqIEdpdmVuIGFuIGFycmF5IG9mIChkZXJlZ2lzdHJhdGlvbikgZnVuY3Rpb25zLCBjYWxscyBhbGwgZnVuY3Rpb25zIGFuZCByZW1vdmVzIGVhY2ggb25lIGZyb20gdGhlIHNvdXJjZSBhcnJheSAqL1xuZXhwb3J0cy5kZXJlZ0FsbCA9IGZ1bmN0aW9uIChmdW5jdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25zLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIGZuKCk7XG4gICAgICAgIGV4cG9ydHMucmVtb3ZlRnJvbShmdW5jdGlvbnMsIGZuKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIEFwcGxpZXMgYSBzZXQgb2YgZGVmYXVsdHMgdG8gYW4gb3B0aW9ucyBvYmplY3QuICBUaGUgb3B0aW9ucyBvYmplY3QgaXMgZmlsdGVyZWRcbiAqIHRvIG9ubHkgdGhvc2UgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0cyBpbiB0aGUgZGVmYXVsdHNMaXN0LlxuICogRWFybGllciBvYmplY3RzIGluIHRoZSBkZWZhdWx0c0xpc3QgdGFrZSBwcmVjZWRlbmNlIHdoZW4gYXBwbHlpbmcgZGVmYXVsdHMuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRzKG9wdHMpIHtcbiAgICB2YXIgZGVmYXVsdHNMaXN0ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZGVmYXVsdHNMaXN0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgX2RlZmF1bHRzTGlzdCA9IGRlZmF1bHRzTGlzdC5jb25jYXQoe30pLnJldmVyc2UoKTtcbiAgICB2YXIgZGVmYXVsdFZhbHMgPSBleHBvcnRzLmV4dGVuZC5hcHBseShudWxsLCBfZGVmYXVsdHNMaXN0KTtcbiAgICByZXR1cm4gZXhwb3J0cy5leHRlbmQoe30sIGRlZmF1bHRWYWxzLCBwaWNrKG9wdHMgfHwge30sIE9iamVjdC5rZXlzKGRlZmF1bHRWYWxzKSkpO1xufVxuZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuLyoqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IG1lcmdlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgaW50byBhIHNpbmdsZSBvYmplY3QsIHVzaW5nIGV4dGVuZCAqL1xuZXhwb3J0cy5tZXJnZVIgPSBmdW5jdGlvbiAobWVtbywgaXRlbSkgeyByZXR1cm4gZXhwb3J0cy5leHRlbmQobWVtbywgaXRlbSk7IH07XG4vKipcbiAqIEZpbmRzIHRoZSBjb21tb24gYW5jZXN0b3IgcGF0aCBiZXR3ZWVuIHR3byBzdGF0ZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpcnN0IFRoZSBmaXJzdCBzdGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWNvbmQgVGhlIHNlY29uZCBzdGF0ZS5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlIG5hbWVzIGluIGRlc2NlbmRpbmcgb3JkZXIsIG5vdCBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gKi9cbmZ1bmN0aW9uIGFuY2VzdG9ycyhmaXJzdCwgc2Vjb25kKSB7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Zm9yaW5cbiAgICBmb3IgKHZhciBuIGluIGZpcnN0LnBhdGgpIHtcbiAgICAgICAgaWYgKGZpcnN0LnBhdGhbbl0gIT09IHNlY29uZC5wYXRoW25dKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBhdGgucHVzaChmaXJzdC5wYXRoW25dKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLmFuY2VzdG9ycyA9IGFuY2VzdG9ycztcbi8qKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBcbiAqIHZhciBmb28gPSB7IGE6IDEsIGI6IDIsIGM6IDMgfTtcbiAqIHZhciBhYiA9IHBpY2soZm9vLCBbJ2EnLCAnYiddKTsgLy8geyBhOiAxLCBiOiAyIH1cbiAqIGBgYFxuICogQHBhcmFtIG9iaiB0aGUgc291cmNlIG9iamVjdFxuICogQHBhcmFtIHByb3BOYW1lcyBhbiBBcnJheSBvZiBzdHJpbmdzLCB3aGljaCBhcmUgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnR5IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIHBpY2sob2JqLCBwcm9wTmFtZXMpIHtcbiAgICB2YXIgb2JqQ29weSA9IHt9O1xuICAgIGZvciAodmFyIF9wcm9wIGluIG9iaikge1xuICAgICAgICBpZiAocHJvcE5hbWVzLmluZGV4T2YoX3Byb3ApICE9PSAtMSkge1xuICAgICAgICAgICAgb2JqQ29weVtfcHJvcF0gPSBvYmpbX3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmpDb3B5O1xufVxuZXhwb3J0cy5waWNrID0gcGljaztcbi8qKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9taXR0aW5nIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiB2YXIgZm9vID0geyBhOiAxLCBiOiAyLCBjOiAzIH07XG4gKiB2YXIgYWIgPSBvbWl0KGZvbywgWydhJywgJ2InXSk7IC8vIHsgYzogMyB9XG4gKiBgYGBcbiAqIEBwYXJhbSBvYmogdGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSBwcm9wTmFtZXMgYW4gQXJyYXkgb2Ygc3RyaW5ncywgd2hpY2ggYXJlIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0eSBuYW1lc1xuICovXG5mdW5jdGlvbiBvbWl0KG9iaiwgcHJvcE5hbWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLmZpbHRlcihob2ZfMS5ub3QoZXhwb3J0cy5pbkFycmF5KHByb3BOYW1lcykpKVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkgeyByZXR1cm4gKChhY2Nba2V5XSA9IG9ialtrZXldKSwgYWNjKTsgfSwge30pO1xufVxuZXhwb3J0cy5vbWl0ID0gb21pdDtcbi8qKlxuICogTWFwcyBhbiBhcnJheSwgb3Igb2JqZWN0IHRvIGEgcHJvcGVydHkgKGJ5IG5hbWUpXG4gKi9cbmZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb24sIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCBob2ZfMS5wcm9wKHByb3BOYW1lKSk7XG59XG5leHBvcnRzLnBsdWNrID0gcGx1Y2s7XG4vKiogRmlsdGVycyBhbiBBcnJheSBvciBhbiBPYmplY3QncyBwcm9wZXJ0aWVzIGJhc2VkIG9uIGEgcHJlZGljYXRlICovXG5mdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJyID0gcHJlZGljYXRlc18xLmlzQXJyYXkoY29sbGVjdGlvbiksIHJlc3VsdCA9IGFyciA/IFtdIDoge307XG4gICAgdmFyIGFjY2VwdCA9IGFyciA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiByZXN1bHQucHVzaCh4KTsgfSA6IGZ1bmN0aW9uICh4LCBrZXkpIHsgcmV0dXJuIChyZXN1bHRba2V5XSA9IHgpOyB9O1xuICAgIGV4cG9ydHMuZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICBpZiAoY2FsbGJhY2soaXRlbSwgaSkpXG4gICAgICAgICAgICBhY2NlcHQoaXRlbSwgaSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuLyoqIEZpbmRzIGFuIG9iamVjdCBmcm9tIGFuIGFycmF5LCBvciBhIHByb3BlcnR5IG9mIGFuIG9iamVjdCwgdGhhdCBtYXRjaGVzIGEgcHJlZGljYXRlICovXG5mdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBleHBvcnRzLmZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZW0sIGkpKVxuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5maW5kID0gZmluZDtcbi8qKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybnMgYSBuZXcgb2JqZWN0LCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIHRyYW5zZm9ybWVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbiAqL1xuZXhwb3J0cy5tYXBPYmogPSBtYXA7XG4vKiogTWFwcyBhbiBhcnJheSBvciBvYmplY3QgcHJvcGVydGllcyB1c2luZyBhIGNhbGxiYWNrIGZ1bmN0aW9uICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRhcmdldCkge1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCAocHJlZGljYXRlc18xLmlzQXJyYXkoY29sbGVjdGlvbikgPyBbXSA6IHt9KTtcbiAgICBleHBvcnRzLmZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0sIGkpIHsgcmV0dXJuICh0YXJnZXRbaV0gPSBjYWxsYmFjayhpdGVtLCBpKSk7IH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbi8qKlxuICogR2l2ZW4gYW4gb2JqZWN0LCByZXR1cm4gaXRzIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBmb28gPSB7IGE6IDEsIGI6IDIsIGM6IDMgfVxuICogbGV0IHZhbHMgPSB2YWx1ZXMoZm9vKTsgLy8gWyAxLCAyLCAzIF1cbiAqIGBgYFxuICovXG5leHBvcnRzLnZhbHVlcyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9ialtrZXldOyB9KTsgfTtcbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGUgdmFsdWVzIGFyZSB0cnV0aHkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCB2YWxzID0gWyAxLCB0cnVlLCB7fSwgXCJoZWxsbyB3b3JsZFwiXTtcbiAqIHZhbHMucmVkdWNlKGFsbFRydWVSLCB0cnVlKTsgLy8gdHJ1ZVxuICpcbiAqIHZhbHMucHVzaCgwKTtcbiAqIHZhbHMucmVkdWNlKGFsbFRydWVSLCB0cnVlKTsgLy8gZmFsc2VcbiAqIGBgYFxuICovXG5leHBvcnRzLmFsbFRydWVSID0gZnVuY3Rpb24gKG1lbW8sIGVsZW0pIHsgcmV0dXJuIG1lbW8gJiYgZWxlbTsgfTtcbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGUgdmFsdWVzIGFyZSB0cnV0aHkuXG4gKlxuICogICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCB2YWxzID0gWyAwLCBudWxsLCB1bmRlZmluZWQgXTtcbiAqIHZhbHMucmVkdWNlKGFueVRydWVSLCB0cnVlKTsgLy8gZmFsc2VcbiAqXG4gKiB2YWxzLnB1c2goXCJoZWxsbyB3b3JsZFwiKTtcbiAqIHZhbHMucmVkdWNlKGFueVRydWVSLCB0cnVlKTsgLy8gdHJ1ZVxuICogYGBgXG4gKi9cbmV4cG9ydHMuYW55VHJ1ZVIgPSBmdW5jdGlvbiAobWVtbywgZWxlbSkgeyByZXR1cm4gbWVtbyB8fCBlbGVtOyB9O1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gd2hpY2ggdW4tbmVzdHMgYSBzaW5nbGUgbGV2ZWwgb2YgYXJyYXlzXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGlucHV0LnJlZHVjZSh1bm5lc3RSLCBbXSkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgWyBcImRvdWJsZSwgXCJuZXN0ZWRcIiBdIF1cbiAqIGBgYFxuICovXG5leHBvcnRzLnVubmVzdFIgPSBmdW5jdGlvbiAobWVtbywgZWxlbSkgeyByZXR1cm4gbWVtby5jb25jYXQoZWxlbSk7IH07XG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB3aGljaCByZWN1cnNpdmVseSB1bi1uZXN0cyBhbGwgYXJyYXlzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBpbnB1dCA9IFsgWyBcImFcIiwgXCJiXCIgXSwgWyBcImNcIiwgXCJkXCIgXSwgWyBbIFwiZG91YmxlXCIsIFwibmVzdGVkXCIgXSBdIF07XG4gKiBpbnB1dC5yZWR1Y2UodW5uZXN0UiwgW10pIC8vIFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZG91YmxlLCBcIm5lc3RlZFwiIF1cbiAqIGBgYFxuICovXG5leHBvcnRzLmZsYXR0ZW5SID0gZnVuY3Rpb24gKG1lbW8sIGVsZW0pIHtcbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzQXJyYXkoZWxlbSkgPyBtZW1vLmNvbmNhdChlbGVtLnJlZHVjZShleHBvcnRzLmZsYXR0ZW5SLCBbXSkpIDogcHVzaFIobWVtbywgZWxlbSk7XG59O1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCBwdXNoZXMgYW4gb2JqZWN0IHRvIGFuIGFycmF5LCB0aGVuIHJldHVybnMgdGhlIGFycmF5LlxuICogTW9zdGx5IGp1c3QgZm9yIFtbZmxhdHRlblJdXSBhbmQgW1t1bmlxUl1dXG4gKi9cbmZ1bmN0aW9uIHB1c2hSKGFyciwgb2JqKSB7XG4gICAgYXJyLnB1c2gob2JqKTtcbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy5wdXNoUiA9IHB1c2hSO1xuLyoqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IGZpbHRlcnMgb3V0IGR1cGxpY2F0ZXMgKi9cbmV4cG9ydHMudW5pcVIgPSBmdW5jdGlvbiAoYWNjLCB0b2tlbikgeyByZXR1cm4gKGV4cG9ydHMuaW5BcnJheShhY2MsIHRva2VuKSA/IGFjYyA6IHB1c2hSKGFjYywgdG9rZW4pKTsgfTtcbi8qKlxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggYSBzaW5nbGUgbGV2ZWwgb2YgYXJyYXlzIHVubmVzdGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogdW5uZXN0KGlucHV0KSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBbIFwiZG91YmxlLCBcIm5lc3RlZFwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydHMudW5uZXN0ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShleHBvcnRzLnVubmVzdFIsIFtdKTsgfTtcbi8qKlxuICogUmV0dXJuIGEgY29tcGxldGVseSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGZsYXR0ZW4oaW5wdXQpIC8vIFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZG91YmxlLCBcIm5lc3RlZFwiIF1cbiAqIGBgYFxuICovXG5leHBvcnRzLmZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGV4cG9ydHMuZmxhdHRlblIsIFtdKTsgfTtcbi8qKlxuICogR2l2ZW4gYSAuZmlsdGVyIFByZWRpY2F0ZSwgYnVpbGRzIGEgLmZpbHRlciBQcmVkaWNhdGUgd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBlbGVtZW50cyBkbyBub3QgcGFzcy5cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaXNOdW1iZXIgPSAob2JqKSA9PiB0eXBlb2Yob2JqKSA9PT0gJ251bWJlcic7XG4gKiBsZXQgYWxsTnVtYmVycyA9IFsgMSwgMiwgMywgNCwgNSBdO1xuICogYWxsTnVtYmVycy5maWx0ZXIoYXNzZXJ0UHJlZGljYXRlKGlzTnVtYmVyKSk7IC8vT0tcbiAqXG4gKiBsZXQgb25lU3RyaW5nID0gWyAxLCAyLCAzLCA0LCBcIjVcIiBdO1xuICogb25lU3RyaW5nLmZpbHRlcihhc3NlcnRQcmVkaWNhdGUoaXNOdW1iZXIsIFwiTm90IGFsbCBudW1iZXJzXCIpKTsgLy8gdGhyb3dzIEVycm9yKFwiXCJOb3QgYWxsIG51bWJlcnNcIlwiKTtcbiAqIGBgYFxuICovXG5leHBvcnRzLmFzc2VydFByZWRpY2F0ZSA9IGFzc2VydEZuO1xuLyoqXG4gKiBHaXZlbiBhIC5tYXAgZnVuY3Rpb24sIGJ1aWxkcyBhIC5tYXAgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBtYXBwZWQgZWxlbWVudHMgZG8gbm90IHBhc3MgYSB0cnV0aHluZXNzIHRlc3QuXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogdmFyIGRhdGEgPSB7IGZvbzogMSwgYmFyOiAyIH07XG4gKlxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJyBdXG4gKiBsZXQgdmFsdWVzID0ga2V5cy5tYXAoYXNzZXJ0TWFwKGtleSA9PiBkYXRhW2tleV0sIFwiS2V5IG5vdCBmb3VuZFwiKSk7XG4gKiAvLyB2YWx1ZXMgaXMgWzEsIDJdXG4gKlxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJywgJ2JheicgXVxuICogbGV0IHZhbHVlcyA9IGtleXMubWFwKGFzc2VydE1hcChrZXkgPT4gZGF0YVtrZXldLCBcIktleSBub3QgZm91bmRcIikpO1xuICogLy8gdGhyb3dzIEVycm9yKFwiS2V5IG5vdCBmb3VuZFwiKVxuICogYGBgXG4gKi9cbmV4cG9ydHMuYXNzZXJ0TWFwID0gYXNzZXJ0Rm47XG5mdW5jdGlvbiBhc3NlcnRGbihwcmVkaWNhdGVPck1hcCwgZXJyTXNnKSB7XG4gICAgaWYgKGVyck1zZyA9PT0gdm9pZCAwKSB7IGVyck1zZyA9ICdhc3NlcnQgZmFpbHVyZSc7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcHJlZGljYXRlT3JNYXAob2JqKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihlcnJNc2cpID8gZXJyTXNnKG9iaikgOiBlcnJNc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMuYXNzZXJ0Rm4gPSBhc3NlcnRGbjtcbi8qKlxuICogTGlrZSBfLnBhaXJzOiBHaXZlbiBhbiBvYmplY3QsIHJldHVybnMgYW4gYXJyYXkgb2Yga2V5L3ZhbHVlIHBhaXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIHBhaXJzKHsgZm9vOiBcIkZPT1wiLCBiYXI6IFwiQkFSIH0pIC8vIFsgWyBcImZvb1wiLCBcIkZPT1wiIF0sIFsgXCJiYXJcIjogXCJCQVJcIiBdIF1cbiAqIGBgYFxuICovXG5leHBvcnRzLnBhaXJzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gW2tleSwgb2JqW2tleV1dOyB9KTsgfTtcbi8qKlxuICogR2l2ZW4gdHdvIG9yIG1vcmUgcGFyYWxsZWwgYXJyYXlzLCByZXR1cm5zIGFuIGFycmF5IG9mIHR1cGxlcyB3aGVyZVxuICogZWFjaCB0dXBsZSBpcyBjb21wb3NlZCBvZiBbIGFbaV0sIGJbaV0sIC4uLiB6W2ldIF1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGZvbyA9IFsgMCwgMiwgNCwgNiBdO1xuICogbGV0IGJhciA9IFsgMSwgMywgNSwgNyBdO1xuICogbGV0IGJheiA9IFsgMTAsIDMwLCA1MCwgNzAgXTtcbiAqIGFycmF5VHVwbGVzKGZvbywgYmFyKTsgICAgICAgLy8gWyBbMCwgMV0sIFsyLCAzXSwgWzQsIDVdLCBbNiwgN10gXVxuICogYXJyYXlUdXBsZXMoZm9vLCBiYXIsIGJheik7ICAvLyBbIFswLCAxLCAxMF0sIFsyLCAzLCAzMF0sIFs0LCA1LCA1MF0sIFs2LCA3LCA3MF0gXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGFycmF5VHVwbGVzKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB2YXIgbWF4QXJyYXlMZW4gPSBhcmdzLnJlZHVjZShmdW5jdGlvbiAobWluLCBhcnIpIHsgcmV0dXJuIE1hdGgubWluKGFyci5sZW5ndGgsIG1pbik7IH0sIDkwMDcxOTkyNTQ3NDA5OTEpOyAvLyBha2EgMl41MyDiiJIgMSBha2EgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaG90IGZ1bmN0aW9uXG4gICAgICAgIC8vIFVucm9sbCB3aGVuIHRoZXJlIGFyZSAxLTQgYXJndW1lbnRzXG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldLCBhcmdzWzFdW2ldXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2FyZ3NbMF1baV0sIGFyZ3NbMV1baV0sIGFyZ3NbMl1baV1dKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXSwgYXJnc1sxXVtpXSwgYXJnc1syXVtpXSwgYXJnc1szXVtpXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcmdzLm1hcChmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2ldOyB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4QXJyYXlMZW47IGkrKykge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5hcnJheVR1cGxlcyA9IGFycmF5VHVwbGVzO1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gd2hpY2ggYnVpbGRzIGFuIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIFtrZXksIHZhbHVlXSBwYWlycy5cbiAqXG4gKiBFYWNoIGl0ZXJhdGlvbiBzZXRzIHRoZSBrZXkvdmFsIHBhaXIgb24gdGhlIG1lbW8gb2JqZWN0LCB0aGVuIHJldHVybnMgdGhlIG1lbW8gZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAqXG4gKiBFYWNoIGtleVZhbHVlVHVwbGUgc2hvdWxkIGJlIGFuIGFycmF5IHdpdGggdmFsdWVzIFsga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkgXVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiB2YXIgcGFpcnMgPSBbIFtcImZvb2tleVwiLCBcImZvb3ZhbFwiXSwgW1wiYmFya2V5XCIsIFwiYmFydmFsXCJdIF1cbiAqXG4gKiB2YXIgcGFpcnNUb09iaiA9IHBhaXJzLnJlZHVjZSgobWVtbywgcGFpcikgPT4gYXBwbHlQYWlycyhtZW1vLCBwYWlyKSwge30pXG4gKiAvLyBwYWlyc1RvT2JqID09IHsgZm9va2V5OiBcImZvb3ZhbFwiLCBiYXJrZXk6IFwiYmFydmFsXCIgfVxuICpcbiAqIC8vIE9yLCBtb3JlIHNpbXBseTpcbiAqIHZhciBwYWlyc1RvT2JqID0gcGFpcnMucmVkdWNlKGFwcGx5UGFpcnMsIHt9KVxuICogLy8gcGFpcnNUb09iaiA9PSB7IGZvb2tleTogXCJmb292YWxcIiwgYmFya2V5OiBcImJhcnZhbFwiIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBhcHBseVBhaXJzKG1lbW8sIGtleVZhbFR1cGxlKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgaWYgKHByZWRpY2F0ZXNfMS5pc0FycmF5KGtleVZhbFR1cGxlKSlcbiAgICAgICAga2V5ID0ga2V5VmFsVHVwbGVbMF0sIHZhbHVlID0ga2V5VmFsVHVwbGVbMV07XG4gICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNTdHJpbmcoa2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhcmFtZXRlcnMgdG8gYXBwbHlQYWlycycpO1xuICAgIG1lbW9ba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBtZW1vO1xufVxuZXhwb3J0cy5hcHBseVBhaXJzID0gYXBwbHlQYWlycztcbi8qKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheSAqL1xuZnVuY3Rpb24gdGFpbChhcnIpIHtcbiAgICByZXR1cm4gKGFyci5sZW5ndGggJiYgYXJyW2Fyci5sZW5ndGggLSAxXSkgfHwgdW5kZWZpbmVkO1xufVxuZXhwb3J0cy50YWlsID0gdGFpbDtcbi8qKlxuICogc2hhbGxvdyBjb3B5IGZyb20gc3JjIHRvIGRlc3RcbiAqL1xuZnVuY3Rpb24gY29weShzcmMsIGRlc3QpIHtcbiAgICBpZiAoZGVzdClcbiAgICAgICAgT2JqZWN0LmtleXMoZGVzdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZWxldGUgZGVzdFtrZXldOyB9KTtcbiAgICBpZiAoIWRlc3QpXG4gICAgICAgIGRlc3QgPSB7fTtcbiAgICByZXR1cm4gZXhwb3J0cy5leHRlbmQoZGVzdCwgc3JjKTtcbn1cbmV4cG9ydHMuY29weSA9IGNvcHk7XG4vKiogTmFpdmUgZm9yRWFjaCBpbXBsZW1lbnRhdGlvbiB3b3JrcyB3aXRoIE9iamVjdHMgb3IgQXJyYXlzICovXG5mdW5jdGlvbiBfZm9yRWFjaChvYmosIGNiLCBfdGhpcykge1xuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheShvYmopKVxuICAgICAgICByZXR1cm4gb2JqLmZvckVhY2goY2IsIF90aGlzKTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY2Iob2JqW2tleV0sIGtleSk7IH0pO1xufVxuZnVuY3Rpb24gX2V4dGVuZCh0b09iaikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0b09ialtrZXlzW2pdXSA9IG9ialtrZXlzW2pdXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9PYmo7XG59XG5leHBvcnRzLl9leHRlbmQgPSBfZXh0ZW5kO1xuZnVuY3Rpb24gX2VxdWFscyhvMSwgbzIpIHtcbiAgICBpZiAobzEgPT09IG8yKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobzEgPT09IG51bGwgfHwgbzIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobzEgIT09IG8xICYmIG8yICE9PSBvMilcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5hTiA9PT0gTmFOXG4gICAgdmFyIHQxID0gdHlwZW9mIG8xLCB0MiA9IHR5cGVvZiBvMjtcbiAgICBpZiAodDEgIT09IHQyIHx8IHQxICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciB0dXAgPSBbbzEsIG8yXTtcbiAgICBpZiAoaG9mXzEuYWxsKHByZWRpY2F0ZXNfMS5pc0FycmF5KSh0dXApKVxuICAgICAgICByZXR1cm4gX2FycmF5c0VxKG8xLCBvMik7XG4gICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNEYXRlKSh0dXApKVxuICAgICAgICByZXR1cm4gbzEuZ2V0VGltZSgpID09PSBvMi5nZXRUaW1lKCk7XG4gICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNSZWdFeHApKHR1cCkpXG4gICAgICAgIHJldHVybiBvMS50b1N0cmluZygpID09PSBvMi50b1N0cmluZygpO1xuICAgIGlmIChob2ZfMS5hbGwocHJlZGljYXRlc18xLmlzRnVuY3Rpb24pKHR1cCkpXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBtZWhcbiAgICB2YXIgcHJlZGljYXRlcyA9IFtwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbiwgcHJlZGljYXRlc18xLmlzQXJyYXksIHByZWRpY2F0ZXNfMS5pc0RhdGUsIHByZWRpY2F0ZXNfMS5pc1JlZ0V4cF07XG4gICAgaWYgKHByZWRpY2F0ZXMubWFwKGhvZl8xLmFueSkucmVkdWNlKGZ1bmN0aW9uIChiLCBmbikgeyByZXR1cm4gYiB8fCAhIWZuKHR1cCk7IH0sIGZhbHNlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBrZXlzID0ge307XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmZvcmluXG4gICAgZm9yICh2YXIga2V5IGluIG8xKSB7XG4gICAgICAgIGlmICghX2VxdWFscyhvMVtrZXldLCBvMltrZXldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAga2V5c1trZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG8yKSB7XG4gICAgICAgIGlmICgha2V5c1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIF9hcnJheXNFcShhMSwgYTIpIHtcbiAgICBpZiAoYTEubGVuZ3RoICE9PSBhMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYXJyYXlUdXBsZXMoYTEsIGEyKS5yZWR1Y2UoZnVuY3Rpb24gKGIsIHQpIHsgcmV0dXJuIGIgJiYgX2VxdWFscyh0WzBdLCB0WzFdKTsgfSwgdHJ1ZSk7XG59XG4vLyBpc3N1ZSAjMjY3NlxuZXhwb3J0cy5zaWxlbmNlVW5jYXVnaHRJblByb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZSkgeyByZXR1cm4gcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gMDsgfSkgJiYgcHJvbWlzZTsgfTtcbmV4cG9ydHMuc2lsZW50UmVqZWN0aW9uID0gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBleHBvcnRzLnNpbGVuY2VVbmNhdWdodEluUHJvbWlzZShjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QoZXJyb3IpKTsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm90SW1wbGVtZW50ZWQgPSBmdW5jdGlvbiAoZm5uYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZubmFtZSArIFwiKCk6IE5vIGNvcmVzZXJ2aWNlcyBpbXBsZW1lbnRhdGlvbiBmb3IgVUktUm91dGVyIGlzIGxvYWRlZC5cIik7XG59OyB9O1xudmFyIHNlcnZpY2VzID0ge1xuICAgICRxOiB1bmRlZmluZWQsXG4gICAgJGluamVjdG9yOiB1bmRlZmluZWQsXG59O1xuZXhwb3J0cy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZXNlcnZpY2VzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBjb3JlXG4gKi9cbi8qKlxuICogTWF0Y2hlcyBzdGF0ZSBuYW1lcyB1c2luZyBnbG9iLWxpa2UgcGF0dGVybiBzdHJpbmdzLlxuICpcbiAqIEdsb2JzIGNhbiBiZSB1c2VkIGluIHNwZWNpZmljIEFQSXMgaW5jbHVkaW5nOlxuICpcbiAqIC0gW1tTdGF0ZVNlcnZpY2UuaXNdXVxuICogLSBbW1N0YXRlU2VydmljZS5pbmNsdWRlc11dXG4gKiAtIFRoZSBmaXJzdCBhcmd1bWVudCB0byBIb29rIFJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgbGlrZSBbW1RyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnRdXVxuICogICAgLSBbW0hvb2tNYXRjaENyaXRlcmlhXV0gYW5kIFtbSG9va01hdGNoQ3JpdGVyaW9uXV1cbiAqXG4gKiBBIGBHbG9iYCBzdHJpbmcgaXMgYSBwYXR0ZXJuIHdoaWNoIG1hdGNoZXMgc3RhdGUgbmFtZXMuXG4gKiBOZXN0ZWQgc3RhdGUgbmFtZXMgYXJlIHNwbGl0IGludG8gc2VnbWVudHMgKHNlcGFyYXRlZCBieSBhIGRvdCkgd2hlbiBwcm9jZXNzaW5nLlxuICogVGhlIHN0YXRlIG5hbWVkIGBmb28uYmFyLmJhemAgaXMgc3BsaXQgaW50byB0aHJlZSBzZWdtZW50cyBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqXG4gKiBHbG9icyB3b3JrIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIHJ1bGVzOlxuICpcbiAqICMjIyBFeGFjdCBtYXRjaDpcbiAqXG4gKiBUaGUgZ2xvYiBgJ0EuQidgIG1hdGNoZXMgdGhlIHN0YXRlIG5hbWVkIGV4YWN0bHkgYCdBLkInYC5cbiAqXG4gKiB8IEdsb2IgICAgICAgIHxNYXRjaGVzIHN0YXRlcyBuYW1lZHxEb2VzIG5vdCBtYXRjaCBzdGF0ZSBuYW1lZHxcbiAqIHw6LS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBgJ0EnYCAgICAgICB8IGAnQSdgICAgICAgICAgICAgICAgfCBgJ0InYCAsIGAnQS5DJ2AgICAgICB8XG4gKiB8IGAnQS5CJ2AgICAgIHwgYCdBLkInYCAgICAgICAgICAgICB8IGAnQSdgICwgYCdBLkIuQydgICAgIHxcbiAqIHwgYCdmb28nYCAgICAgfCBgJ2ZvbydgICAgICAgICAgICAgIHwgYCdGT08nYCAsIGAnZm9vLmJhcidgfFxuICpcbiAqICMjIyBTaW5nbGUgc3RhciAoYCpgKVxuICpcbiAqIEEgc2luZ2xlIHN0YXIgKGAqYCkgaXMgYSB3aWxkY2FyZCB0aGF0IG1hdGNoZXMgZXhhY3RseSBvbmUgc2VnbWVudC5cbiAqXG4gKiB8IEdsb2IgICAgICAgIHxNYXRjaGVzIHN0YXRlcyBuYW1lZCAgfERvZXMgbm90IG1hdGNoIHN0YXRlIG5hbWVkIHxcbiAqIHw6LS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBgJyonYCAgICAgICB8IGAnQSdgICwgYCdaJ2AgICAgICAgIHwgYCdBLkInYCAsIGAnWi5ZLlgnYCAgICAgICB8XG4gKiB8IGAnQS4qJ2AgICAgIHwgYCdBLkInYCAsIGAnQS5DJ2AgICAgfCBgJ0EnYCAsIGAnQS5CLkMnYCAgICAgICAgIHxcbiAqIHwgYCdBLiouKidgICAgfCBgJ0EuQi5DJ2AgLCBgJ0EuWC5ZJ2B8IGAnQSdgLCBgJ0EuQidgICwgYCdaLlkuWCdgfFxuICpcbiAqICMjIyBEb3VibGUgc3RhciAoYCoqYClcbiAqXG4gKiBBIGRvdWJsZSBzdGFyIChgJyoqJ2ApIGlzIGEgd2lsZGNhcmQgdGhhdCBtYXRjaGVzICp6ZXJvIG9yIG1vcmUgc2VnbWVudHMqXG4gKlxuICogfCBHbG9iICAgICAgICB8TWF0Y2hlcyBzdGF0ZXMgbmFtZWQgICAgICAgICAgICAgICAgICAgICAgICAgICB8RG9lcyBub3QgbWF0Y2ggc3RhdGUgbmFtZWQgICAgICAgICB8XG4gKiB8Oi0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgYCcqKidgICAgICAgfCBgJ0EnYCAsIGAnQS5CJ2AsIGAnWi5ZLlgnYCAgICAgICAgICAgICAgICAgICAgfCAobWF0Y2hlcyBhbGwgc3RhdGVzKSAgICAgICAgICAgICAgfFxuICogfCBgJ0EuKionYCAgICB8IGAnQSdgICwgYCdBLkInYCAsIGAnQS5DLlgnYCAgICAgICAgICAgICAgICAgICB8IGAnWi5ZLlgnYCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IGAnKiouWCdgICAgIHwgYCdYJ2AgLCBgJ0EuWCdgICwgYCdaLlkuWCdgICAgICAgICAgICAgICAgICAgIHwgYCdBJ2AgLCBgJ0EubG9naW4uWidgICAgICAgICAgICAgIHxcbiAqIHwgYCdBLioqLlgnYCAgfCBgJ0EuWCdgICwgYCdBLkIuWCdgICwgYCdBLkIuQy5YJ2AgICAgICAgICAgICAgfCBgJ0EnYCAsIGAnQS5CLkMnYCAgICAgICAgICAgICAgICAgfFxuICpcbiAqL1xudmFyIEdsb2IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2xvYih0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuZ2xvYiA9IHRleHQuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIHJlZ2V4cFN0cmluZyA9IHRoaXMudGV4dFxuICAgICAgICAgICAgLnNwbGl0KCcuJylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgICAgICAgICAgaWYgKHNlZyA9PT0gJyoqJylcbiAgICAgICAgICAgICAgICByZXR1cm4gJyg/OnwoPzpcXFxcLlteLl0qKSopJztcbiAgICAgICAgICAgIGlmIChzZWcgPT09ICcqJylcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFwuW14uXSonO1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcLicgKyBzZWc7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cCgnXicgKyByZWdleHBTdHJpbmcgKyAnJCcpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgaGFzIGdsb2ItbGlrZSBjaGFyYWN0ZXJzIGluIGl0ICovXG4gICAgR2xvYi5pcyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiAhIS9bISwqXSsvLmV4ZWModGV4dCk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIGdsb2IgZnJvbSB0aGUgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBzdHJpbmcgaXNuJ3QgR2xvYi1saWtlICovXG4gICAgR2xvYi5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIEdsb2IuaXModGV4dCkgPyBuZXcgR2xvYih0ZXh0KSA6IG51bGw7XG4gICAgfTtcbiAgICBHbG9iLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwLnRlc3QoJy4nICsgbmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gR2xvYjtcbn0oKSk7XG5leHBvcnRzLkdsb2IgPSBHbG9iO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogSGlnaGVyIG9yZGVyIGZ1bmN0aW9uc1xuICpcbiAqIFRoZXNlIHV0aWxpdHkgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgYnV0IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAbW9kdWxlIGNvbW1vbl9ob2ZcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBmb3IgW1BhcnRpYWwgQXBwbGljYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhcnRpYWxfYXBwbGljYXRpb24pIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uIHdpdGggTiBwYXJhbWV0ZXJzLCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgc3VwcG9ydHMgcGFydGlhbCBhcHBsaWNhdGlvbi5cbiAqIFRoZSBuZXcgZnVuY3Rpb24gYWNjZXB0cyBhbnl3aGVyZSBmcm9tIDEgdG8gTiBwYXJhbWV0ZXJzLiAgV2hlbiB0aGF0IGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIE0gcGFyYW1ldGVycyxcbiAqIHdoZXJlIE0gaXMgbGVzcyB0aGFuIE4sIGl0IHJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgcGFyYW1ldGVycy4gIEl0IGNvbnRpbnVlcyB0b1xuICogYWNjZXB0IG1vcmUgcGFyYW1ldGVycyB1bnRpbCBhbGwgTiBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBzdXBwbGllZC5cbiAqXG4gKlxuICogVGhpcyBjb250cml2ZWQgZXhhbXBsZSB1c2VzIGEgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24gYXMgYW4gcHJlZGljYXRlLCB3aGljaCByZXR1cm5zIHRydWVcbiAqIGlmIGFuIG9iamVjdCBpcyBmb3VuZCBpbiBib3RoIGFycmF5cy5cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIC8vIHJldHVybnMgdHJ1ZSBpZiBhbiBvYmplY3QgaXMgaW4gYm90aCBvZiB0aGUgdHdvIGFycmF5c1xuICogZnVuY3Rpb24gaW5Cb3RoKGFycmF5MSwgYXJyYXkyLCBvYmplY3QpIHtcbiAqICAgcmV0dXJuIGFycmF5MS5pbmRleE9mKG9iamVjdCkgIT09IC0xICYmXG4gKiAgICAgICAgICBhcnJheTIuaW5kZXhPZihvYmplY3QpICE9PSAxO1xuICogfVxuICogbGV0IG9iajEsIG9iajIsIG9iajMsIG9iajQsIG9iajUsIG9iajYsIG9iajdcbiAqIGxldCBmb29zID0gW29iajEsIG9iajNdXG4gKiBsZXQgYmFycyA9IFtvYmozLCBvYmo0LCBvYmo1XVxuICpcbiAqIC8vIEEgY3VycmllZCBcImNvcHlcIiBvZiBpbkJvdGhcbiAqIGxldCBjdXJyaWVkSW5Cb3RoID0gY3VycnkoaW5Cb3RoKTtcbiAqIC8vIFBhcnRpYWxseSBhcHBseSBib3RoIHRoZSBhcnJheTEgYW5kIGFycmF5MlxuICogbGV0IGluRm9vc0FuZEJhcnMgPSBjdXJyaWVkSW5Cb3RoKGZvb3MsIGJhcnMpO1xuICpcbiAqIC8vIFN1cHBseSB0aGUgZmluYWwgYXJndW1lbnQ7IHNpbmNlIGFsbCBhcmd1bWVudHMgYXJlXG4gKiAvLyBzdXBwbGllZCwgdGhlIG9yaWdpbmFsIGluQm90aCBmdW5jdGlvbiBpcyB0aGVuIGNhbGxlZC5cbiAqIGxldCBvYmoxSW5Cb3RoID0gaW5Gb29zQW5kQmFycyhvYmoxKTsgLy8gZmFsc2VcbiAqXG4gKiAvLyBVc2UgdGhlIGluRm9vc0FuZEJhcnMgYXMgYSBwcmVkaWNhdGUuXG4gKiAvLyBGaWx0ZXIsIG9uIGVhY2ggaXRlcmF0aW9uLCBzdXBwbGllcyB0aGUgZmluYWwgYXJndW1lbnRcbiAqIGxldCBhbGxPYmpzID0gWyBvYmoxLCBvYmoyLCBvYmozLCBvYmo0LCBvYmo1LCBvYmo2LCBvYmo3IF07XG4gKiBsZXQgZm91bmRJbkJvdGggPSBhbGxPYmpzLmZpbHRlcihpbkZvb3NBbmRCYXJzKTsgLy8gWyBvYmozIF1cbiAqXG4gKiBgYGBcbiAqXG4gKiBTdG9sZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80Mzk0NzQ3L2phdmFzY3JpcHQtY3VycnktZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gZm5cbiAqIEByZXR1cm5zIHsqfGZ1bmN0aW9uKCk6ICgqfGFueSl9XG4gKi9cbmZ1bmN0aW9uIGN1cnJ5KGZuKSB7XG4gICAgdmFyIGluaXRpYWxfYXJncyA9IFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cywgWzFdKTtcbiAgICB2YXIgZnVuY19hcmdzX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBjdXJyaWVkKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID49IGZ1bmNfYXJnc19sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmllZChhcmdzLmNvbmNhdChbXS5zbGljZS5hcHBseShhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjdXJyaWVkKGluaXRpYWxfYXJncyk7XG59XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG4vKipcbiAqIEdpdmVuIGEgdmFyYXJncyBsaXN0IG9mIGZ1bmN0aW9ucywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY29tcG9zZXMgdGhlIGFyZ3VtZW50IGZ1bmN0aW9ucywgcmlnaHQtdG8tbGVmdFxuICogZ2l2ZW46IGYoeCksIGcoeCksIGgoeClcbiAqIGxldCBjb21wb3NlZCA9IGNvbXBvc2UoZixnLGgpXG4gKiB0aGVuLCBjb21wb3NlZCBpczogZihnKGgoeCkpKVxuICovXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IHN0YXJ0LCByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcG9zZSA9IGNvbXBvc2U7XG4vKipcbiAqIEdpdmVuIGEgdmFyYXJncyBsaXN0IG9mIGZ1bmN0aW9ucywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgY29tcG9zZXMgdGhlIGFyZ3VtZW50IGZ1bmN0aW9ucywgbGVmdC10by1yaWdodFxuICogZ2l2ZW46IGYoeCksIGcoeCksIGgoeClcbiAqIGxldCBwaXBlZCA9IHBpcGUoZixnLGgpO1xuICogdGhlbiwgcGlwZWQgaXM6IGgoZyhmKHgpKSlcbiAqL1xuZnVuY3Rpb24gcGlwZSgpIHtcbiAgICB2YXIgZnVuY3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBmdW5jc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykucmV2ZXJzZSgpKTtcbn1cbmV4cG9ydHMucGlwZSA9IHBpcGU7XG4vKipcbiAqIEdpdmVuIGEgcHJvcGVydHkgbmFtZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGF0IHByb3BlcnR5IGZyb20gYW4gb2JqZWN0XG4gKiBsZXQgb2JqID0geyBmb286IDEsIG5hbWU6IFwiYmxhcmdcIiB9O1xuICogbGV0IGdldE5hbWUgPSBwcm9wKFwibmFtZVwiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gXCJibGFyZ1wiXG4gKi9cbmV4cG9ydHMucHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgb2JqW25hbWVdOyB9OyB9O1xuLyoqXG4gKiBHaXZlbiBhIHByb3BlcnR5IG5hbWUgYW5kIGEgdmFsdWUsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBib29sZWFuIGJhc2VkIG9uIHdoZXRoZXJcbiAqIHRoZSBwYXNzZWQgb2JqZWN0IGhhcyBhIHByb3BlcnR5IHRoYXQgbWF0Y2hlcyB0aGUgdmFsdWVcbiAqIGxldCBvYmogPSB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH07XG4gKiBsZXQgZ2V0TmFtZSA9IHByb3BFcShcIm5hbWVcIiwgXCJibGFyZ1wiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gdHJ1ZVxuICovXG5leHBvcnRzLnByb3BFcSA9IGN1cnJ5KGZ1bmN0aW9uIChuYW1lLCBfdmFsLCBvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmpbbmFtZV0gPT09IF92YWw7IH0pO1xuLyoqXG4gKiBHaXZlbiBhIGRvdHRlZCBwcm9wZXJ0eSBuYW1lLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbmVzdGVkIHByb3BlcnR5IGZyb20gYW4gb2JqZWN0LCBvciB1bmRlZmluZWRcbiAqIGxldCBvYmogPSB7IGlkOiAxLCBuZXN0ZWRPYmo6IHsgZm9vOiAxLCBuYW1lOiBcImJsYXJnXCIgfSwgfTtcbiAqIGxldCBnZXROYW1lID0gcHJvcChcIm5lc3RlZE9iai5uYW1lXCIpO1xuICogZ2V0TmFtZShvYmopID09PSBcImJsYXJnXCJcbiAqIGxldCBwcm9wTm90Rm91bmQgPSBwcm9wKFwidGhpcy5wcm9wZXJ0eS5kb2VzbnQuZXhpc3RcIik7XG4gKiBwcm9wTm90Rm91bmQob2JqKSA9PT0gdW5kZWZpbmVkXG4gKi9cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcGlwZS5hcHBseShudWxsLCBuYW1lLnNwbGl0KCcuJykubWFwKGV4cG9ydHMucHJvcCkpOyB9O1xuLyoqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRydXRoeSBvciBmYWxzZXkgdmFsdWUsIHJldHVybnMgYVxuICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBvcHBvc2l0ZSAoZmFsc2V5IG9yIHRydXRoeSkgdmFsdWUgZ2l2ZW4gdGhlIHNhbWUgaW5wdXRzXG4gKi9cbmV4cG9ydHMubm90ID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiAhZm4uYXBwbHkobnVsbCwgYXJncyk7XG59OyB9O1xuLyoqXG4gKiBHaXZlbiB0d28gZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRydXRoeSBvciBmYWxzZXkgdmFsdWVzLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydXRoeVxuICogaWYgYm90aCBmdW5jdGlvbnMgcmV0dXJuIHRydXRoeSBmb3IgdGhlIGdpdmVuIGFyZ3VtZW50c1xuICovXG5mdW5jdGlvbiBhbmQoZm4xLCBmbjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbjEuYXBwbHkobnVsbCwgYXJncykgJiYgZm4yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG59XG5leHBvcnRzLmFuZCA9IGFuZDtcbi8qKlxuICogR2l2ZW4gdHdvIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0cnV0aHkgb3IgZmFsc2V5IHZhbHVlcywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnV0aHlcbiAqIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgZnVuY3Rpb25zIHJldHVybnMgdHJ1dGh5IGZvciB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIG9yKGZuMSwgZm4yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4xLmFwcGx5KG51bGwsIGFyZ3MpIHx8IGZuMi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9O1xufVxuZXhwb3J0cy5vciA9IG9yO1xuLyoqXG4gKiBDaGVjayBpZiBhbGwgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IG1hdGNoIGEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGZuMSBhIHByZWRpY2F0ZSBmdW5jdGlvbiBgZm4xYFxuICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBhcnJheSBhbmQgcmV0dXJucyB0cnVlIGlmIGBmbjFgIGlzIHRydWUgZm9yIGFsbCBlbGVtZW50cyBvZiB0aGUgYXJyYXlcbiAqL1xuZXhwb3J0cy5hbGwgPSBmdW5jdGlvbiAoZm4xKSB7IHJldHVybiBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChiLCB4KSB7IHJldHVybiBiICYmICEhZm4xKHgpOyB9LCB0cnVlKTsgfTsgfTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXG5leHBvcnRzLmFueSA9IGZ1bmN0aW9uIChmbjEpIHsgcmV0dXJuIGZ1bmN0aW9uIChhcnIpIHsgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGIsIHgpIHsgcmV0dXJuIGIgfHwgISFmbjEoeCk7IH0sIGZhbHNlKTsgfTsgfTtcbi8qKiBHaXZlbiBhIGNsYXNzLCByZXR1cm5zIGEgUHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgb2YgdGhhdCBjbGFzcyAqL1xuZXhwb3J0cy5pcyA9IGZ1bmN0aW9uIChjdG9yKSB7IHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgPT09IGN0b3IpIHx8IG9iaiBpbnN0YW5jZW9mIGN0b3I7XG59OyB9O1xuLyoqIEdpdmVuIGEgdmFsdWUsIHJldHVybnMgYSBQcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYW5vdGhlciB2YWx1ZSBpcyA9PT0gZXF1YWwgdG8gdGhlIG9yaWdpbmFsIHZhbHVlICovXG5leHBvcnRzLmVxID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBmdW5jdGlvbiAob3RoZXIpIHsgcmV0dXJuIHZhbHVlID09PSBvdGhlcjsgfTsgfTtcbi8qKiBHaXZlbiBhIHZhbHVlLCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgdmFsdWUgKi9cbmV4cG9ydHMudmFsID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY7IH07IH07XG5mdW5jdGlvbiBpbnZva2UoZm5OYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9ialtmbk5hbWVdLmFwcGx5KG9iaiwgYXJncyk7IH07XG59XG5leHBvcnRzLmludm9rZSA9IGludm9rZTtcbi8qKlxuICogU29ydGEgbGlrZSBQYXR0ZXJuIE1hdGNoaW5nIChhIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgY29uZGl0aW9uYWwgY29uc3RydWN0KVxuICpcbiAqIFNlZSBodHRwOi8vYzIuY29tL2NnaS93aWtpP1BhdHRlcm5NYXRjaGluZ1xuICpcbiAqIFRoaXMgaXMgYSBjb25kaXRpb25hbCBjb25zdHJ1Y3Qgd2hpY2ggYWxsb3dzIGEgc2VyaWVzIG9mIHByZWRpY2F0ZXMgYW5kIG91dHB1dCBmdW5jdGlvbnNcbiAqIHRvIGJlIGNoZWNrZWQgYW5kIHRoZW4gYXBwbGllZC4gIEVhY2ggcHJlZGljYXRlIHJlY2VpdmVzIHRoZSBpbnB1dC4gIElmIHRoZSBwcmVkaWNhdGVcbiAqIHJldHVybnMgdHJ1dGh5LCB0aGVuIGl0cyBtYXRjaGluZyBvdXRwdXQgZnVuY3Rpb24gKG1hcHBpbmcgZnVuY3Rpb24pIGlzIHByb3ZpZGVkIHdpdGhcbiAqIHRoZSBpbnB1dCBhbmQsIHRoZW4gdGhlIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBFYWNoIGNvbWJpbmF0aW9uICgyLXR1cGxlKSBvZiBwcmVkaWNhdGUgKyBvdXRwdXQgZnVuY3Rpb24gc2hvdWxkIGJlIHBsYWNlZCBpbiBhbiBhcnJheVxuICogb2Ygc2l6ZSAyOiBbIHByZWRpY2F0ZSwgbWFwRm4gXVxuICpcbiAqIFRoZXNlIDItdHVwbGVzIHNob3VsZCBiZSBwdXQgaW4gYW4gb3V0ZXIgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIC8vIEhlcmUncyBhIDItdHVwbGUgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGlzU3RyaW5nIHByZWRpY2F0ZVxuICogLy8gYW5kIHRoZSBzZWNvbmQgZWxlbWVudCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnB1dFxuICogbGV0IGZpcnN0VHVwbGUgPSBbIGFuZ3VsYXIuaXNTdHJpbmcsIChpbnB1dCkgPT4gYEhlcmVzIHlvdXIgc3RyaW5nICR7aW5wdXR9YCBdO1xuICpcbiAqIC8vIFNlY29uZCB0dXBsZTogcHJlZGljYXRlIFwiaXNOdW1iZXJcIiwgbWFwZm4gcmV0dXJucyBhIGRlc2NyaXB0aW9uXG4gKiBsZXQgc2Vjb25kVHVwbGUgPSBbIGFuZ3VsYXIuaXNOdW1iZXIsIChpbnB1dCkgPT4gYCgke2lucHV0fSkgVGhhdCdzIGEgbnVtYmVyIWAgXTtcbiAqXG4gKiBsZXQgdGhpcmQgPSBbIChpbnB1dCkgPT4gaW5wdXQgPT09IG51bGwsICAoaW5wdXQpID0+IGBPaCwgbnVsbC4uLmAgXTtcbiAqXG4gKiBsZXQgZm91cnRoID0gWyAoaW5wdXQpID0+IGlucHV0ID09PSB1bmRlZmluZWQsICAoaW5wdXQpID0+IGBub3RkZWZpbmVkYCBdO1xuICpcbiAqIGxldCBkZXNjcmlwdGlvbk9mID0gcGF0dGVybihbIGZpcnN0VHVwbGUsIHNlY29uZFR1cGxlLCB0aGlyZCwgZm91cnRoIF0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGRlc2NyaXB0aW9uT2YodW5kZWZpbmVkKSk7IC8vICdub3RkZWZpbmVkJ1xuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZig1NSkpOyAvLyAnKDU1KSBUaGF0J3MgYSBudW1iZXIhJ1xuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZihcImZvb1wiKSk7IC8vICdIZXJlJ3MgeW91ciBzdHJpbmcgZm9vJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHN0cnVjdCBBIDJEIGFycmF5LiAgRWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBzaG91bGQgYmUgYW4gYXJyYXksIGEgMi10dXBsZSxcbiAqIHdpdGggYSBQcmVkaWNhdGUgYW5kIGEgbWFwcGluZy9vdXRwdXQgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtmdW5jdGlvbihhbnkpOiAqfVxuICovXG5mdW5jdGlvbiBwYXR0ZXJuKHN0cnVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0cnVjdFtpXVswXSh4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0W2ldWzFdKHgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMucGF0dGVybiA9IHBhdHRlcm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgY29tbW9uICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tbW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvcmVzZXJ2aWNlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9nbG9iXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hvZlwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wcmVkaWNhdGVzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3F1ZXVlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0cmluZ3NcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhY2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogUHJlZGljYXRlc1xuICpcbiAqIFRoZXNlIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUvZmFsc2UgYmFzZWQgb24gdGhlIGlucHV0LlxuICogQWx0aG91Z2ggdGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgdGhleSBhcmUgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gKlxuICogQG1vZHVsZSBjb21tb25fcHJlZGljYXRlc1xuICovXG4vKiogKi9cbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuL2hvZlwiKTtcbnZhciBzdGF0ZU9iamVjdF8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3N0YXRlT2JqZWN0XCIpO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB0aXMgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSB0OyB9OyB9O1xuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IHRpcygndW5kZWZpbmVkJyk7XG5leHBvcnRzLmlzRGVmaW5lZCA9IGhvZl8xLm5vdChleHBvcnRzLmlzVW5kZWZpbmVkKTtcbmV4cG9ydHMuaXNOdWxsID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gPT09IG51bGw7IH07XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaG9mXzEub3IoZXhwb3J0cy5pc051bGwsIGV4cG9ydHMuaXNVbmRlZmluZWQpO1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gdGlzKCdmdW5jdGlvbicpO1xuZXhwb3J0cy5pc051bWJlciA9IHRpcygnbnVtYmVyJyk7XG5leHBvcnRzLmlzU3RyaW5nID0gdGlzKCdzdHJpbmcnKTtcbmV4cG9ydHMuaXNPYmplY3QgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7IH07XG5leHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuZXhwb3J0cy5pc0RhdGUgPSAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRvU3RyLmNhbGwoeCkgPT09ICdbb2JqZWN0IERhdGVdJzsgfSk7XG5leHBvcnRzLmlzUmVnRXhwID0gKGZ1bmN0aW9uICh4KSB7IHJldHVybiB0b1N0ci5jYWxsKHgpID09PSAnW29iamVjdCBSZWdFeHBdJzsgfSk7XG5leHBvcnRzLmlzU3RhdGUgPSBzdGF0ZU9iamVjdF8xLlN0YXRlT2JqZWN0LmlzU3RhdGU7XG4vKipcbiAqIFByZWRpY2F0ZSB3aGljaCBjaGVja3MgaWYgYSB2YWx1ZSBpcyBpbmplY3RhYmxlXG4gKlxuICogQSB2YWx1ZSBpcyBcImluamVjdGFibGVcIiBpZiBpdCBpcyBhIGZ1bmN0aW9uLCBvciBpZiBpdCBpcyBhbiBuZzEgYXJyYXktbm90YXRpb24tc3R5bGUgYXJyYXlcbiAqIHdoZXJlIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIGFycmF5IGFyZSBTdHJpbmdzLCBleGNlcHQgdGhlIGxhc3Qgb25lLCB3aGljaCBpcyBhIEZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGlzSW5qZWN0YWJsZSh2YWwpIHtcbiAgICBpZiAoZXhwb3J0cy5pc0FycmF5KHZhbCkgJiYgdmFsLmxlbmd0aCkge1xuICAgICAgICB2YXIgaGVhZCA9IHZhbC5zbGljZSgwLCAtMSksIHRhaWwgPSB2YWwuc2xpY2UoLTEpO1xuICAgICAgICByZXR1cm4gIShoZWFkLmZpbHRlcihob2ZfMS5ub3QoZXhwb3J0cy5pc1N0cmluZykpLmxlbmd0aCB8fCB0YWlsLmZpbHRlcihob2ZfMS5ub3QoZXhwb3J0cy5pc0Z1bmN0aW9uKSkubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNGdW5jdGlvbih2YWwpO1xufVxuZXhwb3J0cy5pc0luamVjdGFibGUgPSBpc0luamVjdGFibGU7XG4vKipcbiAqIFByZWRpY2F0ZSB3aGljaCBjaGVja3MgaWYgYSB2YWx1ZSBsb29rcyBsaWtlIGEgUHJvbWlzZVxuICpcbiAqIEl0IGlzIHByb2JhYmx5IGEgUHJvbWlzZSBpZiBpdCdzIGFuIG9iamVjdCwgYW5kIGl0IGhhcyBhIGB0aGVuYCBwcm9wZXJ0eSB3aGljaCBpcyBhIEZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMuaXNQcm9taXNlID0gaG9mXzEuYW5kKGV4cG9ydHMuaXNPYmplY3QsIGhvZl8xLnBpcGUoaG9mXzEucHJvcCgndGhlbicpLCBleHBvcnRzLmlzRnVuY3Rpb24pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWRpY2F0ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBjb21tb24gKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBRdWV1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWV1ZShfaXRlbXMsIF9saW1pdCkge1xuICAgICAgICBpZiAoX2l0ZW1zID09PSB2b2lkIDApIHsgX2l0ZW1zID0gW107IH1cbiAgICAgICAgaWYgKF9saW1pdCA9PT0gdm9pZCAwKSB7IF9saW1pdCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5faXRlbXMgPSBfaXRlbXM7XG4gICAgICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xuICAgICAgICB0aGlzLl9ldmljdExpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLm9uRXZpY3QgPSBjb21tb25fMS5wdXNoVG8odGhpcy5fZXZpY3RMaXN0ZW5lcnMpO1xuICAgIH1cbiAgICBRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5fbGltaXQgJiYgaXRlbXMubGVuZ3RoID4gdGhpcy5fbGltaXQpXG4gICAgICAgICAgICB0aGlzLmV2aWN0KCk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLmV2aWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX2V2aWN0TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbihpdGVtKTsgfSk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5zcGxpY2UoMCwgMSlbMF07XG4gICAgfTtcbiAgICBRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5faXRlbXM7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gICAgfTtcbiAgICBRdWV1ZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIHJldHVybiBpZHggPiAtMSAmJiB0aGlzLl9pdGVtcy5zcGxpY2UoaWR4LCAxKVswXTtcbiAgICB9O1xuICAgIFF1ZXVlLnByb3RvdHlwZS5wZWVrVGFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLnBlZWtIZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zaXplKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbMF07XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWU7XG59KCkpO1xuZXhwb3J0cy5RdWV1ZSA9IFF1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVldWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEZ1bmN0aW9ucyB0aGF0IG1hbmlwdWxhdGUgc3RyaW5nc1xuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQsIHRoZXkgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICpcbiAqIEBtb2R1bGUgY29tbW9uX3N0cmluZ3NcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi9wcmVkaWNhdGVzXCIpO1xudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnlcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi9ob2ZcIik7XG52YXIgdHJhbnNpdGlvbl8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblwiKTtcbnZhciByZXNvbHZhYmxlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZhYmxlXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHNob3J0ZW5lZCB0byBhIG1heGltdW0gbGVuZ3RoXG4gKlxuICogSWYgdGhlIHN0cmluZyBpcyBhbHJlYWR5IGxlc3MgdGhhbiB0aGUgYG1heGAgbGVuZ3RoLCByZXR1cm4gdGhlIHN0cmluZy5cbiAqIEVsc2UgcmV0dXJuIHRoZSBzdHJpbmcsIHNob3J0ZW5lZCB0byBgbWF4IC0gM2AgYW5kIGFwcGVuZCB0aHJlZSBkb3RzIChcIi4uLlwiKS5cbiAqXG4gKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRvIHJldHVyblxuICogQHBhcmFtIHN0ciB0aGUgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIG1heExlbmd0aChtYXgsIHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoIDw9IG1heClcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBtYXggLSAzKSArICcuLi4nO1xufVxuZXhwb3J0cy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcsIHdpdGggc3BhY2VzIGFkZGVkIHRvIHRoZSBlbmQsIHVwIHRvIGEgZGVzaXJlZCBzdHIgbGVuZ3RoXG4gKlxuICogSWYgdGhlIHN0cmluZyBpcyBhbHJlYWR5IGxvbmdlciB0aGFuIHRoZSBkZXNpcmVkIGxlbmd0aCwgcmV0dXJuIHRoZSBzdHJpbmcuXG4gKiBFbHNlIHJldHVybnMgdGhlIHN0cmluZywgd2l0aCBleHRyYSBzcGFjZXMgb24gdGhlIGVuZCwgc3VjaCB0aGF0IGl0IHJlYWNoZXMgYGxlbmd0aGAgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBkZXNpcmVkIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRvIHJldHVyblxuICogQHBhcmFtIHN0ciB0aGUgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHBhZFN0cmluZyhsZW5ndGgsIHN0cikge1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICBzdHIgKz0gJyAnO1xuICAgIHJldHVybiBzdHI7XG59XG5leHBvcnRzLnBhZFN0cmluZyA9IHBhZFN0cmluZztcbmZ1bmN0aW9uIGtlYm9iU3RyaW5nKGNhbWVsQ2FzZSkge1xuICAgIHJldHVybiBjYW1lbENhc2VcbiAgICAgICAgLnJlcGxhY2UoL14oW0EtWl0pLywgZnVuY3Rpb24gKCQxKSB7IHJldHVybiAkMS50b0xvd2VyQ2FzZSgpOyB9KSAvLyByZXBsYWNlIGZpcnN0IGNoYXJcbiAgICAgICAgLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKCQxKSB7IHJldHVybiAnLScgKyAkMS50b0xvd2VyQ2FzZSgpOyB9KTsgLy8gcmVwbGFjZSByZXN0XG59XG5leHBvcnRzLmtlYm9iU3RyaW5nID0ga2Vib2JTdHJpbmc7XG5mdW5jdGlvbiBfdG9Kc29uKG9iaikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xufVxuZnVuY3Rpb24gX2Zyb21Kc29uKGpzb24pIHtcbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzU3RyaW5nKGpzb24pID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG59XG5mdW5jdGlvbiBwcm9taXNlVG9TdHJpbmcocCkge1xuICAgIHJldHVybiBcIlByb21pc2UoXCIgKyBKU09OLnN0cmluZ2lmeShwKSArIFwiKVwiO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25Ub1N0cmluZyhmbikge1xuICAgIHZhciBmblN0ciA9IGZuVG9TdHJpbmcoZm4pO1xuICAgIHZhciBuYW1lZEZ1bmN0aW9uTWF0Y2ggPSBmblN0ci5tYXRjaCgvXihmdW5jdGlvbiBbXiBdK1xcKFteKV0qXFwpKS8pO1xuICAgIHZhciB0b1N0ciA9IG5hbWVkRnVuY3Rpb25NYXRjaCA/IG5hbWVkRnVuY3Rpb25NYXRjaFsxXSA6IGZuU3RyO1xuICAgIHZhciBmbk5hbWUgPSBmblsnbmFtZSddIHx8ICcnO1xuICAgIGlmIChmbk5hbWUgJiYgdG9TdHIubWF0Y2goL2Z1bmN0aW9uIFxcKC8pKSB7XG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24gJyArIGZuTmFtZSArIHRvU3RyLnN1YnN0cig5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvU3RyO1xufVxuZXhwb3J0cy5mdW5jdGlvblRvU3RyaW5nID0gZnVuY3Rpb25Ub1N0cmluZztcbmZ1bmN0aW9uIGZuVG9TdHJpbmcoZm4pIHtcbiAgICB2YXIgX2ZuID0gcHJlZGljYXRlc18xLmlzQXJyYXkoZm4pID8gZm4uc2xpY2UoLTEpWzBdIDogZm47XG4gICAgcmV0dXJuIChfZm4gJiYgX2ZuLnRvU3RyaW5nKCkpIHx8ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5mblRvU3RyaW5nID0gZm5Ub1N0cmluZztcbnZhciBzdHJpbmdpZnlQYXR0ZXJuRm4gPSBudWxsO1xudmFyIHN0cmluZ2lmeVBhdHRlcm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgaXNSZWplY3Rpb24gPSByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmlzUmVqZWN0aW9uUHJvbWlzZTtcbiAgICBzdHJpbmdpZnlQYXR0ZXJuRm4gPVxuICAgICAgICBzdHJpbmdpZnlQYXR0ZXJuRm4gfHxcbiAgICAgICAgICAgIGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICAgICAgICAgIFtob2ZfMS5ub3QocHJlZGljYXRlc18xLmlzRGVmaW5lZCksIGhvZl8xLnZhbCgndW5kZWZpbmVkJyldLFxuICAgICAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNOdWxsLCBob2ZfMS52YWwoJ251bGwnKV0sXG4gICAgICAgICAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc1Byb21pc2UsIGhvZl8xLnZhbCgnW1Byb21pc2VdJyldLFxuICAgICAgICAgICAgICAgIFtpc1JlamVjdGlvbiwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX3RyYW5zaXRpb25SZWplY3Rpb24udG9TdHJpbmcoKTsgfV0sXG4gICAgICAgICAgICAgICAgW2hvZl8xLmlzKHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24pLCBob2ZfMS5pbnZva2UoJ3RvU3RyaW5nJyldLFxuICAgICAgICAgICAgICAgIFtob2ZfMS5pcyh0cmFuc2l0aW9uXzEuVHJhbnNpdGlvbiksIGhvZl8xLmludm9rZSgndG9TdHJpbmcnKV0sXG4gICAgICAgICAgICAgICAgW2hvZl8xLmlzKHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKSwgaG9mXzEuaW52b2tlKCd0b1N0cmluZycpXSxcbiAgICAgICAgICAgICAgICBbcHJlZGljYXRlc18xLmlzSW5qZWN0YWJsZSwgZnVuY3Rpb25Ub1N0cmluZ10sXG4gICAgICAgICAgICAgICAgW2hvZl8xLnZhbCh0cnVlKSwgY29tbW9uXzEuaWRlbnRpdHldLFxuICAgICAgICAgICAgXSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVBhdHRlcm5Gbih2YWx1ZSk7XG59O1xuZnVuY3Rpb24gc3RyaW5naWZ5KG8pIHtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWx1ZSkgIT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiAnW2NpcmN1bGFyIHJlZl0nO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5UGF0dGVybih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgeyByZXR1cm4gZm9ybWF0KHZhbHVlKTsgfSkucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG4vKiogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgc3BsaXRzIGEgc3RyaW5nIG9uIGEgY2hhcmFjdGVyIG9yIHN1YnN0cmluZyAqL1xuZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0ciA9IGZ1bmN0aW9uIChjaGFyKSB7IHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKCFzdHIpXG4gICAgICAgIHJldHVybiBbJycsICcnXTtcbiAgICB2YXIgaWR4ID0gc3RyLmluZGV4T2YoY2hhcik7XG4gICAgaWYgKGlkeCA9PT0gLTEpXG4gICAgICAgIHJldHVybiBbc3RyLCAnJ107XG4gICAgcmV0dXJuIFtzdHIuc3Vic3RyKDAsIGlkeCksIHN0ci5zdWJzdHIoaWR4ICsgMSldO1xufTsgfTtcbmV4cG9ydHMuaG9zdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXig/OlthLXpdKzopPy8vW14vXSsvJyk7XG5leHBvcnRzLnN0cmlwTGFzdFBhdGhFbGVtZW50ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1xcL1teL10qJC8sICcnKTsgfTtcbmV4cG9ydHMuc3BsaXRIYXNoID0gZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0cignIycpO1xuZXhwb3J0cy5zcGxpdFF1ZXJ5ID0gZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0cignPycpO1xuZXhwb3J0cy5zcGxpdEVxdWFsID0gZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0cignPScpO1xuZXhwb3J0cy50cmltSGFzaFZhbCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIChzdHIgPyBzdHIucmVwbGFjZSgvXiMvLCAnJykgOiAnJyk7IH07XG4vKipcbiAqIFNwbGl0cyBvbiBhIGRlbGltaXRlciwgYnV0IHJldHVybnMgdGhlIGRlbGltaXRlcnMgaW4gdGhlIGFycmF5XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIHZhciBzcGxpdE9uU2xhc2hlcyA9IHNwbGl0T25EZWxpbSgnLycpO1xuICogc3BsaXRPblNsYXNoZXMoXCIvZm9vXCIpOyAvLyBbXCIvXCIsIFwiZm9vXCJdXG4gKiBzcGxpdE9uU2xhc2hlcyhcIi9mb28vXCIpOyAvLyBbXCIvXCIsIFwiZm9vXCIsIFwiL1wiXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHNwbGl0T25EZWxpbShkZWxpbSkge1xuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJygnICsgZGVsaW0gKyAnKScsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5zcGxpdChyZSkuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KTsgfTtcbn1cbmV4cG9ydHMuc3BsaXRPbkRlbGltID0gc3BsaXRPbkRlbGltO1xuLyoqXG4gKiBSZWR1Y2UgZm4gdGhhdCBqb2lucyBuZWlnaGJvcmluZyBzdHJpbmdzXG4gKlxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygc3RyaW5ncywgcmV0dXJucyBhIG5ldyBhcnJheVxuICogd2hlcmUgYWxsIG5laWdoYm9yaW5nIHN0cmluZ3MgaGF2ZSBiZWVuIGpvaW5lZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogbGV0IGFyciA9IFtcImZvb1wiLCBcImJhclwiLCAxLCBcImJhelwiLCBcIlwiLCBcInF1eFwiIF07XG4gKiBhcnIucmVkdWNlKGpvaW5OZWlnaGJvcnNSLCBbXSkgLy8gW1wiZm9vYmFyXCIsIDEsIFwiYmF6cXV4XCIgXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGpvaW5OZWlnaGJvcnNSKGFjYywgeCkge1xuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoY29tbW9uXzEudGFpbChhY2MpKSAmJiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkpXG4gICAgICAgIHJldHVybiBhY2Muc2xpY2UoMCwgLTEpLmNvbmNhdChjb21tb25fMS50YWlsKGFjYykgKyB4KTtcbiAgICByZXR1cm4gY29tbW9uXzEucHVzaFIoYWNjLCB4KTtcbn1cbmV4cG9ydHMuam9pbk5laWdoYm9yc1IgPSBqb2luTmVpZ2hib3JzUjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqICMgVHJhbnNpdGlvbiB0cmFjaW5nIChkZWJ1ZylcbiAqXG4gKiBFbmFibGUgdHJhbnNpdGlvbiB0cmFjaW5nIHRvIHByaW50IHRyYW5zaXRpb24gaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUsXG4gKiBpbiBvcmRlciB0byBoZWxwIGRlYnVnIHlvdXIgYXBwbGljYXRpb24uXG4gKiBUcmFjaW5nIGxvZ3MgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBUcmFuc2l0aW9uIHRvIHlvdXIgY29uc29sZS5cbiAqXG4gKiBUbyBlbmFibGUgdHJhY2luZywgaW1wb3J0IHRoZSBbW1RyYWNlXV0gc2luZ2xldG9uIGFuZCBlbmFibGUgb25lIG9yIG1vcmUgY2F0ZWdvcmllcy5cbiAqXG4gKiAjIyMgRVM2XG4gKiBgYGBqc1xuICogaW1wb3J0IHt0cmFjZX0gZnJvbSBcIkB1aXJvdXRlci9jb3JlXCI7XG4gKiB0cmFjZS5lbmFibGUoMSwgNSk7IC8vIFRSQU5TSVRJT04gYW5kIFZJRVdDT05GSUdcbiAqIGBgYFxuICpcbiAqICMjIyBDSlNcbiAqIGBgYGpzXG4gKiBsZXQgdHJhY2UgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIikudHJhY2U7XG4gKiB0cmFjZS5lbmFibGUoXCJUUkFOU0lUSU9OXCIsIFwiVklFV0NPTkZJR1wiKTtcbiAqIGBgYFxuICpcbiAqICMjIyBHbG9iYWxzXG4gKiBgYGBqc1xuICogbGV0IHRyYWNlID0gd2luZG93W1wiQHVpcm91dGVyL2NvcmVcIl0udHJhY2U7XG4gKiB0cmFjZS5lbmFibGUoKTsgLy8gVHJhY2UgZXZlcnl0aGluZyAodmVyeSB2ZXJib3NlKVxuICogYGBgXG4gKlxuICogIyMjIEFuZ3VsYXIgMTpcbiAqIGBgYGpzXG4gKiBhcHAucnVuKCR0cmFjZSA9PiAkdHJhY2UuZW5hYmxlKCkpO1xuICogYGBgXG4gKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhY2VcbiAqL1xuLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ3NcIik7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gdWlWaWV3U3RyaW5nKHVpdmlldykge1xuICAgIGlmICghdWl2aWV3KVxuICAgICAgICByZXR1cm4gJ3VpLXZpZXcgKGRlZnVuY3QpJztcbiAgICB2YXIgc3RhdGUgPSB1aXZpZXcuY3JlYXRpb25Db250ZXh0ID8gdWl2aWV3LmNyZWF0aW9uQ29udGV4dC5uYW1lIHx8ICcocm9vdCknIDogJyhub25lKSc7XG4gICAgcmV0dXJuIFwiW3VpLXZpZXcjXCIgKyB1aXZpZXcuaWQgKyBcIiBcIiArIHVpdmlldy4kdHlwZSArIFwiOlwiICsgdWl2aWV3LmZxbiArIFwiIChcIiArIHVpdmlldy5uYW1lICsgXCJAXCIgKyBzdGF0ZSArIFwiKV1cIjtcbn1cbi8qKiBAaGlkZGVuICovXG52YXIgdmlld0NvbmZpZ1N0cmluZyA9IGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7XG4gICAgdmFyIHZpZXcgPSB2aWV3Q29uZmlnLnZpZXdEZWNsO1xuICAgIHZhciBzdGF0ZSA9IHZpZXcuJGNvbnRleHQubmFtZSB8fCAnKHJvb3QpJztcbiAgICByZXR1cm4gXCJbVmlldyNcIiArIHZpZXdDb25maWcuJGlkICsgXCIgZnJvbSAnXCIgKyBzdGF0ZSArIFwiJyBzdGF0ZV06IHRhcmdldCB1aS12aWV3OiAnXCIgKyB2aWV3LiR1aVZpZXdOYW1lICsgXCJAXCIgKyB2aWV3LiR1aVZpZXdDb250ZXh0QW5jaG9yICsgXCInXCI7XG59O1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZWRDYXQoaW5wdXQpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzTnVtYmVyKGlucHV0KSA/IENhdGVnb3J5W2lucHV0XSA6IENhdGVnb3J5W0NhdGVnb3J5W2lucHV0XV07XG59XG4vKiogQGhpZGRlbiAqL1xudmFyIGNvbnNvbGVMb2cgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbi8qKiBAaGlkZGVuICovXG52YXIgY29uc29sZXRhYmxlID0gcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oY29uc29sZS50YWJsZSkgPyBjb25zb2xlLnRhYmxlLmJpbmQoY29uc29sZSkgOiBjb25zb2xlTG9nLmJpbmQoY29uc29sZSk7XG4vKipcbiAqIFRyYWNlIGNhdGVnb3JpZXMgRW51bVxuICpcbiAqIEVuYWJsZSBvciBkaXNhYmxlIGEgY2F0ZWdvcnkgdXNpbmcgW1tUcmFjZS5lbmFibGVdXSBvciBbW1RyYWNlLmRpc2FibGVdXVxuICpcbiAqIGB0cmFjZS5lbmFibGUoQ2F0ZWdvcnkuVFJBTlNJVElPTilgXG4gKlxuICogVGhlc2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgdXNpbmcgYSBtYXRjaGluZyBzdHJpbmcsIG9yIHBvc2l0aW9uIG9yZGluYWxcbiAqXG4gKiBgdHJhY2UuZW5hYmxlKFwiVFJBTlNJVElPTlwiKWBcbiAqXG4gKiBgdHJhY2UuZW5hYmxlKDEpYFxuICovXG52YXIgQ2F0ZWdvcnk7XG4oZnVuY3Rpb24gKENhdGVnb3J5KSB7XG4gICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJSRVNPTFZFXCJdID0gMF0gPSBcIlJFU09MVkVcIjtcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlRSQU5TSVRJT05cIl0gPSAxXSA9IFwiVFJBTlNJVElPTlwiO1xuICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiSE9PS1wiXSA9IDJdID0gXCJIT09LXCI7XG4gICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJVSVZJRVdcIl0gPSAzXSA9IFwiVUlWSUVXXCI7XG4gICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJWSUVXQ09ORklHXCJdID0gNF0gPSBcIlZJRVdDT05GSUdcIjtcbn0pKENhdGVnb3J5ID0gZXhwb3J0cy5DYXRlZ29yeSB8fCAoZXhwb3J0cy5DYXRlZ29yeSA9IHt9KSk7XG4vKiogQGhpZGRlbiAqL1xudmFyIF90aWQgPSBob2ZfMS5wYXJzZSgnJGlkJyk7XG4vKiogQGhpZGRlbiAqL1xudmFyIF9yaWQgPSBob2ZfMS5wYXJzZSgncm91dGVyLiRpZCcpO1xuLyoqIEBoaWRkZW4gKi9cbnZhciB0cmFuc0xibCA9IGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gXCJUcmFuc2l0aW9uICNcIiArIF90aWQodHJhbnMpICsgXCItXCIgKyBfcmlkKHRyYW5zKTsgfTtcbi8qKlxuICogUHJpbnRzIFVJLVJvdXRlciBUcmFuc2l0aW9uIHRyYWNlIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLlxuICovXG52YXIgVHJhY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiBUcmFjZSgpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHt9O1xuICAgICAgICB0aGlzLmFwcHJveGltYXRlRGlnZXN0cyA9IDA7XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhY2UucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAoZW5hYmxlZCwgY2F0ZWdvcmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWNhdGVnb3JpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gT2JqZWN0LmtleXMoQ2F0ZWdvcnkpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gcGFyc2VJbnQoaywgMTApOyB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuICFpc05hTihrKTsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIENhdGVnb3J5W2tleV07IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGVnb3JpZXMubWFwKG5vcm1hbGl6ZWRDYXQpLmZvckVhY2goZnVuY3Rpb24gKGNhdGVnb3J5KSB7IHJldHVybiAoX3RoaXMuX2VuYWJsZWRbY2F0ZWdvcnldID0gZW5hYmxlZCk7IH0pO1xuICAgIH07XG4gICAgVHJhY2UucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXQodHJ1ZSwgY2F0ZWdvcmllcyk7XG4gICAgfTtcbiAgICBUcmFjZS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXQoZmFsc2UsIGNhdGVnb3JpZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBlbmFibGVkIHN0YXRldXMgb2YgYSBbW0NhdGVnb3J5XV1cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogdHJhY2UuZW5hYmxlZChcIlZJRVdDT05GSUdcIik7IC8vIHRydWUgb3IgZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW4gdHJ1ZSBpZiB0aGUgY2F0ZWdvcnkgaXMgZW5hYmxlZFxuICAgICAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2VuYWJsZWRbbm9ybWFsaXplZENhdChjYXRlZ29yeSldO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VUcmFuc2l0aW9uU3RhcnQgPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiBTdGFydGVkICAtPiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodHJhbnMpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVHJhbnNpdGlvbklnbm9yZWQgPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiBJZ25vcmVkICA8PiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodHJhbnMpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlSG9va0ludm9jYXRpb24gPSBmdW5jdGlvbiAoc3RlcCwgdHJhbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuSE9PSykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBldmVudCA9IGhvZl8xLnBhcnNlKCd0cmFjZURhdGEuaG9va1R5cGUnKShvcHRpb25zKSB8fCAnaW50ZXJuYWwnLCBjb250ZXh0ID0gaG9mXzEucGFyc2UoJ3RyYWNlRGF0YS5jb250ZXh0LnN0YXRlLm5hbWUnKShvcHRpb25zKSB8fCBob2ZfMS5wYXJzZSgndHJhY2VEYXRhLmNvbnRleHQnKShvcHRpb25zKSB8fCAndW5rbm93bicsIG5hbWUgPSBzdHJpbmdzXzEuZnVuY3Rpb25Ub1N0cmluZyhzdGVwLnJlZ2lzdGVyZWRIb29rLmNhbGxiYWNrKTtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6ICAgSG9vayAtPiBcIiArIGV2ZW50ICsgXCIgY29udGV4dDogXCIgKyBjb250ZXh0ICsgXCIsIFwiICsgc3RyaW5nc18xLm1heExlbmd0aCgyMDAsIG5hbWUpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlSG9va1Jlc3VsdCA9IGZ1bmN0aW9uIChob29rUmVzdWx0LCB0cmFucywgdHJhbnNpdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuSE9PSykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiAgIDwtIEhvb2sgcmV0dXJuZWQ6IFwiICsgc3RyaW5nc18xLm1heExlbmd0aCgyMDAsIHN0cmluZ3NfMS5zdHJpbmdpZnkoaG9va1Jlc3VsdCkpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlUmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAocGF0aCwgd2hlbiwgdHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuUkVTT0xWRSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiAgICAgICAgIFJlc29sdmluZyBcIiArIHBhdGggKyBcIiAoXCIgKyB3aGVuICsgXCIpXCIpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VSZXNvbHZhYmxlUmVzb2x2ZWQgPSBmdW5jdGlvbiAocmVzb2x2YWJsZSwgdHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuUkVTT0xWRSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiAgICAgICAgICAgICAgIDwtIFJlc29sdmVkICBcIiArIHJlc29sdmFibGUgKyBcIiB0bzogXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgc3RyaW5nc18xLnN0cmluZ2lmeShyZXNvbHZhYmxlLmRhdGEpKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZUVycm9yID0gZnVuY3Rpb24gKHJlYXNvbiwgdHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiA8LSBSZWplY3RlZCBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodHJhbnMpICsgXCIsIHJlYXNvbjogXCIgKyByZWFzb24pO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VTdWNjZXNzID0gZnVuY3Rpb24gKGZpbmFsU3RhdGUsIHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogPC0gU3VjY2VzcyAgXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRyYW5zKSArIFwiLCBmaW5hbCBzdGF0ZTogXCIgKyBmaW5hbFN0YXRlLm5hbWUpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VVSVZpZXdFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdmlld0RhdGEsIGV4dHJhKSB7XG4gICAgICAgIGlmIChleHRyYSA9PT0gdm9pZCAwKSB7IGV4dHJhID0gJyc7IH1cbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2coXCJ1aS12aWV3OiBcIiArIHN0cmluZ3NfMS5wYWRTdHJpbmcoMzAsIGV2ZW50KSArIFwiIFwiICsgdWlWaWV3U3RyaW5nKHZpZXdEYXRhKSArIGV4dHJhKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVUlWaWV3Q29uZmlnVXBkYXRlZCA9IGZ1bmN0aW9uICh2aWV3RGF0YSwgY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5VSVZJRVcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyYWNlVUlWaWV3RXZlbnQoJ1VwZGF0aW5nJywgdmlld0RhdGEsIFwiIHdpdGggVmlld0NvbmZpZyBmcm9tIGNvbnRleHQ9J1wiICsgY29udGV4dCArIFwiJ1wiKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVUlWaWV3RmlsbCA9IGZ1bmN0aW9uICh2aWV3RGF0YSwgaHRtbCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5VSVZJRVcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyYWNlVUlWaWV3RXZlbnQoJ0ZpbGwnLCB2aWV3RGF0YSwgXCIgd2l0aDogXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgaHRtbCkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VWaWV3U3luYyA9IGZ1bmN0aW9uIChwYWlycykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5WSUVXQ09ORklHKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHVpdmhlYWRlciA9ICd1aXZpZXcgY29tcG9uZW50IGZxbic7XG4gICAgICAgIHZhciBjZmdoZWFkZXIgPSAndmlldyBjb25maWcgc3RhdGUgKHZpZXcgbmFtZSknO1xuICAgICAgICB2YXIgbWFwcGluZyA9IHBhaXJzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHVpVmlldyA9IF9hLnVpVmlldywgdmlld0NvbmZpZyA9IF9hLnZpZXdDb25maWc7XG4gICAgICAgICAgICB2YXIgdWl2ID0gdWlWaWV3ICYmIHVpVmlldy5mcW47XG4gICAgICAgICAgICB2YXIgY2ZnID0gdmlld0NvbmZpZyAmJiB2aWV3Q29uZmlnLnZpZXdEZWNsLiRjb250ZXh0Lm5hbWUgKyBcIjogKFwiICsgdmlld0NvbmZpZy52aWV3RGVjbC4kbmFtZSArIFwiKVwiO1xuICAgICAgICAgICAgcmV0dXJuIF9iID0ge30sIF9iW3VpdmhlYWRlcl0gPSB1aXYsIF9iW2NmZ2hlYWRlcl0gPSBjZmcsIF9iO1xuICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhW3VpdmhlYWRlcl0gfHwgJycpLmxvY2FsZUNvbXBhcmUoYlt1aXZoZWFkZXJdIHx8ICcnKTsgfSk7XG4gICAgICAgIGNvbnNvbGV0YWJsZShtYXBwaW5nKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1NlcnZpY2VFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdmlld0NvbmZpZykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5WSUVXQ09ORklHKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2coXCJWSUVXQ09ORklHOiBcIiArIGV2ZW50ICsgXCIgXCIgKyB2aWV3Q29uZmlnU3RyaW5nKHZpZXdDb25maWcpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdmlld0RhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVklFV0NPTkZJRykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVklFV0NPTkZJRzogXCIgKyBldmVudCArIFwiIFwiICsgdWlWaWV3U3RyaW5nKHZpZXdEYXRhKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2U7XG59KCkpO1xuZXhwb3J0cy5UcmFjZSA9IFRyYWNlO1xuLyoqXG4gKiBUaGUgW1tUcmFjZV1dIHNpbmdsZXRvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiBpbXBvcnQge3RyYWNlfSBmcm9tIFwiQHVpcm91dGVyL2NvcmVcIjtcbiAqIHRyYWNlLmVuYWJsZSgxLCA1KTtcbiAqIGBgYFxuICovXG52YXIgdHJhY2UgPSBuZXcgVHJhY2UoKTtcbmV4cG9ydHMudHJhY2UgPSB0cmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBjb3JlXG4gKi8gLyoqICovXG52YXIgc3RhdGVQYXJhbXNfMSA9IHJlcXVpcmUoXCIuL3BhcmFtcy9zdGF0ZVBhcmFtc1wiKTtcbnZhciBxdWV1ZV8xID0gcmVxdWlyZShcIi4vY29tbW9uL3F1ZXVlXCIpO1xuLyoqXG4gKiBHbG9iYWwgcm91dGVyIHN0YXRlXG4gKlxuICogVGhpcyBpcyB3aGVyZSB3ZSBob2xkIHRoZSBnbG9iYWwgbXV0YWJsZSBzdGF0ZSBzdWNoIGFzIGN1cnJlbnQgc3RhdGUsIGN1cnJlbnRcbiAqIHBhcmFtcywgY3VycmVudCB0cmFuc2l0aW9uLCBldGMuXG4gKi9cbnZhciBVSVJvdXRlckdsb2JhbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVUlSb3V0ZXJHbG9iYWxzKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBwYXJhbWV0ZXIgdmFsdWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwYXJhbWV0ZXIgdmFsdWVzIGZyb20gdGhlIGxhdGVzdCBzdWNjZXNzZnVsIHRyYW5zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyYW1zID0gbmV3IHN0YXRlUGFyYW1zXzEuU3RhdGVQYXJhbXMoKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgICAgICB0aGlzLmxhc3RTdGFydGVkVHJhbnNpdGlvbklkID0gLTE7XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICAgICAgdGhpcy50cmFuc2l0aW9uSGlzdG9yeSA9IG5ldyBxdWV1ZV8xLlF1ZXVlKFtdLCAxKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgICAgICB0aGlzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucyA9IG5ldyBxdWV1ZV8xLlF1ZXVlKFtdLCAxKTtcbiAgICB9XG4gICAgVUlSb3V0ZXJHbG9iYWxzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25IaXN0b3J5LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVUlSb3V0ZXJHbG9iYWxzO1xufSgpKTtcbmV4cG9ydHMuVUlSb3V0ZXJHbG9iYWxzID0gVUlSb3V0ZXJHbG9iYWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYmFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xudmFyIHRyYW5zaXRpb25fMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25cIik7XG52YXIgcm91dGVyXzEgPSByZXF1aXJlKFwiLi4vcm91dGVyXCIpO1xudmFyIHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmZ1bmN0aW9uIGFkZENvcmVSZXNvbHZhYmxlcyh0cmFucykge1xuICAgIHRyYW5zLmFkZFJlc29sdmFibGUocmVzb2x2ZV8xLlJlc29sdmFibGUuZnJvbURhdGEocm91dGVyXzEuVUlSb3V0ZXIsIHRyYW5zLnJvdXRlciksICcnKTtcbiAgICB0cmFucy5hZGRSZXNvbHZhYmxlKHJlc29sdmVfMS5SZXNvbHZhYmxlLmZyb21EYXRhKHRyYW5zaXRpb25fMS5UcmFuc2l0aW9uLCB0cmFucyksICcnKTtcbiAgICB0cmFucy5hZGRSZXNvbHZhYmxlKHJlc29sdmVfMS5SZXNvbHZhYmxlLmZyb21EYXRhKCckdHJhbnNpdGlvbiQnLCB0cmFucyksICcnKTtcbiAgICB0cmFucy5hZGRSZXNvbHZhYmxlKHJlc29sdmVfMS5SZXNvbHZhYmxlLmZyb21EYXRhKCckc3RhdGVQYXJhbXMnLCB0cmFucy5wYXJhbXMoKSksICcnKTtcbiAgICB0cmFucy5lbnRlcmluZygpLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHRyYW5zLmFkZFJlc29sdmFibGUocmVzb2x2ZV8xLlJlc29sdmFibGUuZnJvbURhdGEoJyRzdGF0ZSQnLCBzdGF0ZSksIHN0YXRlKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJBZGRDb3JlUmVzb2x2YWJsZXMgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25DcmVhdGUoe30sIGFkZENvcmVSZXNvbHZhYmxlcyk7XG59O1xudmFyIFRSQU5TSVRJT05fVE9LRU5TID0gWyckdHJhbnNpdGlvbiQnLCB0cmFuc2l0aW9uXzEuVHJhbnNpdGlvbl07XG52YXIgaXNUcmFuc2l0aW9uID0gY29tbW9uXzEuaW5BcnJheShUUkFOU0lUSU9OX1RPS0VOUyk7XG4vLyBSZWZlcmVuY2VzIHRvIFRyYW5zaXRpb24gaW4gdGhlIHRyZWVDaGFuZ2VzIHBhdGhub2RlcyBtYWtlcyBhbGxcbi8vIHByZXZpb3VzIFRyYW5zaXRpb25zIHJlYWNoYWJsZSBpbiBtZW1vcnksIGNhdXNpbmcgYSBtZW1vcnkgbGVha1xuLy8gVGhpcyBmdW5jdGlvbiByZW1vdmVzIHJlc29sdmVzIGZvciAnJHRyYW5zaXRpb24kJyBhbmQgYFRyYW5zaXRpb25gIGZyb20gdGhlIHRyZWVDaGFuZ2VzLlxuLy8gRG8gbm90IHVzZSB0aGlzIG9uIGN1cnJlbnQgdHJhbnNpdGlvbnMsIG9ubHkgb24gb2xkIG9uZXMuXG5leHBvcnRzLnRyZWVDaGFuZ2VzQ2xlYW51cCA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgIHZhciBub2RlcyA9IGNvbW1vbl8xLnZhbHVlcyh0cmFucy50cmVlQ2hhbmdlcygpKVxuICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVuaXFSLCBbXSk7XG4gICAgLy8gSWYgdGhlIHJlc29sdmFibGUgaXMgYSBUcmFuc2l0aW9uLCByZXR1cm4gYSBuZXcgcmVzb2x2YWJsZSB3aXRoIG51bGwgZGF0YVxuICAgIHZhciByZXBsYWNlVHJhbnNpdGlvbldpdGhOdWxsID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNpdGlvbihyLnRva2VuKSA/IHJlc29sdmVfMS5SZXNvbHZhYmxlLmZyb21EYXRhKHIudG9rZW4sIG51bGwpIDogcjtcbiAgICB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5yZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMubWFwKHJlcGxhY2VUcmFuc2l0aW9uV2l0aE51bGwpO1xuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmVSZXNvbHZhYmxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnlcIik7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCBza2lwcyBhIHRyYW5zaXRpb24gaWYgaXQgc2hvdWxkIGJlIGlnbm9yZWRcbiAqXG4gKiBUaGlzIGhvb2sgaXMgaW52b2tlZCBhdCB0aGUgZW5kIG9mIHRoZSBvbkJlZm9yZSBwaGFzZS5cbiAqXG4gKiBJZiB0aGUgdHJhbnNpdGlvbiBzaG91bGQgYmUgaWdub3JlZCAoYmVjYXVzZSBubyBwYXJhbWV0ZXIgb3Igc3RhdGVzIGNoYW5nZWQpXG4gKiB0aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQgYW5kIG5vdCBwcm9jZXNzZWQuXG4gKi9cbmZ1bmN0aW9uIGlnbm9yZWRIb29rKHRyYW5zKSB7XG4gICAgdmFyIGlnbm9yZWRSZWFzb24gPSB0cmFucy5faWdub3JlZFJlYXNvbigpO1xuICAgIGlmICghaWdub3JlZFJlYXNvbilcbiAgICAgICAgcmV0dXJuO1xuICAgIHRyYWNlXzEudHJhY2UudHJhY2VUcmFuc2l0aW9uSWdub3JlZCh0cmFucyk7XG4gICAgdmFyIHBlbmRpbmcgPSB0cmFucy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uO1xuICAgIC8vIFRoZSB1c2VyIGNsaWNrZWQgYSBsaW5rIGdvaW5nIGJhY2sgdG8gdGhlICpjdXJyZW50IHN0YXRlKiAoJ0EnKVxuICAgIC8vIEhvd2V2ZXIsIHRoZXJlIGlzIGFsc28gYSBwZW5kaW5nIHRyYW5zaXRpb24gaW4gZmxpZ2h0ICh0byAnQicpXG4gICAgLy8gQWJvcnQgdGhlIHRyYW5zaXRpb24gdG8gJ0InIGJlY2F1c2UgdGhlIHVzZXIgbm93IHdhbnRzIHRvIGJlIGJhY2sgYXQgJ0EnLlxuICAgIGlmIChpZ25vcmVkUmVhc29uID09PSAnU2FtZUFzQ3VycmVudCcgJiYgcGVuZGluZykge1xuICAgICAgICBwZW5kaW5nLmFib3J0KCk7XG4gICAgfVxuICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmlnbm9yZWQoKS50b1Byb21pc2UoKTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJJZ25vcmVkVHJhbnNpdGlvbkhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sIGlnbm9yZWRIb29rLCB7IHByaW9yaXR5OiAtOTk5OSB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZ25vcmVkVHJhbnNpdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgcmVqZWN0cyB0aGUgVHJhbnNpdGlvbiBpZiBpdCBpcyBpbnZhbGlkXG4gKlxuICogVGhpcyBob29rIGlzIGludm9rZWQgYXQgdGhlIGVuZCBvZiB0aGUgb25CZWZvcmUgcGhhc2UuXG4gKiBJZiB0aGUgdHJhbnNpdGlvbiBpcyBpbnZhbGlkIChmb3IgZXhhbXBsZSwgcGFyYW0gdmFsdWVzIGRvIG5vdCB2YWxpZGF0ZSlcbiAqIHRoZW4gdGhlIHRyYW5zaXRpb24gaXMgcmVqZWN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRUcmFuc2l0aW9uSG9vayh0cmFucykge1xuICAgIGlmICghdHJhbnMudmFsaWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnMuZXJyb3IoKS50b1N0cmluZygpKTtcbiAgICB9XG59XG5leHBvcnRzLnJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHt9LCBpbnZhbGlkVHJhbnNpdGlvbkhvb2ssIHsgcHJpb3JpdHk6IC0xMDAwMCB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhbGlkVHJhbnNpdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgcGVyZm9ybXMgbGF6eSBsb2FkaW5nXG4gKlxuICogV2hlbiBlbnRlcmluZyBhIHN0YXRlIFwiYWJjXCIgd2hpY2ggaGFzIGEgYGxhenlMb2FkYCBmdW5jdGlvbiBkZWZpbmVkOlxuICogLSBJbnZva2UgdGhlIGBsYXp5TG9hZGAgZnVuY3Rpb24gKHVubGVzcyBpdCBpcyBhbHJlYWR5IGluIHByb2Nlc3MpXG4gKiAgIC0gRmxhZyB0aGUgaG9vayBmdW5jdGlvbiBhcyBcImluIHByb2Nlc3NcIlxuICogICAtIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgcHJvbWlzZSAodGhhdCByZXNvbHZlcyB3aGVuIGxhenkgbG9hZGluZyBpcyBjb21wbGV0ZSlcbiAqIC0gV2FpdCBmb3IgdGhlIHByb21pc2UgdG8gc2V0dGxlXG4gKiAgIC0gSWYgdGhlIHByb21pc2UgcmVzb2x2ZXMgdG8gYSBbW0xhenlMb2FkUmVzdWx0XV0sIHRoZW4gcmVnaXN0ZXIgdGhvc2Ugc3RhdGVzXG4gKiAgIC0gRmxhZyB0aGUgaG9vayBmdW5jdGlvbiBhcyBcIm5vdCBpbiBwcm9jZXNzXCJcbiAqIC0gSWYgdGhlIGhvb2sgd2FzIHN1Y2Nlc3NmdWxcbiAqICAgLSBSZW1vdmUgdGhlIGBsYXp5TG9hZGAgZnVuY3Rpb24gZnJvbSB0aGUgc3RhdGUgZGVjbGFyYXRpb25cbiAqIC0gSWYgYWxsIHRoZSBob29rcyB3ZXJlIHN1Y2Nlc3NmdWxcbiAqICAgLSBSZXRyeSB0aGUgdHJhbnNpdGlvbiAoYnkgcmV0dXJuaW5nIGEgVGFyZ2V0U3RhdGUpXG4gKlxuICogYGBgXG4gKiAuc3RhdGUoJ2FiYycsIHtcbiAqICAgY29tcG9uZW50OiAnZm9vQ29tcG9uZW50JyxcbiAqICAgbGF6eUxvYWQ6ICgpID0+IFN5c3RlbS5pbXBvcnQoJy4vZm9vQ29tcG9uZW50JylcbiAqICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLmxhenlMb2FkXV1cbiAqL1xudmFyIGxhenlMb2FkSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgdmFyIHJvdXRlciA9IHRyYW5zaXRpb24ucm91dGVyO1xuICAgIGZ1bmN0aW9uIHJldHJ5VHJhbnNpdGlvbigpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24ub3JpZ2luYWxUcmFuc2l0aW9uKCkub3B0aW9ucygpLnNvdXJjZSAhPT0gJ3VybCcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIHdhcyBub3QgdHJpZ2dlcmVkIHZpYSB1cmwgc3luY1xuICAgICAgICAgICAgLy8gVGhlIGxhenkgc3RhdGUgc2hvdWxkIGJlIGxvYWRlZCBub3csIHNvIHJlLXRyeSB0aGUgb3JpZ2luYWwgdHJhbnNpdGlvblxuICAgICAgICAgICAgdmFyIG9yaWcgPSB0cmFuc2l0aW9uLnRhcmdldFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLnN0YXRlU2VydmljZS50YXJnZXQob3JpZy5pZGVudGlmaWVyKCksIG9yaWcucGFyYW1zKCksIG9yaWcub3B0aW9ucygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgb3JpZ2luYWwgdHJhbnNpdGlvbiB3YXMgdHJpZ2dlcmVkIHZpYSB1cmwgc3luY1xuICAgICAgICAvLyBSdW4gdGhlIFVSTCBydWxlcyBhbmQgZmluZCB0aGUgYmVzdCBtYXRjaFxuICAgICAgICB2YXIgJHVybCA9IHJvdXRlci51cmxTZXJ2aWNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJHVybC5tYXRjaCgkdXJsLnBhcnRzKCkpO1xuICAgICAgICB2YXIgcnVsZSA9IHJlc3VsdCAmJiByZXN1bHQucnVsZTtcbiAgICAgICAgLy8gSWYgdGhlIGJlc3QgbWF0Y2ggaXMgYSBzdGF0ZSwgcmVkaXJlY3QgdGhlIHRyYW5zaXRpb24gKGluc3RlYWRcbiAgICAgICAgLy8gb2YgY2FsbGluZyBzeW5jKCkgd2hpY2ggc3VwZXJzZWRlcyB0aGUgY3VycmVudCB0cmFuc2l0aW9uKVxuICAgICAgICBpZiAocnVsZSAmJiBydWxlLnR5cGUgPT09ICdTVEFURScpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHJ1bGUuc3RhdGU7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gcmVzdWx0Lm1hdGNoO1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlci5zdGF0ZVNlcnZpY2UudGFyZ2V0KHN0YXRlLCBwYXJhbXMsIHRyYW5zaXRpb24ub3B0aW9ucygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBtYXRjaGluZyBzdGF0ZSBmb3VuZCwgc28gbGV0IC5zeW5jKCkgY2hvb3NlIHRoZSBiZXN0IG5vbi1zdGF0ZSBtYXRjaC9vdGhlcndpc2VcbiAgICAgICAgcm91dGVyLnVybFNlcnZpY2Uuc3luYygpO1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZXMgPSB0cmFuc2l0aW9uXG4gICAgICAgIC5lbnRlcmluZygpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLiQkc3RhdGUoKS5sYXp5TG9hZDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGxhenlMb2FkU3RhdGUodHJhbnNpdGlvbiwgc3RhdGUpOyB9KTtcbiAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEuYWxsKHByb21pc2VzKS50aGVuKHJldHJ5VHJhbnNpdGlvbik7XG59O1xuZXhwb3J0cy5yZWdpc3RlckxhenlMb2FkSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7IGVudGVyaW5nOiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUubGF6eUxvYWQ7IH0gfSwgbGF6eUxvYWRIb29rKTtcbn07XG4vKipcbiAqIEludm9rZXMgYSBzdGF0ZSdzIGxhenkgbG9hZCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIGEgVHJhbnNpdGlvbiBjb250ZXh0XG4gKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIHRvIGxhenkgbG9hZFxuICogQHJldHVybnMgQSBwcm9taXNlIGZvciB0aGUgbGF6eSBsb2FkIHJlc3VsdFxuICovXG5mdW5jdGlvbiBsYXp5TG9hZFN0YXRlKHRyYW5zaXRpb24sIHN0YXRlKSB7XG4gICAgdmFyIGxhenlMb2FkRm4gPSBzdGF0ZS4kJHN0YXRlKCkubGF6eUxvYWQ7XG4gICAgLy8gU3RvcmUvZ2V0IHRoZSBsYXp5IGxvYWQgcHJvbWlzZSBvbi9mcm9tIHRoZSBob29rZm4gc28gaXQgZG9lc24ndCBnZXQgcmUtaW52b2tlZFxuICAgIHZhciBwcm9taXNlID0gbGF6eUxvYWRGblsnX3Byb21pc2UnXTtcbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUubGF6eUxvYWQ7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuJCRzdGF0ZSgpLmxhenlMb2FkO1xuICAgICAgICAgICAgZGVsZXRlIGxhenlMb2FkRm5bJ19wcm9taXNlJ107XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBkZWxldGUgbGF6eUxvYWRGblsnX3Byb21pc2UnXTtcbiAgICAgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvbWlzZSA9IGxhenlMb2FkRm5bJ19wcm9taXNlJ10gPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcVxuICAgICAgICAgICAgLndoZW4obGF6eUxvYWRGbih0cmFuc2l0aW9uLCBzdGF0ZSkpXG4gICAgICAgICAgICAudGhlbih1cGRhdGVTdGF0ZVJlZ2lzdHJ5KVxuICAgICAgICAgICAgLnRoZW4oc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cbiAgICAvKiogUmVnaXN0ZXIgYW55IGxhenkgbG9hZGVkIHN0YXRlIGRlZmluaXRpb25zICovXG4gICAgZnVuY3Rpb24gdXBkYXRlU3RhdGVSZWdpc3RyeShyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBBcnJheS5pc0FycmF5KHJlc3VsdC5zdGF0ZXMpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKF9zdGF0ZSkgeyByZXR1cm4gdHJhbnNpdGlvbi5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5yZWdpc3Rlcihfc3RhdGUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmV4cG9ydHMubGF6eUxvYWRTdGF0ZSA9IGxhenlMb2FkU3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXp5TG9hZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQSBmYWN0b3J5IHdoaWNoIGNyZWF0ZXMgYW4gb25FbnRlciwgb25FeGl0IG9yIG9uUmV0YWluIHRyYW5zaXRpb24gaG9vayBmdW5jdGlvblxuICpcbiAqIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBpbnZva2VzIHRoZSAoZm9yIGluc3RhbmNlKSBzdGF0ZS5vbkVudGVyIGhvb2sgd2hlbiB0aGVcbiAqIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXG4gKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBtYWtlRW50ZXJFeGl0UmV0YWluSG9vayhob29rTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodHJhbnNpdGlvbiwgc3RhdGUpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSA9IHN0YXRlLiQkc3RhdGUoKTtcbiAgICAgICAgdmFyIGhvb2tGbiA9IF9zdGF0ZVtob29rTmFtZV07XG4gICAgICAgIHJldHVybiBob29rRm4odHJhbnNpdGlvbiwgc3RhdGUpO1xuICAgIH07XG59XG4vKipcbiAqIFRoZSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dIGZvciBvbkV4aXRcbiAqXG4gKiBXaGVuIHRoZSBzdGF0ZSBpcyBiZWluZyBleGl0ZWQsIHRoZSBzdGF0ZSdzIC5vbkV4aXQgZnVuY3Rpb24gaXMgaW52b2tlZC5cbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vbkV4aXQoeyBleGl0aW5nOiAoc3RhdGUpID0+ICEhc3RhdGUub25FeGl0IH0sIG9uRXhpdEhvb2spO2BcbiAqXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vbkV4aXRdXVxuICovXG52YXIgb25FeGl0SG9vayA9IG1ha2VFbnRlckV4aXRSZXRhaW5Ib29rKCdvbkV4aXQnKTtcbmV4cG9ydHMucmVnaXN0ZXJPbkV4aXRIb29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRXhpdCh7IGV4aXRpbmc6IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gISFzdGF0ZS5vbkV4aXQ7IH0gfSwgb25FeGl0SG9vayk7XG59O1xuLyoqXG4gKiBUaGUgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSBmb3Igb25SZXRhaW5cbiAqXG4gKiBXaGVuIHRoZSBzdGF0ZSB3YXMgYWxyZWFkeSBlbnRlcmVkLCBhbmQgaXMgbm90IGJlaW5nIGV4aXRlZCBvciByZS1lbnRlcmVkLCB0aGUgc3RhdGUncyAub25SZXRhaW4gZnVuY3Rpb24gaXMgaW52b2tlZC5cbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblJldGFpbih7IHJldGFpbmVkOiAoc3RhdGUpID0+ICEhc3RhdGUub25SZXRhaW4gfSwgb25SZXRhaW5Ib29rKTtgXG4gKlxuICogU2VlOiBbW0lIb29rUmVnaXN0cnkub25SZXRhaW5dXVxuICovXG52YXIgb25SZXRhaW5Ib29rID0gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soJ29uUmV0YWluJyk7XG5leHBvcnRzLnJlZ2lzdGVyT25SZXRhaW5Ib29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uUmV0YWluKHsgcmV0YWluZWQ6IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gISFzdGF0ZS5vblJldGFpbjsgfSB9LCBvblJldGFpbkhvb2spO1xufTtcbi8qKlxuICogVGhlIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0gZm9yIG9uRW50ZXJcbiAqXG4gKiBXaGVuIHRoZSBzdGF0ZSBpcyBiZWluZyBlbnRlcmVkLCB0aGUgc3RhdGUncyAub25FbnRlciBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogKHN0YXRlKSA9PiAhIXN0YXRlLm9uRW50ZXIgfSwgb25FbnRlckhvb2spO2BcbiAqXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vbkVudGVyXV1cbiAqL1xudmFyIG9uRW50ZXJIb29rID0gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soJ29uRW50ZXInKTtcbmV4cG9ydHMucmVnaXN0ZXJPbkVudGVySG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkVudGVyKHsgZW50ZXJpbmc6IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gISFzdGF0ZS5vbkVudGVyOyB9IH0sIG9uRW50ZXJIb29rKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbkVudGVyRXhpdFJldGFpbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHRhcmdldFN0YXRlXzEgPSByZXF1aXJlKFwiLi4vc3RhdGUvdGFyZ2V0U3RhdGVcIik7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCByZWRpcmVjdHMgdG8gYSBkaWZmZXJlbnQgc3RhdGUgb3IgcGFyYW1zXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7IHRvOiAoc3RhdGUpID0+ICEhc3RhdGUucmVkaXJlY3RUbyB9LCByZWRpcmVjdEhvb2spO2BcbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlZGlyZWN0VG9dXVxuICovXG52YXIgcmVkaXJlY3RUb0hvb2sgPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICB2YXIgcmVkaXJlY3QgPSB0cmFucy50bygpLnJlZGlyZWN0VG87XG4gICAgaWYgKCFyZWRpcmVjdClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciAkc3RhdGUgPSB0cmFucy5yb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhyZXN1bHQpKVxuICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS50YXJnZXQocmVzdWx0LCB0cmFucy5wYXJhbXMoKSwgdHJhbnMub3B0aW9ucygpKTtcbiAgICAgICAgaWYgKHJlc3VsdFsnc3RhdGUnXSB8fCByZXN1bHRbJ3BhcmFtcyddKVxuICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS50YXJnZXQocmVzdWx0WydzdGF0ZSddIHx8IHRyYW5zLnRvKCksIHJlc3VsdFsncGFyYW1zJ10gfHwgdHJhbnMucGFyYW1zKCksIHRyYW5zLm9wdGlvbnMoKSk7XG4gICAgfVxuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihyZWRpcmVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4ocmVkaXJlY3QodHJhbnMpKS50aGVuKGhhbmRsZVJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVSZXN1bHQocmVkaXJlY3QpO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJSZWRpcmVjdFRvSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHsgdG86IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gISFzdGF0ZS5yZWRpcmVjdFRvOyB9IH0sIHJlZGlyZWN0VG9Ib29rKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWRpcmVjdFRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgaG9va3MgKi9cbi8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcmVzb2x2ZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0XCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG5leHBvcnRzLlJFU09MVkVfSE9PS19QUklPUklUWSA9IDEwMDA7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggcmVzb2x2ZXMgYWxsIEVBR0VSIFJlc29sdmFibGVzIGluIHRoZSBUbyBQYXRoXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgZWFnZXJSZXNvbHZlUGF0aCwgeyBwcmlvcml0eTogMTAwMCB9KTtgXG4gKlxuICogV2hlbiBhIFRyYW5zaXRpb24gc3RhcnRzLCB0aGlzIGhvb2sgcmVzb2x2ZXMgYWxsIHRoZSBFQUdFUiBSZXNvbHZhYmxlcywgd2hpY2ggdGhlIHRyYW5zaXRpb24gdGhlbiB3YWl0cyBmb3IuXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cbiAqL1xudmFyIGVhZ2VyUmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMoKS50bykucmVzb2x2ZVBhdGgoJ0VBR0VSJywgdHJhbnMpLnRoZW4oY29tbW9uXzEubm9vcCk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckVhZ2VyUmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgZWFnZXJSZXNvbHZlUGF0aCwgeyBwcmlvcml0eTogZXhwb3J0cy5SRVNPTFZFX0hPT0tfUFJJT1JJVFkgfSk7XG59O1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHJlc29sdmVzIGFsbCBMQVpZIFJlc29sdmFibGVzIGZvciB0aGUgc3RhdGUgKGFuZCBhbGwgaXRzIGFuY2VzdG9ycykgaW4gdGhlIFRvIFBhdGhcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vbkVudGVyKHsgZW50ZXJpbmc6ICgpID0+IHRydWUgfSwgbGF6eVJlc29sdmVTdGF0ZSwgeyBwcmlvcml0eTogMTAwMCB9KTtgXG4gKlxuICogV2hlbiBhIFN0YXRlIGlzIGJlaW5nIGVudGVyZWQsIHRoaXMgaG9vayByZXNvbHZlcyBhbGwgdGhlIFJlc29sdmFibGVzIGZvciB0aGlzIHN0YXRlLCB3aGljaCB0aGUgdHJhbnNpdGlvbiB0aGVuIHdhaXRzIGZvci5cbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXVxuICovXG52YXIgbGF6eVJlc29sdmVTdGF0ZSA9IGZ1bmN0aW9uICh0cmFucywgc3RhdGUpIHtcbiAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMoKS50bylcbiAgICAgICAgLnN1YkNvbnRleHQoc3RhdGUuJCRzdGF0ZSgpKVxuICAgICAgICAucmVzb2x2ZVBhdGgoJ0xBWlknLCB0cmFucylcbiAgICAgICAgLnRoZW4oY29tbW9uXzEubm9vcCk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckxhenlSZXNvbHZlU3RhdGUgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25FbnRlcih7IGVudGVyaW5nOiBob2ZfMS52YWwodHJ1ZSkgfSwgbGF6eVJlc29sdmVTdGF0ZSwgeyBwcmlvcml0eTogZXhwb3J0cy5SRVNPTFZFX0hPT0tfUFJJT1JJVFkgfSk7XG59O1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHJlc29sdmVzIGFueSBkeW5hbWljYWxseSBhZGRlZCAoTEFaWSBvciBFQUdFUikgUmVzb2x2YWJsZXMuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25GaW5pc2goe30sIGVhZ2VyUmVzb2x2ZVBhdGgsIHsgcHJpb3JpdHk6IDEwMDAgfSk7YFxuICpcbiAqIEFmdGVyIGFsbCBlbnRlcmluZyBzdGF0ZXMgaGF2ZSBiZWVuIGVudGVyZWQsIHRoaXMgaG9vayByZXNvbHZlcyBhbnkgcmVtYWluaW5nIFJlc29sdmFibGVzLlxuICogVGhlc2UgYXJlIHR5cGljYWxseSBkeW5hbWljIHJlc29sdmVzIHdoaWNoIHdlcmUgYWRkZWQgYnkgc29tZSBUcmFuc2l0aW9uIEhvb2sgdXNpbmcgW1tUcmFuc2l0aW9uLmFkZFJlc29sdmFibGVdXS5cbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXVxuICovXG52YXIgcmVzb2x2ZVJlbWFpbmluZyA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgIHJldHVybiBuZXcgcmVzb2x2ZUNvbnRleHRfMS5SZXNvbHZlQ29udGV4dCh0cmFucy50cmVlQ2hhbmdlcygpLnRvKS5yZXNvbHZlUGF0aCgnTEFaWScsIHRyYW5zKS50aGVuKGNvbW1vbl8xLm5vb3ApO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlUmVtYWluaW5nID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCByZXNvbHZlUmVtYWluaW5nLCB7IHByaW9yaXR5OiBleHBvcnRzLlJFU09MVkVfSE9PS19QUklPUklUWSB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggdXBkYXRlcyBnbG9iYWwgVUktUm91dGVyIHN0YXRlXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sIHVwZGF0ZUdsb2JhbFN0YXRlKTtgXG4gKlxuICogQmVmb3JlIGEgW1tUcmFuc2l0aW9uXV0gc3RhcnRzLCB1cGRhdGVzIHRoZSBnbG9iYWwgdmFsdWUgb2YgXCJ0aGUgY3VycmVudCB0cmFuc2l0aW9uXCIgKFtbR2xvYmFscy50cmFuc2l0aW9uXV0pLlxuICogQWZ0ZXIgYSBzdWNjZXNzZnVsIFtbVHJhbnNpdGlvbl1dLCB1cGRhdGVzIHRoZSBnbG9iYWwgdmFsdWVzIG9mIFwidGhlIGN1cnJlbnQgc3RhdGVcIlxuICogKFtbR2xvYmFscy5jdXJyZW50XV0gYW5kIFtbR2xvYmFscy4kY3VycmVudF1dKSBhbmQgXCJ0aGUgY3VycmVudCBwYXJhbSB2YWx1ZXNcIiAoW1tHbG9iYWxzLnBhcmFtc11dKS5cbiAqXG4gKiBTZWUgYWxzbyB0aGUgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzOlxuICogW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvbl1dLCBbW1N0YXRlU2VydmljZS5jdXJyZW50XV0sIFtbU3RhdGVTZXJ2aWNlLnBhcmFtc11dXG4gKi9cbnZhciB1cGRhdGVHbG9iYWxTdGF0ZSA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgIHZhciBnbG9iYWxzID0gdHJhbnMucm91dGVyLmdsb2JhbHM7XG4gICAgdmFyIHRyYW5zaXRpb25TdWNjZXNzZnVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBnbG9iYWxzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucy5lbnF1ZXVlKHRyYW5zKTtcbiAgICAgICAgZ2xvYmFscy4kY3VycmVudCA9IHRyYW5zLiR0bygpO1xuICAgICAgICBnbG9iYWxzLmN1cnJlbnQgPSBnbG9iYWxzLiRjdXJyZW50LnNlbGY7XG4gICAgICAgIGNvbW1vbl8xLmNvcHkodHJhbnMucGFyYW1zKCksIGdsb2JhbHMucGFyYW1zKTtcbiAgICB9O1xuICAgIHZhciBjbGVhckN1cnJlbnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEbyBub3QgY2xlYXIgZ2xvYmFscy50cmFuc2l0aW9uIGlmIGEgZGlmZmVyZW50IHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGlmIChnbG9iYWxzLnRyYW5zaXRpb24gPT09IHRyYW5zKVxuICAgICAgICAgICAgZ2xvYmFscy50cmFuc2l0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIHRyYW5zLm9uU3VjY2Vzcyh7fSwgdHJhbnNpdGlvblN1Y2Nlc3NmdWwsIHsgcHJpb3JpdHk6IDEwMDAwIH0pO1xuICAgIHRyYW5zLnByb21pc2UudGhlbihjbGVhckN1cnJlbnRUcmFuc2l0aW9uLCBjbGVhckN1cnJlbnRUcmFuc2l0aW9uKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyVXBkYXRlR2xvYmFsU3RhdGUgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25DcmVhdGUoe30sIHVwZGF0ZUdsb2JhbFN0YXRlKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGVHbG9iYWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHVwZGF0ZXMgdGhlIFVSTCBhZnRlciBhIHN1Y2Nlc3NmdWwgdHJhbnNpdGlvblxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlVXJsKTtgXG4gKi9cbnZhciB1cGRhdGVVcmwgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gdHJhbnNpdGlvbi5vcHRpb25zKCk7XG4gICAgdmFyICRzdGF0ZSA9IHRyYW5zaXRpb24ucm91dGVyLnN0YXRlU2VydmljZTtcbiAgICB2YXIgJHVybFJvdXRlciA9IHRyYW5zaXRpb24ucm91dGVyLnVybFJvdXRlcjtcbiAgICAvLyBEb250IHVwZGF0ZSB0aGUgdXJsIGluIHRoZXNlIHNpdHVhdGlvbnM6XG4gICAgLy8gVGhlIHRyYW5zaXRpb24gd2FzIHRyaWdnZXJlZCBieSBhIFVSTCBzeW5jIChvcHRpb25zLnNvdXJjZSA9PT0gJ3VybCcpXG4gICAgLy8gVGhlIHVzZXIgZG9lc24ndCB3YW50IHRoZSB1cmwgdG8gdXBkYXRlIChvcHRpb25zLmxvY2F0aW9uID09PSBmYWxzZSlcbiAgICAvLyBUaGUgZGVzdGluYXRpb24gc3RhdGUsIGFuZCBhbGwgcGFyZW50cyBoYXZlIG5vIG5hdmlnYWJsZSB1cmxcbiAgICBpZiAob3B0aW9ucy5zb3VyY2UgIT09ICd1cmwnICYmIG9wdGlvbnMubG9jYXRpb24gJiYgJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZSkge1xuICAgICAgICB2YXIgdXJsT3B0aW9ucyA9IHsgcmVwbGFjZTogb3B0aW9ucy5sb2NhdGlvbiA9PT0gJ3JlcGxhY2UnIH07XG4gICAgICAgICR1cmxSb3V0ZXIucHVzaCgkc3RhdGUuJGN1cnJlbnQubmF2aWdhYmxlLnVybCwgJHN0YXRlLnBhcmFtcywgdXJsT3B0aW9ucyk7XG4gICAgfVxuICAgICR1cmxSb3V0ZXIudXBkYXRlKHRydWUpO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJVcGRhdGVVcmwgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCB1cGRhdGVVcmwsIHsgcHJpb3JpdHk6IDk5OTkgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHdhaXRzIGZvciB0aGUgdmlld3MgdG8gbG9hZFxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGxvYWRFbnRlcmluZ1ZpZXdzKTtgXG4gKlxuICogQWxsb3dzIHRoZSB2aWV3cyB0byBkbyBhc3luYyB3b3JrIGluIFtbVmlld0NvbmZpZy5sb2FkXV0gYmVmb3JlIHRoZSB0cmFuc2l0aW9uIGNvbnRpbnVlcy5cbiAqIEluIGFuZ3VsYXIgMSwgdGhpcyBpbmNsdWRlcyBsb2FkaW5nIHRoZSB0ZW1wbGF0ZXMuXG4gKi9cbnZhciBsb2FkRW50ZXJpbmdWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgdmFyICRxID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHE7XG4gICAgdmFyIGVudGVyaW5nVmlld3MgPSB0cmFuc2l0aW9uLnZpZXdzKCdlbnRlcmluZycpO1xuICAgIGlmICghZW50ZXJpbmdWaWV3cy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gJHEuYWxsKGVudGVyaW5nVmlld3MubWFwKGZ1bmN0aW9uICh2aWV3KSB7IHJldHVybiAkcS53aGVuKHZpZXcubG9hZCgpKTsgfSkpLnRoZW4oY29tbW9uXzEubm9vcCk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckxvYWRFbnRlcmluZ1ZpZXdzID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCBsb2FkRW50ZXJpbmdWaWV3cyk7XG59O1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIGFjdGl2YXRlcyB0aGUgbmV3IHZpZXdzIHdoZW4gYSB0cmFuc2l0aW9uIGlzIHN1Y2Nlc3NmdWwuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCBhY3RpdmF0ZVZpZXdzKTtgXG4gKlxuICogQWZ0ZXIgYSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlLCB0aGlzIGhvb2sgZGVhY3RpdmF0ZXMgdGhlIG9sZCB2aWV3cyBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZSxcbiAqIGFuZCBhY3RpdmF0ZXMgdGhlIG5ldyB2aWV3cyBmcm9tIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZS5cbiAqXG4gKiBTZWUgW1tWaWV3U2VydmljZV1dXG4gKi9cbnZhciBhY3RpdmF0ZVZpZXdzID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICB2YXIgZW50ZXJpbmdWaWV3cyA9IHRyYW5zaXRpb24udmlld3MoJ2VudGVyaW5nJyk7XG4gICAgdmFyIGV4aXRpbmdWaWV3cyA9IHRyYW5zaXRpb24udmlld3MoJ2V4aXRpbmcnKTtcbiAgICBpZiAoIWVudGVyaW5nVmlld3MubGVuZ3RoICYmICFleGl0aW5nVmlld3MubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyICR2aWV3ID0gdHJhbnNpdGlvbi5yb3V0ZXIudmlld1NlcnZpY2U7XG4gICAgZXhpdGluZ1ZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZjKSB7IHJldHVybiAkdmlldy5kZWFjdGl2YXRlVmlld0NvbmZpZyh2Yyk7IH0pO1xuICAgIGVudGVyaW5nVmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmMpIHsgcmV0dXJuICR2aWV3LmFjdGl2YXRlVmlld0NvbmZpZyh2Yyk7IH0pO1xuICAgICR2aWV3LnN5bmMoKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyQWN0aXZhdGVWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIGFjdGl2YXRlVmlld3MpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBjb21tb25cbiAqLyAvKiogKi9cbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21tb24vaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGFyYW1zL2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGgvaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVzb2x2ZS9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZS9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmFuc2l0aW9uL2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybC9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi92aWV3L2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2dsb2JhbHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcm91dGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZhbmlsbGFcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAjIENvcmUgY2xhc3NlcyBhbmQgaW50ZXJmYWNlc1xuICpcbiAqIFRoZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHRoYXQgYXJlIGNvcmUgdG8gdWktcm91dGVyIGFuZCBkbyBub3QgYmVsb25nXG4gKiB0byBhIG1vcmUgc3BlY2lmaWMgc3Vic3lzdGVtIChzdWNoIGFzIHJlc29sdmUpLlxuICpcbiAqIEBjb3JlYXBpXG4gKiBAcHJlZmVycmVkXG4gKiBAbW9kdWxlIGNvcmVcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBVSVJvdXRlclBsdWdpbkJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVUlSb3V0ZXJQbHVnaW5CYXNlKCkge1xuICAgIH1cbiAgICBVSVJvdXRlclBsdWdpbkJhc2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAocm91dGVyKSB7IH07XG4gICAgcmV0dXJuIFVJUm91dGVyUGx1Z2luQmFzZTtcbn0oKSk7XG5leHBvcnRzLlVJUm91dGVyUGx1Z2luQmFzZSA9IFVJUm91dGVyUGx1Z2luQmFzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXJhbVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXJhbVR5cGVzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlUGFyYW1zXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhcmFtVHlwZVwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgcGFyYW1zXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHBhcmFtVHlwZV8xID0gcmVxdWlyZShcIi4vcGFyYW1UeXBlXCIpO1xuLyoqIEBoaWRkZW4gKi9cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuLyoqIEBoaWRkZW4gKi9cbnZhciBpc1Nob3J0aGFuZCA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICByZXR1cm4gWyd2YWx1ZScsICd0eXBlJywgJ3NxdWFzaCcsICdhcnJheScsICdkeW5hbWljJ10uZmlsdGVyKGhhc093bi5iaW5kKGNmZyB8fCB7fSkpLmxlbmd0aCA9PT0gMDtcbn07XG4vKiogQGludGVybmFsYXBpICovXG52YXIgRGVmVHlwZTtcbihmdW5jdGlvbiAoRGVmVHlwZSkge1xuICAgIERlZlR5cGVbRGVmVHlwZVtcIlBBVEhcIl0gPSAwXSA9IFwiUEFUSFwiO1xuICAgIERlZlR5cGVbRGVmVHlwZVtcIlNFQVJDSFwiXSA9IDFdID0gXCJTRUFSQ0hcIjtcbiAgICBEZWZUeXBlW0RlZlR5cGVbXCJDT05GSUdcIl0gPSAyXSA9IFwiQ09ORklHXCI7XG59KShEZWZUeXBlID0gZXhwb3J0cy5EZWZUeXBlIHx8IChleHBvcnRzLkRlZlR5cGUgPSB7fSkpO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHVud3JhcFNob3J0aGFuZChjZmcpIHtcbiAgICBjZmcgPSAoaXNTaG9ydGhhbmQoY2ZnKSAmJiB7IHZhbHVlOiBjZmcgfSkgfHwgY2ZnO1xuICAgIGdldFN0YXRpY0RlZmF1bHRWYWx1ZVsnX19jYWNoZWFibGUnXSA9IHRydWU7XG4gICAgZnVuY3Rpb24gZ2V0U3RhdGljRGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gY2ZnLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGNmZywge1xuICAgICAgICAkJGZuOiBwcmVkaWNhdGVzXzEuaXNJbmplY3RhYmxlKGNmZy52YWx1ZSkgPyBjZmcudmFsdWUgOiBnZXRTdGF0aWNEZWZhdWx0VmFsdWUsXG4gICAgfSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZShjZmcsIHVybFR5cGUsIGxvY2F0aW9uLCBpZCwgcGFyYW1UeXBlcykge1xuICAgIGlmIChjZmcudHlwZSAmJiB1cmxUeXBlICYmIHVybFR5cGUubmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtICdcIiArIGlkICsgXCInIGhhcyB0d28gdHlwZSBjb25maWd1cmF0aW9ucy5cIik7XG4gICAgaWYgKGNmZy50eXBlICYmIHVybFR5cGUgJiYgdXJsVHlwZS5uYW1lID09PSAnc3RyaW5nJyAmJiBwYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUpKVxuICAgICAgICByZXR1cm4gcGFyYW1UeXBlcy50eXBlKGNmZy50eXBlKTtcbiAgICBpZiAodXJsVHlwZSlcbiAgICAgICAgcmV0dXJuIHVybFR5cGU7XG4gICAgaWYgKCFjZmcudHlwZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGxvY2F0aW9uID09PSBEZWZUeXBlLkNPTkZJR1xuICAgICAgICAgICAgPyAnYW55J1xuICAgICAgICAgICAgOiBsb2NhdGlvbiA9PT0gRGVmVHlwZS5QQVRIID8gJ3BhdGgnIDogbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIID8gJ3F1ZXJ5JyA6ICdzdHJpbmcnO1xuICAgICAgICByZXR1cm4gcGFyYW1UeXBlcy50eXBlKHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2ZnLnR5cGUgaW5zdGFuY2VvZiBwYXJhbVR5cGVfMS5QYXJhbVR5cGUgPyBjZmcudHlwZSA6IHBhcmFtVHlwZXMudHlwZShjZmcudHlwZSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogcmV0dXJucyBmYWxzZSwgdHJ1ZSwgb3IgdGhlIHNxdWFzaCB2YWx1ZSB0byBpbmRpY2F0ZSB0aGUgXCJkZWZhdWx0IHBhcmFtZXRlciB1cmwgc3F1YXNoIHBvbGljeVwiLlxuICovXG5mdW5jdGlvbiBnZXRTcXVhc2hQb2xpY3koY29uZmlnLCBpc09wdGlvbmFsLCBkZWZhdWx0UG9saWN5KSB7XG4gICAgdmFyIHNxdWFzaCA9IGNvbmZpZy5zcXVhc2g7XG4gICAgaWYgKCFpc09wdGlvbmFsIHx8IHNxdWFzaCA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoc3F1YXNoKSB8fCBzcXVhc2ggPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQb2xpY3k7XG4gICAgaWYgKHNxdWFzaCA9PT0gdHJ1ZSB8fCBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3F1YXNoKSlcbiAgICAgICAgcmV0dXJuIHNxdWFzaDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNxdWFzaCBwb2xpY3k6ICdcIiArIHNxdWFzaCArIFwiJy4gVmFsaWQgcG9saWNpZXM6IGZhbHNlLCB0cnVlLCBvciBhcmJpdHJhcnkgc3RyaW5nXCIpO1xufVxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZnVuY3Rpb24gZ2V0UmVwbGFjZShjb25maWcsIGFycmF5TW9kZSwgaXNPcHRpb25hbCwgc3F1YXNoKSB7XG4gICAgdmFyIGRlZmF1bHRQb2xpY3kgPSBbXG4gICAgICAgIHsgZnJvbTogJycsIHRvOiBpc09wdGlvbmFsIHx8IGFycmF5TW9kZSA/IHVuZGVmaW5lZCA6ICcnIH0sXG4gICAgICAgIHsgZnJvbTogbnVsbCwgdG86IGlzT3B0aW9uYWwgfHwgYXJyYXlNb2RlID8gdW5kZWZpbmVkIDogJycgfSxcbiAgICBdO1xuICAgIHZhciByZXBsYWNlID0gcHJlZGljYXRlc18xLmlzQXJyYXkoY29uZmlnLnJlcGxhY2UpID8gY29uZmlnLnJlcGxhY2UgOiBbXTtcbiAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHNxdWFzaCkpXG4gICAgICAgIHJlcGxhY2UucHVzaCh7IGZyb206IHNxdWFzaCwgdG86IHVuZGVmaW5lZCB9KTtcbiAgICB2YXIgY29uZmlndXJlZEtleXMgPSBjb21tb25fMS5tYXAocmVwbGFjZSwgaG9mXzEucHJvcCgnZnJvbScpKTtcbiAgICByZXR1cm4gY29tbW9uXzEuZmlsdGVyKGRlZmF1bHRQb2xpY3ksIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBjb25maWd1cmVkS2V5cy5pbmRleE9mKGl0ZW0uZnJvbSkgPT09IC0xOyB9KS5jb25jYXQocmVwbGFjZSk7XG59XG4vKiogQGludGVybmFsYXBpICovXG52YXIgUGFyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyYW0oaWQsIHR5cGUsIGNvbmZpZywgbG9jYXRpb24sIHVybE1hdGNoZXJGYWN0b3J5KSB7XG4gICAgICAgIGNvbmZpZyA9IHVud3JhcFNob3J0aGFuZChjb25maWcpO1xuICAgICAgICB0eXBlID0gZ2V0VHlwZShjb25maWcsIHR5cGUsIGxvY2F0aW9uLCBpZCwgdXJsTWF0Y2hlckZhY3RvcnkucGFyYW1UeXBlcyk7XG4gICAgICAgIHZhciBhcnJheU1vZGUgPSBnZXRBcnJheU1vZGUoKTtcbiAgICAgICAgdHlwZSA9IGFycmF5TW9kZSA/IHR5cGUuJGFzQXJyYXkoYXJyYXlNb2RlLCBsb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0gpIDogdHlwZTtcbiAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBjb25maWcudmFsdWUgIT09IHVuZGVmaW5lZCB8fCBsb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0g7XG4gICAgICAgIHZhciBkeW5hbWljID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZChjb25maWcuZHluYW1pYykgPyAhIWNvbmZpZy5keW5hbWljIDogISF0eXBlLmR5bmFtaWM7XG4gICAgICAgIHZhciByYXcgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGNvbmZpZy5yYXcpID8gISFjb25maWcucmF3IDogISF0eXBlLnJhdztcbiAgICAgICAgdmFyIHNxdWFzaCA9IGdldFNxdWFzaFBvbGljeShjb25maWcsIGlzT3B0aW9uYWwsIHVybE1hdGNoZXJGYWN0b3J5LmRlZmF1bHRTcXVhc2hQb2xpY3koKSk7XG4gICAgICAgIHZhciByZXBsYWNlID0gZ2V0UmVwbGFjZShjb25maWcsIGFycmF5TW9kZSwgaXNPcHRpb25hbCwgc3F1YXNoKTtcbiAgICAgICAgdmFyIGluaGVyaXQgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGNvbmZpZy5pbmhlcml0KSA/ICEhY29uZmlnLmluaGVyaXQgOiAhIXR5cGUuaW5oZXJpdDtcbiAgICAgICAgLy8gYXJyYXkgY29uZmlnOiBwYXJhbSBuYW1lIChwYXJhbVtdKSBvdmVycmlkZXMgZGVmYXVsdCBzZXR0aW5ncy4gIGV4cGxpY2l0IGNvbmZpZyBvdmVycmlkZXMgcGFyYW0gbmFtZS5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QXJyYXlNb2RlKCkge1xuICAgICAgICAgICAgdmFyIGFycmF5RGVmYXVsdHMgPSB7IGFycmF5OiBsb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0ggPyAnYXV0bycgOiBmYWxzZSB9O1xuICAgICAgICAgICAgdmFyIGFycmF5UGFyYW1Ob21lbmNsYXR1cmUgPSBpZC5tYXRjaCgvXFxbXFxdJC8pID8geyBhcnJheTogdHJ1ZSB9IDoge307XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGFycmF5RGVmYXVsdHMsIGFycmF5UGFyYW1Ob21lbmNsYXR1cmUsIGNvbmZpZykuYXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHsgaWQ6IGlkLCB0eXBlOiB0eXBlLCBsb2NhdGlvbjogbG9jYXRpb24sIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwsIGR5bmFtaWM6IGR5bmFtaWMsIHJhdzogcmF3LCBzcXVhc2g6IHNxdWFzaCwgcmVwbGFjZTogcmVwbGFjZSwgaW5oZXJpdDogaW5oZXJpdCwgYXJyYXk6IGFycmF5TW9kZSwgY29uZmlnOiBjb25maWcgfSk7XG4gICAgfVxuICAgIFBhcmFtLnZhbHVlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0ge307IH1cbiAgICAgICAgdmFyIHBhcmFtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFyYW1zXzEgPSBwYXJhbXM7IF9pIDwgcGFyYW1zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNfMVtfaV07XG4gICAgICAgICAgICBwYXJhbVZhbHVlc1twYXJhbS5pZF0gPSBwYXJhbS52YWx1ZSh2YWx1ZXNbcGFyYW0uaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1WYWx1ZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBbW1BhcmFtXV0gb2JqZWN0cyB3aGljaCBoYXZlIGRpZmZlcmVudCBwYXJhbSB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEZpbHRlcnMgYSBsaXN0IG9mIFtbUGFyYW1dXSBvYmplY3RzIHRvIG9ubHkgdGhvc2Ugd2hvc2UgcGFyYW1ldGVyIHZhbHVlcyBkaWZmZXIgaW4gdHdvIHBhcmFtIHZhbHVlIG9iamVjdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXM6IFRoZSBsaXN0IG9mIFBhcmFtIG9iamVjdHMgdG8gZmlsdGVyXG4gICAgICogQHBhcmFtIHZhbHVlczE6IFRoZSBmaXJzdCBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlc1xuICAgICAqIEBwYXJhbSB2YWx1ZXMyOiB0aGUgc2Vjb25kIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbnkgUGFyYW0gb2JqZWN0cyB3aG9zZSB2YWx1ZXMgd2VyZSBkaWZmZXJlbnQgYmV0d2VlbiB2YWx1ZXMxIGFuZCB2YWx1ZXMyXG4gICAgICovXG4gICAgUGFyYW0uY2hhbmdlZCA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlczEsIHZhbHVlczIpIHtcbiAgICAgICAgaWYgKHZhbHVlczEgPT09IHZvaWQgMCkgeyB2YWx1ZXMxID0ge307IH1cbiAgICAgICAgaWYgKHZhbHVlczIgPT09IHZvaWQgMCkgeyB2YWx1ZXMyID0ge307IH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0udHlwZS5lcXVhbHModmFsdWVzMVtwYXJhbS5pZF0sIHZhbHVlczJbcGFyYW0uaWRdKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdHdvIHBhcmFtIHZhbHVlIG9iamVjdHMgYXJlIGVxdWFsIChmb3IgYSBzZXQgb2YgW1tQYXJhbV1dIG9iamVjdHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBsaXN0IG9mIFtbUGFyYW1dXSBvYmplY3RzIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHZhbHVlczEgVGhlIGZpcnN0IHNldCBvZiBwYXJhbSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gdmFsdWVzMiBUaGUgc2Vjb25kIHNldCBvZiBwYXJhbSB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHBhcmFtIHZhbHVlcyBpbiB2YWx1ZXMxIGFuZCB2YWx1ZXMyIGFyZSBlcXVhbFxuICAgICAqL1xuICAgIFBhcmFtLmVxdWFscyA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlczEsIHZhbHVlczIpIHtcbiAgICAgICAgaWYgKHZhbHVlczEgPT09IHZvaWQgMCkgeyB2YWx1ZXMxID0ge307IH1cbiAgICAgICAgaWYgKHZhbHVlczIgPT09IHZvaWQgMCkgeyB2YWx1ZXMyID0ge307IH1cbiAgICAgICAgcmV0dXJuIFBhcmFtLmNoYW5nZWQocGFyYW1zLCB2YWx1ZXMxLCB2YWx1ZXMyKS5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGEgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYXJlIHZhbGlkLCBhY2NvcmRpbmcgdG8gdGhlIFBhcmFtIGRlZmluaXRpb25zICovXG4gICAgUGFyYW0udmFsaWRhdGVzID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLnZhbGlkYXRlcyh2YWx1ZXNbcGFyYW0uaWRdKTsgfSkucmVkdWNlKGNvbW1vbl8xLmFsbFRydWVSLCB0cnVlKTtcbiAgICB9O1xuICAgIFBhcmFtLnByb3RvdHlwZS5pc0RlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09wdGlvbmFsICYmIHRoaXMudHlwZS5lcXVhbHModGhpcy52YWx1ZSgpLCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbSW50ZXJuYWxdIEdldHMgdGhlIGRlY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYSB2YWx1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlLCByZXR1cm5zIHRoZVxuICAgICAqIGRlZmF1bHQgdmFsdWUsIHdoaWNoIG1heSBiZSB0aGUgcmVzdWx0IG9mIGFuIGluamVjdGFibGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgUGFyYW0ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBbSW50ZXJuYWxdIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHBhcmFtZXRlciwgd2hpY2ggbWF5IGJlIGFuIGluamVjdGFibGUgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZ2V0RGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9kZWZhdWx0VmFsdWVDYWNoZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2RlZmF1bHRWYWx1ZUNhY2hlLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIGlmICghY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5qZWN0YWJsZSBmdW5jdGlvbnMgY2Fubm90IGJlIGNhbGxlZCBhdCBjb25maWd1cmF0aW9uIHRpbWUnKTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuaW52b2tlKF90aGlzLmNvbmZpZy4kJGZuKTtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIV90aGlzLnR5cGUuaXMoZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZhdWx0IHZhbHVlIChcIiArIGRlZmF1bHRWYWx1ZSArIFwiKSBmb3IgcGFyYW1ldGVyICdcIiArIF90aGlzLmlkICsgXCInIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBQYXJhbVR5cGUgKFwiICsgX3RoaXMudHlwZS5uYW1lICsgXCIpXCIpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy4kJGZuWydfX2NhY2hlYWJsZSddKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2RlZmF1bHRWYWx1ZUNhY2hlID0geyBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcGxhY2VTcGVjaWFsVmFsdWVzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IF90aGlzLnJlcGxhY2U7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR1cGxlID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmICh0dXBsZS5mcm9tID09PSB2YWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0dXBsZS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlID0gcmVwbGFjZVNwZWNpYWxWYWx1ZXModmFsdWUpO1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzVW5kZWZpbmVkKHZhbHVlKSA/IGdldERlZmF1bHRWYWx1ZSgpIDogdGhpcy50eXBlLiRub3JtYWxpemUodmFsdWUpO1xuICAgIH07XG4gICAgUGFyYW0ucHJvdG90eXBlLmlzU2VhcmNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0g7XG4gICAgfTtcbiAgICBQYXJhbS5wcm90b3R5cGUudmFsaWRhdGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIFRoZXJlIHdhcyBubyBwYXJhbWV0ZXIgdmFsdWUsIGJ1dCB0aGUgcGFyYW0gaXMgb3B0aW9uYWxcbiAgICAgICAgaWYgKChwcmVkaWNhdGVzXzEuaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSAmJiB0aGlzLmlzT3B0aW9uYWwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gVGhlIHZhbHVlIHdhcyBub3Qgb2YgdGhlIGNvcnJlY3QgUGFyYW1UeXBlLCBhbmQgY291bGQgbm90IGJlIGRlY29kZWQgdG8gdGhlIGNvcnJlY3QgUGFyYW1UeXBlXG4gICAgICAgIHZhciBub3JtYWxpemVkID0gdGhpcy50eXBlLiRub3JtYWxpemUodmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMudHlwZS5pcyhub3JtYWxpemVkKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVGhlIHZhbHVlIHdhcyBvZiB0aGUgY29ycmVjdCB0eXBlLCBidXQgd2hlbiBlbmNvZGVkLCBkaWQgbm90IG1hdGNoIHRoZSBQYXJhbVR5cGUncyByZWdleHBcbiAgICAgICAgdmFyIGVuY29kZWQgPSB0aGlzLnR5cGUuZW5jb2RlKG5vcm1hbGl6ZWQpO1xuICAgICAgICByZXR1cm4gIShwcmVkaWNhdGVzXzEuaXNTdHJpbmcoZW5jb2RlZCkgJiYgIXRoaXMudHlwZS5wYXR0ZXJuLmV4ZWMoZW5jb2RlZCkpO1xuICAgIH07XG4gICAgUGFyYW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJ7UGFyYW06XCIgKyB0aGlzLmlkICsgXCIgXCIgKyB0aGlzLnR5cGUgKyBcIiBzcXVhc2g6ICdcIiArIHRoaXMuc3F1YXNoICsgXCInIG9wdGlvbmFsOiBcIiArIHRoaXMuaXNPcHRpb25hbCArIFwifVwiO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcmFtO1xufSgpKTtcbmV4cG9ydHMuUGFyYW0gPSBQYXJhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmFtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBwYXJhbXNcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG4vKipcbiAqIEFuIGludGVybmFsIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0uXG4gKlxuICogQSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBpcyBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IHVzZWQgdG8gcmVnaXN0ZXIgY3VzdG9tIHBhcmFtZXRlciB0eXBlcy5cbiAqIFdoZW4gYSBwYXJhbSB0eXBlIGRlZmluaXRpb24gaXMgcmVnaXN0ZXJlZCwgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBpcyBjcmVhdGVkIGludGVybmFsbHkuXG4gKlxuICogVGhpcyBjbGFzcyBoYXMgbmFpdmUgaW1wbGVtZW50YXRpb25zIGZvciBhbGwgdGhlIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dIG1ldGhvZHMuXG4gKlxuICogVXNlZCBieSBbW1VybE1hdGNoZXJdXSB3aGVuIG1hdGNoaW5nIG9yIGZvcm1hdHRpbmcgVVJMcywgb3IgY29tcGFyaW5nIGFuZCB2YWxpZGF0aW5nIHBhcmFtZXRlciB2YWx1ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIHZhciBwYXJhbVR5cGVEZWYgPSB7XG4gKiAgIGRlY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKTsgfSxcbiAqICAgZW5jb2RlOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHZhbCAmJiB2YWwudG9TdHJpbmcoKTsgfSxcbiAqICAgZXF1YWxzOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLmlzKGEpICYmIGEgPT09IGI7IH0sXG4gKiAgIGlzOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIGFuZ3VsYXIuaXNOdW1iZXIodmFsKSAmJiBpc0Zpbml0ZSh2YWwpICYmIHZhbCAlIDEgPT09IDA7IH0sXG4gKiAgIHBhdHRlcm46IC9cXGQrL1xuICogfVxuICpcbiAqIHZhciBwYXJhbVR5cGUgPSBuZXcgUGFyYW1UeXBlKHBhcmFtVHlwZURlZik7XG4gKiBgYGBcbiAqIEBpbnRlcm5hbGFwaVxuICovXG52YXIgUGFyYW1UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkZWYgIEEgY29uZmlndXJhdGlvbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGN1c3RvbSB0eXBlIGRlZmluaXRpb24uICBUaGUgb2JqZWN0J3NcbiAgICAgKiAgICAgICAgcHJvcGVydGllcyB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1ldGhvZHMgYW5kL29yIHBhdHRlcm4gaW4gYFBhcmFtVHlwZWAncyBwdWJsaWMgaW50ZXJmYWNlLlxuICAgICAqIEByZXR1cm5zIGEgbmV3IFBhcmFtVHlwZSBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJhbVR5cGUoZGVmKSB7XG4gICAgICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSAvLiovO1xuICAgICAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICAgICAgdGhpcy5pbmhlcml0ID0gdHJ1ZTtcbiAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIGRlZik7XG4gICAgfVxuICAgIC8vIGNvbnNpZGVyIHRoZXNlIGZvdXIgbWV0aG9kcyB0byBiZSBcImFic3RyYWN0IG1ldGhvZHNcIiB0aGF0IHNob3VsZCBiZSBvdmVycmlkZGVuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHJpcGxlLWVxdWFsc1xuICAgICAgICByZXR1cm4gYSA9PSBiO1xuICAgIH07XG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS4kc3ViUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YiA9IHRoaXMucGF0dGVybi50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gc3ViLnN1YnN0cigxLCBzdWIubGVuZ3RoIC0gMik7XG4gICAgfTtcbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJ7UGFyYW1UeXBlOlwiICsgdGhpcy5uYW1lICsgXCJ9XCI7XG4gICAgfTtcbiAgICAvKiogR2l2ZW4gYW4gZW5jb2RlZCBzdHJpbmcsIG9yIGEgZGVjb2RlZCBvYmplY3QsIHJldHVybnMgYSBkZWNvZGVkIG9iamVjdCAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuJG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXModmFsKSA/IHZhbCA6IHRoaXMuZGVjb2RlKHZhbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcmFwcyBhbiBleGlzdGluZyBjdXN0b20gUGFyYW1UeXBlIGFzIGFuIGFycmF5IG9mIFBhcmFtVHlwZSwgZGVwZW5kaW5nIG9uICdtb2RlJy5cbiAgICAgKiBlLmcuOlxuICAgICAqIC0gdXJsbWF0Y2hlciBwYXR0ZXJuIFwiL3BhdGg/e3F1ZXJ5UGFyYW1bXTppbnR9XCJcbiAgICAgKiAtIHVybDogXCIvcGF0aD9xdWVyeVBhcmFtPTEmcXVlcnlQYXJhbT0yXG4gICAgICogLSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbSB3aWxsIGJlIFsxLCAyXVxuICAgICAqIGlmIGBtb2RlYCBpcyBcImF1dG9cIiwgdGhlblxuICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSB3aWxsIGNyZWF0ZSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbTogMVxuICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSZxdWVyeVBhcmFtPTIgd2lsbCBjcmVhdGUgJHN0YXRlUGFyYW1zLnF1ZXJ5UGFyYW06IFsxLCAyXVxuICAgICAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuJGFzQXJyYXkgPSBmdW5jdGlvbiAobW9kZSwgaXNTZWFyY2gpIHtcbiAgICAgICAgaWYgKCFtb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChtb2RlID09PSAnYXV0bycgJiYgIWlzU2VhcmNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2F1dG8nIGFycmF5IG1vZGUgaXMgZm9yIHF1ZXJ5IHBhcmFtZXRlcnMgb25seVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVR5cGUodGhpcywgbW9kZSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyYW1UeXBlO1xufSgpKTtcbmV4cG9ydHMuUGFyYW1UeXBlID0gUGFyYW1UeXBlO1xuLyoqXG4gKiBXcmFwcyB1cCBhIGBQYXJhbVR5cGVgIG9iamVjdCB0byBoYW5kbGUgYXJyYXkgdmFsdWVzLlxuICogQGludGVybmFsYXBpXG4gKi9cbmZ1bmN0aW9uIEFycmF5VHlwZSh0eXBlLCBtb2RlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBXcmFwIG5vbi1hcnJheSB2YWx1ZSBhcyBhcnJheVxuICAgIGZ1bmN0aW9uIGFycmF5V3JhcCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0FycmF5KHZhbCkgPyB2YWwgOiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbCkgPyBbdmFsXSA6IFtdO1xuICAgIH1cbiAgICAvLyBVbndyYXAgYXJyYXkgdmFsdWUgZm9yIFwiYXV0b1wiIG1vZGUuIFJldHVybiB1bmRlZmluZWQgZm9yIGVtcHR5IGFycmF5LlxuICAgIGZ1bmN0aW9uIGFycmF5VW53cmFwKHZhbCkge1xuICAgICAgICBzd2l0Y2ggKHZhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlID09PSAnYXV0bycgPyB2YWxbMF0gOiB2YWw7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV3JhcHMgdHlwZSAoLmlzLy5lbmNvZGUvLmRlY29kZSkgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGFycmF5SGFuZGxlcihjYWxsYmFjaywgYWxsVHJ1dGh5TW9kZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB2YXIgYXJyID0gYXJyYXlXcmFwKHZhbCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tbW9uXzEubWFwKGFyciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGFsbFRydXRoeU1vZGUgPT09IHRydWUgPyBjb21tb25fMS5maWx0ZXIocmVzdWx0LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4gIXg7IH0pLmxlbmd0aCA9PT0gMCA6IGFycmF5VW53cmFwKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFdyYXBzIHR5cGUgKC5lcXVhbHMpIGZ1bmN0aW9ucyB0byBvcGVyYXRlIG9uIGVhY2ggdmFsdWUgb2YgYW4gYXJyYXlcbiAgICBmdW5jdGlvbiBhcnJheUVxdWFsc0hhbmRsZXIoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbDEsIHZhbDIpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gYXJyYXlXcmFwKHZhbDEpLCByaWdodCA9IGFycmF5V3JhcCh2YWwyKTtcbiAgICAgICAgICAgIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2sobGVmdFtpXSwgcmlnaHRbaV0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgWydlbmNvZGUnLCAnZGVjb2RlJywgJ2VxdWFscycsICckbm9ybWFsaXplJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcGFyYW1UeXBlRm4gPSB0eXBlW25hbWVdLmJpbmQodHlwZSk7XG4gICAgICAgIHZhciB3cmFwcGVyRm4gPSBuYW1lID09PSAnZXF1YWxzJyA/IGFycmF5RXF1YWxzSGFuZGxlciA6IGFycmF5SGFuZGxlcjtcbiAgICAgICAgX3RoaXNbbmFtZV0gPSB3cmFwcGVyRm4ocGFyYW1UeXBlRm4pO1xuICAgIH0pO1xuICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgIGR5bmFtaWM6IHR5cGUuZHluYW1pYyxcbiAgICAgICAgbmFtZTogdHlwZS5uYW1lLFxuICAgICAgICBwYXR0ZXJuOiB0eXBlLnBhdHRlcm4sXG4gICAgICAgIGluaGVyaXQ6IHR5cGUuaW5oZXJpdCxcbiAgICAgICAgaXM6IGFycmF5SGFuZGxlcih0eXBlLmlzLmJpbmQodHlwZSksIHRydWUpLFxuICAgICAgICAkYXJyYXlNb2RlOiBtb2RlLFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyYW1UeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBwYXJhbXNcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHBhcmFtVHlwZV8xID0gcmVxdWlyZShcIi4vcGFyYW1UeXBlXCIpO1xuLyoqXG4gKiBBIHJlZ2lzdHJ5IGZvciBwYXJhbWV0ZXIgdHlwZXMuXG4gKlxuICogVGhpcyByZWdpc3RyeSBtYW5hZ2VzIHRoZSBidWlsdC1pbiAoYW5kIGN1c3RvbSkgcGFyYW1ldGVyIHR5cGVzLlxuICpcbiAqIFRoZSBidWlsdC1pbiBwYXJhbWV0ZXIgdHlwZXMgYXJlOlxuICpcbiAqIC0gW1tzdHJpbmddXVxuICogLSBbW3BhdGhdXVxuICogLSBbW3F1ZXJ5XV1cbiAqIC0gW1toYXNoXV1cbiAqIC0gW1tpbnRdXVxuICogLSBbW2Jvb2xdXVxuICogLSBbW2RhdGVdXVxuICogLSBbW2pzb25dXVxuICogLSBbW2FueV1dXG4gKi9cbnZhciBQYXJhbVR5cGVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBmdW5jdGlvbiBQYXJhbVR5cGVzKCkge1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLmVucXVldWUgPSB0cnVlO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLnR5cGVRdWV1ZSA9IFtdO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgICAgIHRoaXMuZGVmYXVsdFR5cGVzID0gY29tbW9uXzEucGljayhQYXJhbVR5cGVzLnByb3RvdHlwZSwgW1xuICAgICAgICAgICAgJ2hhc2gnLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAncXVlcnknLFxuICAgICAgICAgICAgJ3BhdGgnLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnYm9vbCcsXG4gICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAnanNvbicsXG4gICAgICAgICAgICAnYW55JyxcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGRlZmF1bHQgdHlwZXMuIFN0b3JlIHRoZW0gaW4gdGhlIHByb3RvdHlwZSBvZiB0aGlzLnR5cGVzLlxuICAgICAgICB2YXIgbWFrZVR5cGUgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgbmFtZSkgeyByZXR1cm4gbmV3IHBhcmFtVHlwZV8xLlBhcmFtVHlwZShjb21tb25fMS5leHRlbmQoeyBuYW1lOiBuYW1lIH0sIGRlZmluaXRpb24pKTsgfTtcbiAgICAgICAgdGhpcy50eXBlcyA9IGNvbW1vbl8xLmluaGVyaXQoY29tbW9uXzEubWFwKHRoaXMuZGVmYXVsdFR5cGVzLCBtYWtlVHlwZSksIHt9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFBhcmFtVHlwZXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB7fTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHBhcmFtZXRlciB0eXBlXG4gICAgICpcbiAgICAgKiBFbmQgdXNlcnMgc2hvdWxkIGNhbGwgW1tVcmxNYXRjaGVyRmFjdG9yeS50eXBlXV0sIHdoaWNoIGRlbGVnYXRlcyB0byB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBQYXJhbVR5cGVzLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb25Gbikge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoZGVmaW5pdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlc1tuYW1lXTtcbiAgICAgICAgaWYgKHRoaXMudHlwZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHR5cGUgbmFtZWQgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXCIpO1xuICAgICAgICB0aGlzLnR5cGVzW25hbWVdID0gbmV3IHBhcmFtVHlwZV8xLlBhcmFtVHlwZShjb21tb25fMS5leHRlbmQoeyBuYW1lOiBuYW1lIH0sIGRlZmluaXRpb24pKTtcbiAgICAgICAgaWYgKGRlZmluaXRpb25Gbikge1xuICAgICAgICAgICAgdGhpcy50eXBlUXVldWUucHVzaCh7IG5hbWU6IG5hbWUsIGRlZjogZGVmaW5pdGlvbkZuIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVucXVldWUpXG4gICAgICAgICAgICAgICAgdGhpcy5fZmx1c2hUeXBlUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBQYXJhbVR5cGVzLnByb3RvdHlwZS5fZmx1c2hUeXBlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnR5cGVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlLnBhdHRlcm4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBvdmVycmlkZSBhIHR5cGUncyAucGF0dGVybiBhdCBydW50aW1lLlwiKTtcbiAgICAgICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLnR5cGVzW3R5cGUubmFtZV0sIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UodHlwZS5kZWYpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBhcmFtVHlwZXM7XG59KCkpO1xuZXhwb3J0cy5QYXJhbVR5cGVzID0gUGFyYW1UeXBlcztcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBpbml0RGVmYXVsdFR5cGVzKCkge1xuICAgIHZhciBtYWtlRGVmYXVsdFR5cGUgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgIHZhciB2YWxUb1N0cmluZyA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuICh2YWwgIT0gbnVsbCA/IHZhbC50b1N0cmluZygpIDogdmFsKTsgfTtcbiAgICAgICAgdmFyIGRlZmF1bHRUeXBlQmFzZSA9IHtcbiAgICAgICAgICAgIGVuY29kZTogdmFsVG9TdHJpbmcsXG4gICAgICAgICAgICBkZWNvZGU6IHZhbFRvU3RyaW5nLFxuICAgICAgICAgICAgaXM6IGhvZl8xLmlzKFN0cmluZyksXG4gICAgICAgICAgICBwYXR0ZXJuOiAvLiovLFxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnRyaXBsZS1lcXVhbHNcbiAgICAgICAgICAgIGVxdWFsczogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT0gYjsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7fSwgZGVmYXVsdFR5cGVCYXNlLCBkZWYpO1xuICAgIH07XG4gICAgLy8gRGVmYXVsdCBQYXJhbWV0ZXIgVHlwZSBEZWZpbml0aW9uc1xuICAgIGNvbW1vbl8xLmV4dGVuZChQYXJhbVR5cGVzLnByb3RvdHlwZSwge1xuICAgICAgICBzdHJpbmc6IG1ha2VEZWZhdWx0VHlwZSh7fSksXG4gICAgICAgIHBhdGg6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvW14vXSovLFxuICAgICAgICB9KSxcbiAgICAgICAgcXVlcnk6IG1ha2VEZWZhdWx0VHlwZSh7fSksXG4gICAgICAgIGhhc2g6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgfSksXG4gICAgICAgIGludDogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIGRlY29kZTogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7IH0sXG4gICAgICAgICAgICBpczogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhcHJlZGljYXRlc18xLmlzTnVsbE9yVW5kZWZpbmVkKHZhbCkgJiYgdGhpcy5kZWNvZGUodmFsLnRvU3RyaW5nKCkpID09PSB2YWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0dGVybjogLy0/XFxkKy8sXG4gICAgICAgIH0pLFxuICAgICAgICBib29sOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiAodmFsICYmIDEpIHx8IDA7IH0sXG4gICAgICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApICE9PSAwOyB9LFxuICAgICAgICAgICAgaXM6IGhvZl8xLmlzKEJvb2xlYW4pLFxuICAgICAgICAgICAgcGF0dGVybjogLzB8MS8sXG4gICAgICAgIH0pLFxuICAgICAgICBkYXRlOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzKHZhbClcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiBbdmFsLmdldEZ1bGxZZWFyKCksICgnMCcgKyAodmFsLmdldE1vbnRoKCkgKyAxKSkuc2xpY2UoLTIpLCAoJzAnICsgdmFsLmdldERhdGUoKSkuc2xpY2UoLTIpXS5qb2luKCctJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXModmFsKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLmNhcHR1cmUuZXhlYyh2YWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA/IG5ldyBEYXRlKG1hdGNoWzFdLCBtYXRjaFsyXSAtIDEsIG1hdGNoWzNdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpczogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsLnZhbHVlT2YoKSk7IH0sXG4gICAgICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uIChsLCByKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZ2V0RnVsbFllYXInLCAnZ2V0TW9udGgnLCAnZ2V0RGF0ZSddLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmbikgeyByZXR1cm4gYWNjICYmIGxbZm5dKCkgPT09IHJbZm5dKCk7IH0sIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdHRlcm46IC9bMC05XXs0fS0oPzowWzEtOV18MVswLTJdKS0oPzowWzEtOV18WzEtMl1bMC05XXwzWzAtMV0pLyxcbiAgICAgICAgICAgIGNhcHR1cmU6IC8oWzAtOV17NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxLTJdWzAtOV18M1swLTFdKS8sXG4gICAgICAgIH0pLFxuICAgICAgICBqc29uOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBjb21tb25fMS50b0pzb24sXG4gICAgICAgICAgICBkZWNvZGU6IGNvbW1vbl8xLmZyb21Kc29uLFxuICAgICAgICAgICAgaXM6IGhvZl8xLmlzKE9iamVjdCksXG4gICAgICAgICAgICBlcXVhbHM6IGNvbW1vbl8xLmVxdWFscyxcbiAgICAgICAgICAgIHBhdHRlcm46IC9bXi9dKi8sXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBkb2VzIG5vdCBlbmNvZGUvZGVjb2RlXG4gICAgICAgIGFueTogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIGVuY29kZTogY29tbW9uXzEuaWRlbnRpdHksXG4gICAgICAgICAgICBkZWNvZGU6IGNvbW1vbl8xLmlkZW50aXR5LFxuICAgICAgICAgICAgaXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICBlcXVhbHM6IGNvbW1vbl8xLmVxdWFscyxcbiAgICAgICAgfSksXG4gICAgfSk7XG59XG5pbml0RGVmYXVsdFR5cGVzKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbVR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBwYXJhbXNcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBTdGF0ZVBhcmFtcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYSBzZXQgb2YgcGFyYW1ldGVycyB3aXRoIGFsbCBwYXJhbWV0ZXJzIGluaGVyaXRlZCBiZXR3ZWVuIHRoZSBjb21tb24gcGFyZW50cyBvZiB0aGVcbiAgICAgKiBjdXJyZW50IHN0YXRlIGFuZCBhIGdpdmVuIGRlc3RpbmF0aW9uIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1BhcmFtcyBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgd2hpY2ggd2lsbCBiZSBjb21wb3NpdGVkIHdpdGggaW5oZXJpdGVkIHBhcmFtcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGN1cnJlbnQgSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkdG8gSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uXG4gICAgICovXG4gICAgU3RhdGVQYXJhbXMucHJvdG90eXBlLiRpbmhlcml0ID0gZnVuY3Rpb24gKG5ld1BhcmFtcywgJGN1cnJlbnQsICR0bykge1xuICAgICAgICB2YXIgcGFyZW50UGFyYW1zO1xuICAgICAgICB2YXIgcGFyZW50cyA9IGNvbW1vbl8xLmFuY2VzdG9ycygkY3VycmVudCwgJHRvKSwgaW5oZXJpdGVkID0ge30sIGluaGVyaXRMaXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgaW4gcGFyZW50cykge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2ldIHx8ICFwYXJlbnRzW2ldLnBhcmFtcylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHBhcmVudFBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmVudHNbaV0ucGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghcGFyZW50UGFyYW1zLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogaW4gcGFyZW50UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaGVyaXRMaXN0LmluZGV4T2YocGFyZW50UGFyYW1zW2pdKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpbmhlcml0TGlzdC5wdXNoKHBhcmVudFBhcmFtc1tqXSk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkW3BhcmVudFBhcmFtc1tqXV0gPSB0aGlzW3BhcmVudFBhcmFtc1tqXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7fSwgaW5oZXJpdGVkLCBuZXdQYXJhbXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlUGFyYW1zO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVQYXJhbXMgPSBTdGF0ZVBhcmFtcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlUGFyYW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIHBhdGggKi8gLyoqIGZvciB0eXBlZG9jICovXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXRoTm9kZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXRoVXRpbHNcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBwYXRoICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKlxuICogQSBub2RlIGluIGEgW1tUcmVlQ2hhbmdlc11dIHBhdGhcbiAqXG4gKiBGb3IgYSBbW1RyZWVDaGFuZ2VzXV0gcGF0aCwgdGhpcyBjbGFzcyBob2xkcyB0aGUgc3RhdGVmdWwgaW5mb3JtYXRpb24gZm9yIGEgc2luZ2xlIG5vZGUgaW4gdGhlIHBhdGguXG4gKiBFYWNoIFBhdGhOb2RlIGNvcnJlc3BvbmRzIHRvIGEgc3RhdGUgYmVpbmcgZW50ZXJlZCwgZXhpdGVkLCBvciByZXRhaW5lZC5cbiAqIFRoZSBzdGF0ZWZ1bCBpbmZvcm1hdGlvbiBpbmNsdWRlcyBwYXJhbWV0ZXIgdmFsdWVzIGFuZCByZXNvbHZlIGRhdGEuXG4gKi9cbnZhciBQYXRoTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXRoTm9kZShzdGF0ZU9yTm9kZSkge1xuICAgICAgICBpZiAoc3RhdGVPck5vZGUgaW5zdGFuY2VvZiBQYXRoTm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGF0ZU9yTm9kZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub2RlLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbVNjaGVtYSA9IG5vZGUucGFyYW1TY2hlbWEuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSBjb21tb25fMS5leHRlbmQoe30sIG5vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMudmlld3MgPSBub2RlLnZpZXdzICYmIG5vZGUudmlld3Muc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlT3JOb2RlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbVNjaGVtYSA9IHN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2YWJsZXMgPSBzdGF0ZS5yZXNvbHZhYmxlcy5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmNsb25lKCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoTm9kZSh0aGlzKTtcbiAgICB9O1xuICAgIC8qKiBTZXRzIFtbcGFyYW1WYWx1ZXNdXSBmb3IgdGhlIG5vZGUsIGZyb20gdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QgaGFzaCAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5hcHBseVJhd1BhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIGdldFBhcmFtVmFsID0gZnVuY3Rpb24gKHBhcmFtRGVmKSB7IHJldHVybiBbcGFyYW1EZWYuaWQsIHBhcmFtRGVmLnZhbHVlKHBhcmFtc1twYXJhbURlZi5pZF0pXTsgfTtcbiAgICAgICAgdGhpcy5wYXJhbVZhbHVlcyA9IHRoaXMucGFyYW1TY2hlbWEucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBwRGVmKSB7IHJldHVybiBjb21tb25fMS5hcHBseVBhaXJzKG1lbW8sIGdldFBhcmFtVmFsKHBEZWYpKTsgfSwge30pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBHZXRzIGEgc3BlY2lmaWMgW1tQYXJhbV1dIG1ldGFkYXRhIHRoYXQgYmVsb25ncyB0byB0aGUgbm9kZSAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5wYXJhbWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZmluZCh0aGlzLnBhcmFtU2NoZW1hLCBob2ZfMS5wcm9wRXEoJ2lkJywgbmFtZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RhdGUgYW5kIHBhcmFtZXRlciB2YWx1ZXMgZm9yIGFub3RoZXIgUGF0aE5vZGUgYXJlXG4gICAgICogZXF1YWwgdG8gdGhlIHN0YXRlIGFuZCBwYXJhbSB2YWx1ZXMgZm9yIHRoaXMgUGF0aE5vZGVcbiAgICAgKi9cbiAgICBQYXRoTm9kZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG5vZGUsIHBhcmFtc0ZuKSB7XG4gICAgICAgIHZhciBkaWZmID0gdGhpcy5kaWZmKG5vZGUsIHBhcmFtc0ZuKTtcbiAgICAgICAgcmV0dXJuIGRpZmYgJiYgZGlmZi5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBQYXJhbXMgd2l0aCBkaWZmZXJlbnQgcGFyYW1ldGVyIHZhbHVlcyBvbiBhbm90aGVyIFBhdGhOb2RlLlxuICAgICAqXG4gICAgICogR2l2ZW4gYW5vdGhlciBub2RlIChvZiB0aGUgc2FtZSBzdGF0ZSksIGZpbmRzIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIHdoaWNoIGRpZmZlci5cbiAgICAgKiBSZXR1cm5zIHRoZSBbW1BhcmFtXV0gKHNjaGVtYSBvYmplY3RzKSB3aG9zZSBwYXJhbWV0ZXIgdmFsdWVzIGRpZmZlci5cbiAgICAgKlxuICAgICAqIEdpdmVuIGFub3RoZXIgbm9kZSBmb3IgYSBkaWZmZXJlbnQgc3RhdGUsIHJldHVybnMgYGZhbHNlYFxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gY29tcGFyZSB0b1xuICAgICAqIEBwYXJhbSBwYXJhbXNGbiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB3aGljaCBwYXJhbWV0ZXJzIHNob3VsZCBiZSBjb21wYXJlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgW1tQYXJhbV1dcyB3aGljaCBkaWZmZXIsIG9yIG51bGwgaWYgdGhlIHR3byBub2RlcyBhcmUgZm9yIGRpZmZlcmVudCBzdGF0ZXNcbiAgICAgKi9cbiAgICBQYXRoTm9kZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChub2RlLCBwYXJhbXNGbikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbm9kZS5zdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHBhcmFtc0ZuID8gcGFyYW1zRm4odGhpcykgOiB0aGlzLnBhcmFtU2NoZW1hO1xuICAgICAgICByZXR1cm4gcGFyYW1fMS5QYXJhbS5jaGFuZ2VkKHBhcmFtcywgdGhpcy5wYXJhbVZhbHVlcywgbm9kZS5wYXJhbVZhbHVlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBhdGhOb2RlXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGluc3RhbmNlIG1ldGhvZCBgbm9kZS5jbG9uZSgpYFxuICAgICAqL1xuICAgIFBhdGhOb2RlLmNsb25lID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2xvbmUoKTsgfTtcbiAgICByZXR1cm4gUGF0aE5vZGU7XG59KCkpO1xuZXhwb3J0cy5QYXRoTm9kZSA9IFBhdGhOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQG1vZHVsZSBwYXRoICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xudmFyIHBhdGhOb2RlXzEgPSByZXF1aXJlKFwiLi9wYXRoTm9kZVwiKTtcbi8qKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBmdW5jdGlvbnMgd2hpY2ggY29udmVydCBUYXJnZXRTdGF0ZXMsIE5vZGVzIGFuZCBwYXRocyBmcm9tIG9uZSB0eXBlIHRvIGFub3RoZXIuXG4gKi9cbnZhciBQYXRoVXRpbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGF0aFV0aWxzKCkge1xuICAgIH1cbiAgICAvKiogR2l2ZW4gYSBQYXRoTm9kZVtdLCBjcmVhdGUgYW4gVGFyZ2V0U3RhdGUgKi9cbiAgICBQYXRoVXRpbHMubWFrZVRhcmdldFN0YXRlID0gZnVuY3Rpb24gKHJlZ2lzdHJ5LCBwYXRoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGNvbW1vbl8xLnRhaWwocGF0aCkuc3RhdGU7XG4gICAgICAgIHJldHVybiBuZXcgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZShyZWdpc3RyeSwgc3RhdGUsIHBhdGgubWFwKGhvZl8xLnByb3AoJ3BhcmFtVmFsdWVzJykpLnJlZHVjZShjb21tb25fMS5tZXJnZVIsIHt9KSwge30pO1xuICAgIH07XG4gICAgUGF0aFV0aWxzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgICAgICB2YXIgdG9QYXJhbXMgPSB0YXJnZXRTdGF0ZS5wYXJhbXMoKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlLiRzdGF0ZSgpLnBhdGgubWFwKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gbmV3IHBhdGhOb2RlXzEuUGF0aE5vZGUoc3RhdGUpLmFwcGx5UmF3UGFyYW1zKHRvUGFyYW1zKTsgfSk7XG4gICAgfTtcbiAgICAvKiogR2l2ZW4gYSBmcm9tUGF0aDogUGF0aE5vZGVbXSBhbmQgYSBUYXJnZXRTdGF0ZSwgYnVpbGRzIGEgdG9QYXRoOiBQYXRoTm9kZVtdICovXG4gICAgUGF0aFV0aWxzLmJ1aWxkVG9QYXRoID0gZnVuY3Rpb24gKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSkge1xuICAgICAgICB2YXIgdG9QYXRoID0gUGF0aFV0aWxzLmJ1aWxkUGF0aCh0YXJnZXRTdGF0ZSk7XG4gICAgICAgIGlmICh0YXJnZXRTdGF0ZS5vcHRpb25zKCkuaW5oZXJpdCkge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGhVdGlscy5pbmhlcml0UGFyYW1zKGZyb21QYXRoLCB0b1BhdGgsIE9iamVjdC5rZXlzKHRhcmdldFN0YXRlLnBhcmFtcygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUGF0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgVmlld0NvbmZpZyBvYmplY3RzIGFuZCBhZGRzIHRvIG5vZGVzLlxuICAgICAqXG4gICAgICogT24gZWFjaCBbW1BhdGhOb2RlXV0sIGNyZWF0ZXMgVmlld0NvbmZpZyBvYmplY3RzIGZyb20gdGhlIHZpZXdzOiBwcm9wZXJ0eSBvZiB0aGUgbm9kZSdzIHN0YXRlXG4gICAgICovXG4gICAgUGF0aFV0aWxzLmFwcGx5Vmlld0NvbmZpZ3MgPSBmdW5jdGlvbiAoJHZpZXcsIHBhdGgsIHN0YXRlcykge1xuICAgICAgICAvLyBPbmx5IGFwcGx5IHRoZSB2aWV3Q29uZmlncyB0byB0aGUgbm9kZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZXNcbiAgICAgICAgcGF0aC5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGNvbW1vbl8xLmluQXJyYXkoc3RhdGVzLCBub2RlLnN0YXRlKTsgfSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHZpZXdEZWNscyA9IGNvbW1vbl8xLnZhbHVlcyhub2RlLnN0YXRlLnZpZXdzIHx8IHt9KTtcbiAgICAgICAgICAgIHZhciBzdWJQYXRoID0gUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gPT09IG5vZGU7IH0pO1xuICAgICAgICAgICAgdmFyIHZpZXdDb25maWdzID0gdmlld0RlY2xzLm1hcChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gJHZpZXcuY3JlYXRlVmlld0NvbmZpZyhzdWJQYXRoLCB2aWV3KTsgfSk7XG4gICAgICAgICAgICBub2RlLnZpZXdzID0gdmlld0NvbmZpZ3MucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGZyb21QYXRoIGFuZCBhIHRvUGF0aCwgcmV0dXJucyBhIG5ldyB0byBwYXRoIHdoaWNoIGluaGVyaXRzIHBhcmFtZXRlcnMgZnJvbSB0aGUgZnJvbVBhdGhcbiAgICAgKlxuICAgICAqIEZvciBhIHBhcmFtZXRlciBpbiBhIG5vZGUgdG8gYmUgaW5oZXJpdGVkIGZyb20gdGhlIGZyb20gcGF0aDpcbiAgICAgKiAtIFRoZSB0b1BhdGgncyBub2RlIG11c3QgaGF2ZSBhIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGZyb21QYXRoIChieSBzdGF0ZSkuXG4gICAgICogLSBUaGUgcGFyYW1ldGVyIG5hbWUgbXVzdCBub3QgYmUgZm91bmQgaW4gdGhlIHRvS2V5cyBwYXJhbWV0ZXIgYXJyYXkuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGUga2V5cyBwcm92aWRlZCBpbiB0b0tleXMgYXJlIGludGVuZGVkIHRvIGJlIHRob3NlIHBhcmFtIGtleXMgZXhwbGljaXRseSBzcGVjaWZpZWQgYnkgc29tZVxuICAgICAqIGNhbGxlciwgZm9yIGluc3RhbmNlLCAkc3RhdGUudHJhbnNpdGlvblRvKC4uLiwgdG9QYXJhbXMpLiAgSWYgYSBrZXkgd2FzIGZvdW5kIGluIHRvUGFyYW1zLFxuICAgICAqIGl0IGlzIG5vdCBpbmhlcml0ZWQgZnJvbSB0aGUgZnJvbVBhdGguXG4gICAgICovXG4gICAgUGF0aFV0aWxzLmluaGVyaXRQYXJhbXMgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRvUGF0aCwgdG9LZXlzKSB7XG4gICAgICAgIGlmICh0b0tleXMgPT09IHZvaWQgMCkgeyB0b0tleXMgPSBbXTsgfVxuICAgICAgICBmdW5jdGlvbiBub2RlUGFyYW1WYWxzKHBhdGgsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNvbW1vbl8xLmZpbmQocGF0aCwgaG9mXzEucHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHt9LCBub2RlICYmIG5vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub0luaGVyaXQgPSBmcm9tUGF0aFxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5wYXJhbVNjaGVtYTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gIXBhcmFtLmluaGVyaXQ7IH0pXG4gICAgICAgICAgICAubWFwKGhvZl8xLnByb3AoJ2lkJykpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYW4gW1tQYXRoTm9kZV1dIFwidG9Ob2RlXCIsIHJldHVybiBhIG5ldyBbW1BhdGhOb2RlXV0gd2l0aCBwYXJhbSB2YWx1ZXMgaW5oZXJpdGVkIGZyb20gdGhlXG4gICAgICAgICAqIG1hdGNoaW5nIG5vZGUgaW4gZnJvbVBhdGguICBPbmx5IGluaGVyaXQga2V5cyB0aGF0IGFyZW4ndCBmb3VuZCBpbiBcInRvS2V5c1wiIGZyb20gdGhlIG5vZGUgaW4gXCJmcm9tUGF0aFwiXCJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VJbmhlcml0ZWRQYXJhbXNOb2RlKHRvTm9kZSkge1xuICAgICAgICAgICAgLy8gQWxsIHBhcmFtIHZhbHVlcyBmb3IgdGhlIG5vZGUgKG1heSBpbmNsdWRlIGRlZmF1bHQga2V5L3ZhbHMsIHdoZW4ga2V5IHdhcyBub3QgZm91bmQgaW4gdG9QYXJhbXMpXG4gICAgICAgICAgICB2YXIgdG9QYXJhbVZhbHMgPSBjb21tb25fMS5leHRlbmQoe30sIHRvTm9kZSAmJiB0b05vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgICAgICAgLy8gbGltaXRlZCB0byBvbmx5IHRob3NlIGtleXMgZm91bmQgaW4gdG9QYXJhbXNcbiAgICAgICAgICAgIHZhciBpbmNvbWluZ1BhcmFtVmFscyA9IGNvbW1vbl8xLnBpY2sodG9QYXJhbVZhbHMsIHRvS2V5cyk7XG4gICAgICAgICAgICB0b1BhcmFtVmFscyA9IGNvbW1vbl8xLm9taXQodG9QYXJhbVZhbHMsIHRvS2V5cyk7XG4gICAgICAgICAgICB2YXIgZnJvbVBhcmFtVmFscyA9IGNvbW1vbl8xLm9taXQobm9kZVBhcmFtVmFscyhmcm9tUGF0aCwgdG9Ob2RlLnN0YXRlKSB8fCB7fSwgbm9Jbmhlcml0KTtcbiAgICAgICAgICAgIC8vIGV4dGVuZCB0b1BhcmFtVmFscyB3aXRoIGFueSBmcm9tUGFyYW1WYWxzLCB0aGVuIG92ZXJyaWRlIGFueSBvZiB0aG9zZSB0aG9zZSB3aXRoIGluY29taW5nUGFyYW1WYWxzXG4gICAgICAgICAgICB2YXIgb3duUGFyYW1WYWxzID0gY29tbW9uXzEuZXh0ZW5kKHRvUGFyYW1WYWxzLCBmcm9tUGFyYW1WYWxzLCBpbmNvbWluZ1BhcmFtVmFscyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHBhdGhOb2RlXzEuUGF0aE5vZGUodG9Ob2RlLnN0YXRlKS5hcHBseVJhd1BhcmFtcyhvd25QYXJhbVZhbHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBwYXJhbSBrZXlzIHNwZWNpZmllZCBieSB0aGUgaW5jb21pbmcgdG9QYXJhbXNcbiAgICAgICAgcmV0dXJuIHRvUGF0aC5tYXAobWFrZUluaGVyaXRlZFBhcmFtc05vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHRyZWUgY2hhbmdlcyAoZW50ZXJpbmcsIGV4aXRpbmcpIGJldHdlZW4gYSBmcm9tUGF0aCBhbmQgdG9QYXRoLlxuICAgICAqL1xuICAgIFBhdGhVdGlscy50cmVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdG9QYXRoLCByZWxvYWRTdGF0ZSkge1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5taW4oZnJvbVBhdGgubGVuZ3RoLCB0b1BhdGgubGVuZ3RoKTtcbiAgICAgICAgdmFyIGtlZXAgPSAwO1xuICAgICAgICB2YXIgbm9kZXNNYXRjaCA9IGZ1bmN0aW9uIChub2RlMSwgbm9kZTIpIHsgcmV0dXJuIG5vZGUxLmVxdWFscyhub2RlMiwgUGF0aFV0aWxzLm5vbkR5bmFtaWNQYXJhbXMpOyB9O1xuICAgICAgICB3aGlsZSAoa2VlcCA8IG1heCAmJiBmcm9tUGF0aFtrZWVwXS5zdGF0ZSAhPT0gcmVsb2FkU3RhdGUgJiYgbm9kZXNNYXRjaChmcm9tUGF0aFtrZWVwXSwgdG9QYXRoW2tlZXBdKSkge1xuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBHaXZlbiBhIHJldGFpbmVkIG5vZGUsIHJldHVybiBhIG5ldyBub2RlIHdoaWNoIHVzZXMgdGhlIHRvIG5vZGUncyBwYXJhbSB2YWx1ZXMgKi9cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlUb1BhcmFtcyhyZXRhaW5lZE5vZGUsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGNsb25lZCA9IHJldGFpbmVkTm9kZS5jbG9uZSgpO1xuICAgICAgICAgICAgY2xvbmVkLnBhcmFtVmFsdWVzID0gdG9QYXRoW2lkeF0ucGFyYW1WYWx1ZXM7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9tLCByZXRhaW5lZCwgZXhpdGluZywgZW50ZXJpbmcsIHRvO1xuICAgICAgICBmcm9tID0gZnJvbVBhdGg7XG4gICAgICAgIHJldGFpbmVkID0gZnJvbS5zbGljZSgwLCBrZWVwKTtcbiAgICAgICAgZXhpdGluZyA9IGZyb20uc2xpY2Uoa2VlcCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyByZXRhaW5lZCBwYXRoICh3aXRoIHNoYWxsb3cgY29waWVzIG9mIG5vZGVzKSB3aGljaCBoYXZlIHRoZSBwYXJhbXMgb2YgdGhlIHRvUGF0aCBtYXBwZWRcbiAgICAgICAgdmFyIHJldGFpbmVkV2l0aFRvUGFyYW1zID0gcmV0YWluZWQubWFwKGFwcGx5VG9QYXJhbXMpO1xuICAgICAgICBlbnRlcmluZyA9IHRvUGF0aC5zbGljZShrZWVwKTtcbiAgICAgICAgdG8gPSByZXRhaW5lZFdpdGhUb1BhcmFtcy5jb25jYXQoZW50ZXJpbmcpO1xuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tLCB0bzogdG8sIHJldGFpbmVkOiByZXRhaW5lZCwgcmV0YWluZWRXaXRoVG9QYXJhbXM6IHJldGFpbmVkV2l0aFRvUGFyYW1zLCBleGl0aW5nOiBleGl0aW5nLCBlbnRlcmluZzogZW50ZXJpbmcgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcGF0aCB3aGljaCBpczogdGhlIHN1YnBhdGggb2YgdGhlIGZpcnN0IHBhdGggd2hpY2ggbWF0Y2hlcyB0aGUgc2Vjb25kIHBhdGguXG4gICAgICpcbiAgICAgKiBUaGUgbmV3IHBhdGggc3RhcnRzIGZyb20gcm9vdCBhbmQgY29udGFpbnMgYW55IG5vZGVzIHRoYXQgbWF0Y2ggdGhlIG5vZGVzIGluIHRoZSBzZWNvbmQgcGF0aC5cbiAgICAgKiBJdCBzdG9wcyBiZWZvcmUgdGhlIGZpcnN0IG5vbi1tYXRjaGluZyBub2RlLlxuICAgICAqXG4gICAgICogTm9kZXMgYXJlIGNvbXBhcmVkIHVzaW5nIHRoZWlyIHN0YXRlIHByb3BlcnR5IGFuZCB0aGVpciBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAqIElmIGEgYHBhcmFtc0ZuYCBpcyBwcm92aWRlZCwgb25seSB0aGUgW1tQYXJhbV1dIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNvbnNpZGVyZWQgd2hlbiBjb21wYXJpbmcgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aEEgdGhlIGZpcnN0IHBhdGhcbiAgICAgKiBAcGFyYW0gcGF0aEIgdGhlIHNlY29uZCBwYXRoXG4gICAgICogQHBhcmFtIHBhcmFtc0ZuIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgcGFyYW1ldGVycyB0byBjb25zaWRlciB3aGVuIGNvbXBhcmluZ1xuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgUGF0aE5vZGVzIGZyb20gdGhlIGZpcnN0IHBhdGggd2hpY2ggbWF0Y2ggdGhlIG5vZGVzIGluIHRoZSBzZWNvbmQgcGF0aFxuICAgICAqL1xuICAgIFBhdGhVdGlscy5tYXRjaGluZyA9IGZ1bmN0aW9uIChwYXRoQSwgcGF0aEIsIHBhcmFtc0ZuKSB7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHZhciB0dXBsZXMgPSBjb21tb25fMS5hcnJheVR1cGxlcyhwYXRoQSwgcGF0aEIpO1xuICAgICAgICByZXR1cm4gdHVwbGVzLnJlZHVjZShmdW5jdGlvbiAobWF0Y2hpbmcsIF9hKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUEgPSBfYVswXSwgbm9kZUIgPSBfYVsxXTtcbiAgICAgICAgICAgIGRvbmUgPSBkb25lIHx8ICFub2RlQS5lcXVhbHMobm9kZUIsIHBhcmFtc0ZuKTtcbiAgICAgICAgICAgIHJldHVybiBkb25lID8gbWF0Y2hpbmcgOiBtYXRjaGluZy5jb25jYXQobm9kZUEpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdHdvIHBhdGhzIGFyZSBpZGVudGljYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aEFcbiAgICAgKiBAcGFyYW0gcGF0aEJcbiAgICAgKiBAcGFyYW0gcGFyYW1zRm4gYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnNpZGVyIHdoZW4gY29tcGFyaW5nXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdGhlIHN0YXRlcyBhbmQgcGFyYW1ldGVyIHZhbHVlcyBmb3IgYm90aCBwYXRocyBhcmUgaWRlbnRpY2FsXG4gICAgICovXG4gICAgUGF0aFV0aWxzLmVxdWFscyA9IGZ1bmN0aW9uIChwYXRoQSwgcGF0aEIsIHBhcmFtc0ZuKSB7XG4gICAgICAgIHJldHVybiBwYXRoQS5sZW5ndGggPT09IHBhdGhCLmxlbmd0aCAmJiBQYXRoVXRpbHMubWF0Y2hpbmcocGF0aEEsIHBhdGhCLCBwYXJhbXNGbikubGVuZ3RoID09PSBwYXRoQS5sZW5ndGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdWJwYXRoIG9mIGEgcGF0aCwgd2hpY2ggc3RvcHMgYXQgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGVcbiAgICAgKlxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIG5vZGVzLCByZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBhcnJheSBzdGFydGluZyBmcm9tIHRoZSBmaXJzdCBub2RlLFxuICAgICAqIHN0b3BwaW5nIHdoZW4gdGhlIGZpcnN0IG5vZGUgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggYSBwYXRoIG9mIFtbUGF0aE5vZGVdXXNcbiAgICAgKiBAcGFyYW0gcHJlZGljYXRlIGEgW1tQcmVkaWNhdGVdXSBmbiB0aGF0IG1hdGNoZXMgW1tQYXRoTm9kZV1dc1xuICAgICAqIEByZXR1cm5zIGEgc3VicGF0aCB1cCB0byB0aGUgbWF0Y2hpbmcgbm9kZSwgb3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoIGlzIGZvdW5kXG4gICAgICovXG4gICAgUGF0aFV0aWxzLnN1YlBhdGggPSBmdW5jdGlvbiAocGF0aCwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tbW9uXzEuZmluZChwYXRoLCBwcmVkaWNhdGUpO1xuICAgICAgICB2YXIgZWxlbWVudElkeCA9IHBhdGguaW5kZXhPZihub2RlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRJZHggPT09IC0xID8gdW5kZWZpbmVkIDogcGF0aC5zbGljZSgwLCBlbGVtZW50SWR4ICsgMSk7XG4gICAgfTtcbiAgICBQYXRoVXRpbHMubm9uRHluYW1pY1BhcmFtcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KS5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0uZHluYW1pYzsgfSk7XG4gICAgfTtcbiAgICAvKiogR2V0cyB0aGUgcmF3IHBhcmFtZXRlciB2YWx1ZXMgZnJvbSBhIHBhdGggKi9cbiAgICBQYXRoVXRpbHMucGFyYW1WYWx1ZXMgPSBmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkgeyByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGFjYywgbm9kZS5wYXJhbVZhbHVlcyk7IH0sIHt9KTsgfTtcbiAgICByZXR1cm4gUGF0aFV0aWxzO1xufSgpKTtcbmV4cG9ydHMuUGF0aFV0aWxzID0gUGF0aFV0aWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aFV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIHJlc29sdmUgKi8gLyoqIGZvciB0eXBlZG9jICovXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9pbnRlcmZhY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVzb2x2YWJsZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9yZXNvbHZlQ29udGV4dFwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmV4cG9ydHMucmVzb2x2ZVBvbGljaWVzID0ge1xuICAgIHdoZW46IHtcbiAgICAgICAgTEFaWTogJ0xBWlknLFxuICAgICAgICBFQUdFUjogJ0VBR0VSJyxcbiAgICB9LFxuICAgIGFzeW5jOiB7XG4gICAgICAgIFdBSVQ6ICdXQUlUJyxcbiAgICAgICAgTk9XQUlUOiAnTk9XQUlUJyxcbiAgICAgICAgUlhXQUlUOiAnUlhXQUlUJyxcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgcmVzb2x2ZVxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHByZWRpY2F0ZXNfMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbi8vIFRPRE86IGV4cGxpY2l0bHkgbWFrZSB0aGlzIHVzZXIgY29uZmlndXJhYmxlXG5leHBvcnRzLmRlZmF1bHRSZXNvbHZlUG9saWN5ID0ge1xuICAgIHdoZW46ICdMQVpZJyxcbiAgICBhc3luYzogJ1dBSVQnLFxufTtcbi8qKlxuICogVGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIGZvciB0aGUgcmVzb2x2ZSBzeXN0ZW0uXG4gKlxuICogUmVzb2x2YWJsZXMgZW5jYXBzdWxhdGUgYSBzdGF0ZSdzIHJlc29sdmUncyByZXNvbHZlRm4sIHRoZSByZXNvbHZlRm4ncyBkZWNsYXJlZCBkZXBlbmRlbmNpZXMsIHRoZSB3cmFwcGVkICgucHJvbWlzZSksXG4gKiBhbmQgdGhlIHVud3JhcHBlZC13aGVuLWNvbXBsZXRlICguZGF0YSkgcmVzdWx0IG9mIHRoZSByZXNvbHZlRm4uXG4gKlxuICogUmVzb2x2YWJsZS5nZXQoKSBlaXRoZXIgcmV0cmlldmVzIHRoZSBSZXNvbHZhYmxlJ3MgZXhpc3RpbmcgcHJvbWlzZSwgb3IgZWxzZSBpbnZva2VzIHJlc29sdmUoKSAod2hpY2ggaW52b2tlcyB0aGVcbiAqIHJlc29sdmVGbikgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBwcm9taXNlLlxuICpcbiAqIFJlc29sdmFibGUuZ2V0KCkgYW5kIFJlc29sdmFibGUucmVzb2x2ZSgpIGJvdGggZXhlY3V0ZSB3aXRoaW4gYSBjb250ZXh0IHBhdGgsIHdoaWNoIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3RcbiAqIHBhcmFtZXRlciB0byB0aG9zZSBmbnMuXG4gKi9cbnZhciBSZXNvbHZhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc29sdmFibGUoYXJnMSwgcmVzb2x2ZUZuLCBkZXBzLCBwb2xpY3ksIGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgUmVzb2x2YWJsZSkge1xuICAgICAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIGFyZzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHJlc29sdmVGbikpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzIuaXNOdWxsT3JVbmRlZmluZWQoYXJnMSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUmVzb2x2YWJsZSgpOiB0b2tlbiBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihyZXNvbHZlRm4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJlc29sdmFibGUoKTogcmVzb2x2ZUZuIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IGFyZzE7XG4gICAgICAgICAgICB0aGlzLnBvbGljeSA9IHBvbGljeTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUZuID0gcmVzb2x2ZUZuO1xuICAgICAgICAgICAgdGhpcy5kZXBzID0gZGVwcyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gZGF0YSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5yZXNvbHZlZCA/IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4odGhpcy5kYXRhKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVkaWNhdGVzXzEuaXNPYmplY3QoYXJnMSkgJiYgYXJnMS50b2tlbiAmJiAoYXJnMS5oYXNPd25Qcm9wZXJ0eSgncmVzb2x2ZUZuJykgfHwgYXJnMS5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKSkge1xuICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSBhcmcxO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKGxpdGVyYWwudG9rZW4sIGxpdGVyYWwucmVzb2x2ZUZuLCBsaXRlcmFsLmRlcHMsIGxpdGVyYWwucG9saWN5LCBsaXRlcmFsLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmFibGUucHJvdG90eXBlLmdldFBvbGljeSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgdGhpc1BvbGljeSA9IHRoaXMucG9saWN5IHx8IHt9O1xuICAgICAgICB2YXIgc3RhdGVQb2xpY3kgPSAoc3RhdGUgJiYgc3RhdGUucmVzb2x2ZVBvbGljeSkgfHwge307XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aGVuOiB0aGlzUG9saWN5LndoZW4gfHwgc3RhdGVQb2xpY3kud2hlbiB8fCBleHBvcnRzLmRlZmF1bHRSZXNvbHZlUG9saWN5LndoZW4sXG4gICAgICAgICAgICBhc3luYzogdGhpc1BvbGljeS5hc3luYyB8fCBzdGF0ZVBvbGljeS5hc3luYyB8fCBleHBvcnRzLmRlZmF1bHRSZXNvbHZlUG9saWN5LmFzeW5jLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmVzb2x2ZSB0aGlzIFJlc29sdmFibGUncyBkYXRhXG4gICAgICpcbiAgICAgKiBHaXZlbiBhIFJlc29sdmVDb250ZXh0IHRoYXQgdGhpcyBSZXNvbHZhYmxlIGlzIGZvdW5kIGluOlxuICAgICAqIFdhaXQgZm9yIHRoaXMgUmVzb2x2YWJsZSdzIGRlcGVuZGVuY2llcywgdGhlbiBpbnZva2UgdGhpcyBSZXNvbHZhYmxlJ3MgZnVuY3Rpb25cbiAgICAgKiBhbmQgdXBkYXRlIHRoZSBSZXNvbHZhYmxlJ3Mgc3RhdGVcbiAgICAgKi9cbiAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHJlc29sdmVDb250ZXh0LCB0cmFucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgJHEgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcTtcbiAgICAgICAgLy8gR2V0cyBhbGwgZGVwZW5kZW5jaWVzIGZyb20gUmVzb2x2ZUNvbnRleHQgYW5kIHdhaXQgZm9yIHRoZW0gdG8gYmUgcmVzb2x2ZWRcbiAgICAgICAgdmFyIGdldFJlc29sdmFibGVEZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHJlc29sdmVDb250ZXh0LmdldERlcGVuZGVuY2llcyhfdGhpcykubWFwKGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7IHJldHVybiByZXNvbHZhYmxlLmdldChyZXNvbHZlQ29udGV4dCwgdHJhbnMpOyB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEludm9rZXMgdGhlIHJlc29sdmUgZnVuY3Rpb24gcGFzc2luZyB0aGUgcmVzb2x2ZWQgZGVwZW5kZW5jaWVzIGFzIGFyZ3VtZW50c1xuICAgICAgICB2YXIgaW52b2tlUmVzb2x2ZUZuID0gZnVuY3Rpb24gKHJlc29sdmVkRGVwcykgeyByZXR1cm4gX3RoaXMucmVzb2x2ZUZuLmFwcGx5KG51bGwsIHJlc29sdmVkRGVwcyk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgUlhXQUlUIHBvbGljeTpcbiAgICAgICAgICpcbiAgICAgICAgICogR2l2ZW4gYW4gb2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIGEgcmVzb2x2ZSBmdW5jdGlvbjpcbiAgICAgICAgICogLSBlbmFibGVzIC5jYWNoZSgpIG1vZGUgKHRoaXMgYWxsb3dzIG11bHRpY2FzdCBzdWJzY3JpYmVycylcbiAgICAgICAgICogLSB0aGVuIGNhbGxzIHRvUHJvbWlzZSgpICh0aGlzIHRyaWdnZXJzIHN1YnNjcmliZSgpIGFuZCB0aHVzIGZldGNoZXMpXG4gICAgICAgICAqIC0gV2FpdHMgZm9yIHRoZSBwcm9taXNlLCB0aGVuIHJldHVybiB0aGUgY2FjaGVkIG9ic2VydmFibGUgKG5vdCB0aGUgZmlyc3QgZW1pdHRlZCB2YWx1ZSkuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgd2FpdEZvclJ4ID0gZnVuY3Rpb24gKG9ic2VydmFibGUkKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVkID0gb2JzZXJ2YWJsZSQuY2FjaGUoMSk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkXG4gICAgICAgICAgICAgICAgLnRha2UoMSlcbiAgICAgICAgICAgICAgICAudG9Qcm9taXNlKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZWQ7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiB0aGUgcmVzb2x2ZSBwb2xpY3kgaXMgUlhXQUlULCB3YWl0IGZvciB0aGUgb2JzZXJ2YWJsZSB0byBlbWl0IHNvbWV0aGluZy4gb3RoZXJ3aXNlIHBhc3MgdGhyb3VnaC5cbiAgICAgICAgdmFyIG5vZGUgPSByZXNvbHZlQ29udGV4dC5maW5kTm9kZSh0aGlzKTtcbiAgICAgICAgdmFyIHN0YXRlID0gbm9kZSAmJiBub2RlLnN0YXRlO1xuICAgICAgICB2YXIgbWF5YmVXYWl0Rm9yUnggPSB0aGlzLmdldFBvbGljeShzdGF0ZSkuYXN5bmMgPT09ICdSWFdBSVQnID8gd2FpdEZvclJ4IDogY29tbW9uXzEuaWRlbnRpdHk7XG4gICAgICAgIC8vIEFmdGVyIHRoZSBmaW5hbCB2YWx1ZSBoYXMgYmVlbiByZXNvbHZlZCwgdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgUmVzb2x2YWJsZVxuICAgICAgICB2YXIgYXBwbHlSZXNvbHZlZFZhbHVlID0gZnVuY3Rpb24gKHJlc29sdmVkVmFsdWUpIHtcbiAgICAgICAgICAgIF90aGlzLmRhdGEgPSByZXNvbHZlZFZhbHVlO1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZUZuID0gbnVsbDtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VSZXNvbHZhYmxlUmVzb2x2ZWQoX3RoaXMsIHRyYW5zKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5kYXRhO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTZXRzIHRoZSBwcm9taXNlIHByb3BlcnR5IGZpcnN0LCB0aGVuIGdldHNSZXNvbHZhYmxlRGVwZW5kZW5jaWVzIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcm9taXNlIGNoYWluLiBBbHdheXMgd2FpdHMgb25lIHRpY2suXG4gICAgICAgIHJldHVybiAodGhpcy5wcm9taXNlID0gJHFcbiAgICAgICAgICAgIC53aGVuKClcbiAgICAgICAgICAgIC50aGVuKGdldFJlc29sdmFibGVEZXBlbmRlbmNpZXMpXG4gICAgICAgICAgICAudGhlbihpbnZva2VSZXNvbHZlRm4pXG4gICAgICAgICAgICAudGhlbihtYXliZVdhaXRGb3JSeClcbiAgICAgICAgICAgIC50aGVuKGFwcGx5UmVzb2x2ZWRWYWx1ZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHByb21pc2UgZm9yIHRoaXMgUmVzb2x2YWJsZSdzIGRhdGEuXG4gICAgICpcbiAgICAgKiBGZXRjaGVzIHRoZSBkYXRhIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICAgKiBSZXR1cm5zIHRoZSBleGlzdGluZyBwcm9taXNlIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gZmV0Y2hlZCBvbmNlLlxuICAgICAqL1xuICAgIFJlc29sdmFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChyZXNvbHZlQ29udGV4dCwgdHJhbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSB8fCB0aGlzLnJlc29sdmUocmVzb2x2ZUNvbnRleHQsIHRyYW5zKTtcbiAgICB9O1xuICAgIFJlc29sdmFibGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXNvbHZhYmxlKHRva2VuOiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodGhpcy50b2tlbikgKyBcIiwgcmVxdWlyZXM6IFtcIiArIHRoaXMuZGVwcy5tYXAoc3RyaW5nc18xLnN0cmluZ2lmeSkgKyBcIl0pXCI7XG4gICAgfTtcbiAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKHRoaXMpO1xuICAgIH07XG4gICAgUmVzb2x2YWJsZS5mcm9tRGF0YSA9IGZ1bmN0aW9uICh0b2tlbiwgZGF0YSkgeyByZXR1cm4gbmV3IFJlc29sdmFibGUodG9rZW4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGE7IH0sIG51bGwsIG51bGwsIGRhdGEpOyB9O1xuICAgIHJldHVybiBSZXNvbHZhYmxlO1xufSgpKTtcbmV4cG9ydHMuUmVzb2x2YWJsZSA9IFJlc29sdmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgcmVzb2x2ZSAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7XG52YXIgcmVzb2x2YWJsZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2YWJsZVwiKTtcbnZhciBwYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9wYXRoL3BhdGhVdGlsc1wiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG52YXIgY29tbW9uXzIgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIHdoZW5zID0gaW50ZXJmYWNlXzEucmVzb2x2ZVBvbGljaWVzLndoZW47XG52YXIgQUxMX1dIRU5TID0gW3doZW5zLkVBR0VSLCB3aGVucy5MQVpZXTtcbnZhciBFQUdFUl9XSEVOUyA9IFt3aGVucy5FQUdFUl07XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5mZXJyYWJsZS10eXBlc1xuZXhwb3J0cy5OQVRJVkVfSU5KRUNUT1JfVE9LRU4gPSAnTmF0aXZlIEluamVjdG9yJztcbi8qKlxuICogRW5jYXBzdWxhdGVzIERlcGVuZGVuY3kgSW5qZWN0aW9uIGZvciBhIHBhdGggb2Ygbm9kZXNcbiAqXG4gKiBVSS1Sb3V0ZXIgc3RhdGVzIGFyZSBvcmdhbml6ZWQgYXMgYSB0cmVlLlxuICogQSBuZXN0ZWQgc3RhdGUgaGFzIGEgcGF0aCBvZiBhbmNlc3RvcnMgdG8gdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gKiBXaGVuIGEgc3RhdGUgaXMgYmVpbmcgYWN0aXZhdGVkLCBlYWNoIGVsZW1lbnQgaW4gdGhlIHBhdGggaXMgd3JhcHBlZCBhcyBhIFtbUGF0aE5vZGVdXS5cbiAqIEEgYFBhdGhOb2RlYCBpcyBhIHN0YXRlZnVsIG9iamVjdCB0aGF0IGhvbGRzIHRoaW5ncyBsaWtlIHBhcmFtZXRlcnMgYW5kIHJlc29sdmFibGVzIGZvciB0aGUgc3RhdGUgYmVpbmcgYWN0aXZhdGVkLlxuICpcbiAqIFRoZSBSZXNvbHZlQ29udGV4dCBjbG9zZXMgb3ZlciB0aGUgW1tQYXRoTm9kZV1dcywgYW5kIHByb3ZpZGVzIERJIGZvciB0aGUgbGFzdCBub2RlIGluIHRoZSBwYXRoLlxuICovXG52YXIgUmVzb2x2ZUNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb2x2ZUNvbnRleHQoX3BhdGgpIHtcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xuICAgIH1cbiAgICAvKiogR2V0cyBhbGwgdGhlIHRva2VucyBmb3VuZCBpbiB0aGUgcmVzb2x2ZSBjb250ZXh0LCBkZS1kdXBsaWNhdGVkICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmdldFRva2VucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHsgcmV0dXJuIGFjYy5jb25jYXQobm9kZS5yZXNvbHZhYmxlcy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudG9rZW47IH0pKTsgfSwgW10pLnJlZHVjZShjb21tb25fMS51bmlxUiwgW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUmVzb2x2YWJsZSB0aGF0IG1hdGNoZXMgdGhlIHRva2VuXG4gICAgICpcbiAgICAgKiBHZXRzIHRoZSBsYXN0IFJlc29sdmFibGUgdGhhdCBtYXRjaGVzIHRoZSB0b2tlbiBpbiB0aGlzIGNvbnRleHQsIG9yIHVuZGVmaW5lZC5cbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZG9lc24ndCBleGlzdCBpbiB0aGUgUmVzb2x2ZUNvbnRleHRcbiAgICAgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuZ2V0UmVzb2x2YWJsZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgbWF0Y2hpbmcgPSB0aGlzLl9wYXRoXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnJlc29sdmFibGVzOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudG9rZW4gPT09IHRva2VuOyB9KTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnRhaWwobWF0Y2hpbmcpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIFtbUmVzb2x2ZVBvbGljeV1dIGZvciB0aGUgZ2l2ZW4gW1tSZXNvbHZhYmxlXV0gKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuZ2V0UG9saWN5ID0gZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmZpbmROb2RlKHJlc29sdmFibGUpO1xuICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXRQb2xpY3kobm9kZS5zdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUmVzb2x2ZUNvbnRleHQgdGhhdCBpbmNsdWRlcyBhIHBvcnRpb24gb2YgdGhpcyBvbmVcbiAgICAgKlxuICAgICAqIEdpdmVuIGEgc3RhdGUsIHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgUmVzb2x2ZUNvbnRleHQgZnJvbSB0aGlzIG9uZS5cbiAgICAgKiBUaGUgbmV3IGNvbnRleHQgc3RhcnRzIGF0IHRoZSBmaXJzdCBub2RlIChyb290KSBhbmQgc3RvcHMgYXQgdGhlIG5vZGUgZm9yIHRoZSBgc3RhdGVgIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqICMjIyMgV2h5XG4gICAgICpcbiAgICAgKiBXaGVuIGEgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLCB0aGUgbm9kZXMgaW4gdGhlIFwiVG8gUGF0aFwiIGFyZSBpbmplY3RlZCBmcm9tIGEgUmVzb2x2ZUNvbnRleHQuXG4gICAgICogQSBSZXNvbHZlQ29udGV4dCBjbG9zZXMgb3ZlciBhIHBhdGggb2YgW1tQYXRoTm9kZV1dcyBhbmQgcHJvY2Vzc2VzIHRoZSByZXNvbHZhYmxlcy5cbiAgICAgKiBUaGUgXCJUbyBTdGF0ZVwiIGNhbiBpbmplY3QgdmFsdWVzIGZyb20gaXRzIG93biByZXNvbHZhYmxlcywgYXMgd2VsbCBhcyB0aG9zZSBmcm9tIGFsbCBpdHMgYW5jZXN0b3Igc3RhdGUncyAobm9kZSdzKS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG5hcnJvd2VyIGNvbnRleHQgd2hlbiBpbmplY3RpbmcgYW5jZXN0b3Igbm9kZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBsZXQgQUJDRCA9IG5ldyBSZXNvbHZlQ29udGV4dChbQSwgQiwgQywgRF0pO2BcbiAgICAgKlxuICAgICAqIEdpdmVuIGEgcGF0aCBgW0EsIEIsIEMsIERdYCwgd2hlcmUgYEFgLCBgQmAsIGBDYCBhbmQgYERgIGFyZSBub2RlcyBmb3Igc3RhdGVzIGBhYCwgYGJgLCBgY2AsIGBkYDpcbiAgICAgKiBXaGVuIGluamVjdGluZyBgRGAsIGBEYCBzaG91bGQgaGF2ZSBhY2Nlc3MgdG8gYWxsIHJlc29sdmFibGVzIGZyb20gYEFgLCBgQmAsIGBDYCwgYERgLlxuICAgICAqIEhvd2V2ZXIsIGBCYCBzaG91bGQgb25seSBiZSBhYmxlIHRvIGFjY2VzcyByZXNvbHZhYmxlcyBmcm9tIGBBYCwgYEJgLlxuICAgICAqXG4gICAgICogV2hlbiByZXNvbHZpbmcgZm9yIHRoZSBgQmAgbm9kZSwgZmlyc3QgdGFrZSB0aGUgZnVsbCBcIlRvIFBhdGhcIiBDb250ZXh0IGBbQSxCLEMsRF1gIGFuZCBsaW1pdCB0byB0aGUgc3VicGF0aCBgW0EsQl1gLlxuICAgICAqIGBsZXQgQUIgPSBBQkNELnN1YmNvbnRleHQoYSlgXG4gICAgICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLnN1YkNvbnRleHQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlQ29udGV4dChwYXRoVXRpbHNfMS5QYXRoVXRpbHMuc3ViUGF0aCh0aGlzLl9wYXRoLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5zdGF0ZSA9PT0gc3RhdGU7IH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgUmVzb2x2YWJsZXMgdG8gdGhlIG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBzdGF0ZVxuICAgICAqXG4gICAgICogVGhpcyBhZGRzIGEgW1tSZXNvbHZhYmxlXV0gKGdlbmVyYWxseSBvbmUgY3JlYXRlZCBvbiB0aGUgZmx5OyBub3QgZGVjbGFyZWQgb24gYSBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dIGJsb2NrKS5cbiAgICAgKiBUaGUgcmVzb2x2YWJsZSBpcyBhZGRlZCB0byB0aGUgbm9kZSBtYXRjaGluZyB0aGUgYHN0YXRlYCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBUaGVzZSBuZXcgcmVzb2x2YWJsZXMgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IGZldGNoZWQuXG4gICAgICogVGhlIGNhbGxpbmcgY29kZSBzaG91bGQgZWl0aGVyIGZldGNoIHRoZW0sIGZldGNoIHNvbWV0aGluZyB0aGF0IGRlcGVuZHMgb24gdGhlbSxcbiAgICAgKiBvciByZWx5IG9uIFtbcmVzb2x2ZVBhdGhdXSBiZWluZyBjYWxsZWQgd2hlbiBzb21lIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBlYWNoIHJlc29sdmFibGUncyBbW1Jlc29sdmVQb2xpY3ldXSBpcyBtZXJnZWQgd2l0aCB0aGUgc3RhdGUncyBwb2xpY3ksIGFuZCB0aGUgZ2xvYmFsIGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3UmVzb2x2YWJsZXMgdGhlIG5ldyBSZXNvbHZhYmxlc1xuICAgICAqIEBwYXJhbSBzdGF0ZSBVc2VkIHRvIGZpbmQgdGhlIG5vZGUgdG8gcHV0IHRoZSByZXNvbHZhYmxlIG9uXG4gICAgICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmFkZFJlc29sdmFibGVzID0gZnVuY3Rpb24gKG5ld1Jlc29sdmFibGVzLCBzdGF0ZSkge1xuICAgICAgICB2YXIgbm9kZSA9IGNvbW1vbl8xLmZpbmQodGhpcy5fcGF0aCwgaG9mXzEucHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgICAgIHZhciBrZXlzID0gbmV3UmVzb2x2YWJsZXMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRva2VuOyB9KTtcbiAgICAgICAgbm9kZS5yZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBrZXlzLmluZGV4T2Yoci50b2tlbikgPT09IC0xOyB9KS5jb25jYXQobmV3UmVzb2x2YWJsZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHJlc29sdmVkIHBhdGggRWxlbWVudCBwcm9taXNlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHdoZW5cbiAgICAgKiBAcGFyYW0gdHJhbnNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fGFueX1cbiAgICAgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUucmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAod2hlbiwgdHJhbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHdoZW4gPT09IHZvaWQgMCkgeyB3aGVuID0gJ0xBWlknOyB9XG4gICAgICAgIC8vIFRoaXMgb3B0aW9uIGRldGVybWluZXMgd2hpY2ggJ3doZW4nIHBvbGljeSBSZXNvbHZhYmxlcyB3ZSBhcmUgYWJvdXQgdG8gZmV0Y2guXG4gICAgICAgIHZhciB3aGVuT3B0aW9uID0gY29tbW9uXzEuaW5BcnJheShBTExfV0hFTlMsIHdoZW4pID8gd2hlbiA6ICdMQVpZJztcbiAgICAgICAgLy8gSWYgdGhlIGNhbGxlciBzcGVjaWZpZWQgRUFHRVIsIG9ubHkgdGhlIEVBR0VSIFJlc29sdmFibGVzIGFyZSBmZXRjaGVkLlxuICAgICAgICAvLyBpZiB0aGUgY2FsbGVyIHNwZWNpZmllZCBMQVpZLCBib3RoIEVBR0VSIGFuZCBMQVpZIFJlc29sdmFibGVzIGFyZSBmZXRjaGVkLmBcbiAgICAgICAgdmFyIG1hdGNoZWRXaGVucyA9IHdoZW5PcHRpb24gPT09IGludGVyZmFjZV8xLnJlc29sdmVQb2xpY2llcy53aGVuLkVBR0VSID8gRUFHRVJfV0hFTlMgOiBBTExfV0hFTlM7XG4gICAgICAgIC8vIGdldCB0aGUgc3VicGF0aCB0byB0aGUgc3RhdGUgYXJndW1lbnQsIGlmIHByb3ZpZGVkXG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VSZXNvbHZlUGF0aCh0aGlzLl9wYXRoLCB3aGVuLCB0cmFucyk7XG4gICAgICAgIHZhciBtYXRjaGVzUG9saWN5ID0gZnVuY3Rpb24gKGFjY2VwdGVkVmFscywgd2hlbk9yQXN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuaW5BcnJheShhY2NlcHRlZFZhbHMsIF90aGlzLmdldFBvbGljeShyZXNvbHZhYmxlKVt3aGVuT3JBc3luY10pO1xuICAgICAgICB9OyB9O1xuICAgICAgICAvLyBUcmlnZ2VyIGFsbCB0aGUgKG1hdGNoaW5nKSBSZXNvbHZhYmxlcyBpbiB0aGUgcGF0aFxuICAgICAgICAvLyBSZWR1Y2UgYWxsIHRoZSBcIldBSVRcIiBSZXNvbHZhYmxlcyBpbnRvIGFuIGFycmF5XG4gICAgICAgIHZhciBwcm9taXNlcyA9IHRoaXMuX3BhdGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlUmVzb2x2YWJsZXMgPSBub2RlLnJlc29sdmFibGVzLmZpbHRlcihtYXRjaGVzUG9saWN5KG1hdGNoZWRXaGVucywgJ3doZW4nKSk7XG4gICAgICAgICAgICB2YXIgbm93YWl0ID0gbm9kZVJlc29sdmFibGVzLmZpbHRlcihtYXRjaGVzUG9saWN5KFsnTk9XQUlUJ10sICdhc3luYycpKTtcbiAgICAgICAgICAgIHZhciB3YWl0ID0gbm9kZVJlc29sdmFibGVzLmZpbHRlcihob2ZfMS5ub3QobWF0Y2hlc1BvbGljeShbJ05PV0FJVCddLCAnYXN5bmMnKSkpO1xuICAgICAgICAgICAgLy8gRm9yIHRoZSBtYXRjaGluZyBSZXNvbHZhYmxlcywgc3RhcnQgdGhlaXIgYXN5bmMgZmV0Y2ggcHJvY2Vzcy5cbiAgICAgICAgICAgIHZhciBzdWJDb250ZXh0ID0gX3RoaXMuc3ViQ29udGV4dChub2RlLnN0YXRlKTtcbiAgICAgICAgICAgIHZhciBnZXRSZXN1bHQgPSBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgICAgICAgICAgICAgIC5nZXQoc3ViQ29udGV4dCwgdHJhbnMpXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhIHR1cGxlIHRoYXQgaW5jbHVkZXMgdGhlIFJlc29sdmFibGUncyB0b2tlblxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh7IHRva2VuOiByLnRva2VuLCB2YWx1ZTogdmFsdWUgfSk7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vd2FpdC5mb3JFYWNoKGdldFJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjLmNvbmNhdCh3YWl0Lm1hcChnZXRSZXN1bHQpKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICAvLyBXYWl0IGZvciBhbGwgdGhlIFwiV0FJVFwiIHJlc29sdmFibGVzXG4gICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmluamVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5qZWN0b3IgfHwgKHRoaXMuX2luamVjdG9yID0gbmV3IFVJSW5qZWN0b3JJbXBsKHRoaXMpKTtcbiAgICB9O1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5maW5kTm9kZSA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS5maW5kKHRoaXMuX3BhdGgsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBjb21tb25fMS5pbkFycmF5KG5vZGUucmVzb2x2YWJsZXMsIHJlc29sdmFibGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFzeW5jIGRlcGVuZGVuY2llcyBvZiBhIFJlc29sdmFibGVcbiAgICAgKlxuICAgICAqIEdpdmVuIGEgUmVzb2x2YWJsZSwgcmV0dXJucyBpdHMgZGVwZW5kZW5jaWVzIGFzIGEgUmVzb2x2YWJsZVtdXG4gICAgICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmdldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5maW5kTm9kZShyZXNvbHZhYmxlKTtcbiAgICAgICAgLy8gRmluZCB3aGljaCBvdGhlciByZXNvbHZhYmxlcyBhcmUgXCJ2aXNpYmxlXCIgdG8gdGhlIGByZXNvbHZhYmxlYCBhcmd1bWVudFxuICAgICAgICAvLyBzdWJwYXRoIHN0b3BwaW5nIGF0IHJlc29sdmFibGUncyBub2RlLCBvciB0aGUgd2hvbGUgcGF0aCAoaWYgdGhlIHJlc29sdmFibGUgaXNuJ3QgaW4gdGhlIHBhdGgpXG4gICAgICAgIHZhciBzdWJQYXRoID0gcGF0aFV0aWxzXzEuUGF0aFV0aWxzLnN1YlBhdGgodGhpcy5fcGF0aCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPT09IG5vZGU7IH0pIHx8IHRoaXMuX3BhdGg7XG4gICAgICAgIHZhciBhdmFpbGFibGVSZXNvbHZhYmxlcyA9IHN1YlBhdGhcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX25vZGUpIHsgcmV0dXJuIGFjYy5jb25jYXQoX25vZGUucmVzb2x2YWJsZXMpOyB9LCBbXSkgLy8gYWxsIG9mIHN1YnBhdGgncyByZXNvbHZhYmxlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMgIT09IHJlc29sdmFibGU7IH0pOyAvLyBmaWx0ZXIgb3V0IHRoZSBgcmVzb2x2YWJsZWAgYXJndW1lbnRcbiAgICAgICAgdmFyIGdldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IGF2YWlsYWJsZVJlc29sdmFibGVzLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gci50b2tlbiA9PT0gdG9rZW47IH0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbChtYXRjaGluZyk7XG4gICAgICAgICAgICB2YXIgZnJvbUluamVjdG9yID0gX3RoaXMuaW5qZWN0b3IoKS5nZXROYXRpdmUodG9rZW4pO1xuICAgICAgICAgICAgaWYgKGNvbW1vbl8yLmlzVW5kZWZpbmVkKGZyb21JbmplY3RvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIERlcGVuZGVuY3kgSW5qZWN0aW9uIHRva2VuOiAnICsgc3RyaW5nc18xLnN0cmluZ2lmeSh0b2tlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0b2tlbiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJvbUluamVjdG9yOyB9LCBbXSwgZnJvbUluamVjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZGVwcy5tYXAoZ2V0RGVwZW5kZW5jeSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzb2x2ZUNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5SZXNvbHZlQ29udGV4dCA9IFJlc29sdmVDb250ZXh0O1xudmFyIFVJSW5qZWN0b3JJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJSW5qZWN0b3JJbXBsKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5uYXRpdmUgPSB0aGlzLmdldChleHBvcnRzLk5BVElWRV9JTkpFQ1RPUl9UT0tFTikgfHwgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yO1xuICAgIH1cbiAgICBVSUluamVjdG9ySW1wbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciByZXNvbHZhYmxlID0gdGhpcy5jb250ZXh0LmdldFJlc29sdmFibGUodG9rZW4pO1xuICAgICAgICBpZiAocmVzb2x2YWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5nZXRQb2xpY3kocmVzb2x2YWJsZSkuYXN5bmMgPT09ICdOT1dBSVQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc29sdmFibGUucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmFibGUgYXN5bmMgLmdldCgpIG5vdCBjb21wbGV0ZTonICsgc3RyaW5nc18xLnN0cmluZ2lmeShyZXNvbHZhYmxlLnRva2VuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZSh0b2tlbik7XG4gICAgfTtcbiAgICBVSUluamVjdG9ySW1wbC5wcm90b3R5cGUuZ2V0QXN5bmMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHJlc29sdmFibGUgPSB0aGlzLmNvbnRleHQuZ2V0UmVzb2x2YWJsZSh0b2tlbik7XG4gICAgICAgIGlmIChyZXNvbHZhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHRoaXMubmF0aXZlLmdldCh0b2tlbikpO1xuICAgIH07XG4gICAgVUlJbmplY3RvckltcGwucHJvdG90eXBlLmdldE5hdGl2ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmUgJiYgdGhpcy5uYXRpdmUuZ2V0KHRva2VuKTtcbiAgICB9O1xuICAgIHJldHVybiBVSUluamVjdG9ySW1wbDtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlQ29udGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgY29yZVxuICovIC8qKiAqL1xudmFyIHVybE1hdGNoZXJGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi91cmwvdXJsTWF0Y2hlckZhY3RvcnlcIik7XG52YXIgdXJsUm91dGVyXzEgPSByZXF1aXJlKFwiLi91cmwvdXJsUm91dGVyXCIpO1xudmFyIHRyYW5zaXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlXCIpO1xudmFyIHZpZXdfMSA9IHJlcXVpcmUoXCIuL3ZpZXcvdmlld1wiKTtcbnZhciBzdGF0ZVJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9zdGF0ZS9zdGF0ZVJlZ2lzdHJ5XCIpO1xudmFyIHN0YXRlU2VydmljZV8xID0gcmVxdWlyZShcIi4vc3RhdGUvc3RhdGVTZXJ2aWNlXCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHVybFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3VybC91cmxTZXJ2aWNlXCIpO1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi9jb21tb24vdHJhY2VcIik7XG4vKiogQGhpZGRlbiAqL1xudmFyIF9yb3V0ZXJJbnN0YW5jZSA9IDA7XG4vKipcbiAqIFRoZSBtYXN0ZXIgY2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZiBVSS1Sb3V0ZXIuXG4gKlxuICogVUktUm91dGVyIChmb3IgZWFjaCBzcGVjaWZpYyBmcmFtZXdvcmspIHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZHVyaW5nIGJvb3RzdHJhcC5cbiAqIFRoaXMgY2xhc3MgaW5zdGFudGlhdGVzIGFuZCB3aXJlcyB0aGUgVUktUm91dGVyIHNlcnZpY2VzIHRvZ2V0aGVyLlxuICpcbiAqIEFmdGVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBVSVJvdXRlciBjbGFzcyBpcyBjcmVhdGVkLCBpdCBzaG91bGQgYmUgY29uZmlndXJlZCBmb3IgeW91ciBhcHAuXG4gKiBGb3IgaW5zdGFuY2UsIGFwcCBzdGF0ZXMgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgW1tVSVJvdXRlci5zdGF0ZVJlZ2lzdHJ5XV0uXG4gKlxuICogLS0tXG4gKlxuICogTm9ybWFsbHkgdGhlIGZyYW1ld29yayBjb2RlIHdpbGwgYm9vdHN0cmFwIFVJLVJvdXRlci5cbiAqIElmIHlvdSBhcmUgYm9vdHN0cmFwcGluZyBVSVJvdXRlciBtYW51YWxseSwgdGVsbCBpdCB0byBtb25pdG9yIHRoZSBVUkwgYnkgY2FsbGluZ1xuICogW1tVcmxTZXJ2aWNlLmxpc3Rlbl1dIHRoZW4gW1tVcmxTZXJ2aWNlLnN5bmNdXS5cbiAqL1xudmFyIFVJUm91dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFVJUm91dGVyYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhdGlvblNlcnZpY2UgYSBbW0xvY2F0aW9uU2VydmljZXNdXSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSBsb2NhdGlvbkNvbmZpZyBhIFtbTG9jYXRpb25Db25maWddXSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVJUm91dGVyKGxvY2F0aW9uU2VydmljZSwgbG9jYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uU2VydmljZSA9PT0gdm9pZCAwKSB7IGxvY2F0aW9uU2VydmljZSA9IHVybFNlcnZpY2VfMS5VcmxTZXJ2aWNlLmxvY2F0aW9uU2VydmljZVN0dWI7IH1cbiAgICAgICAgaWYgKGxvY2F0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgbG9jYXRpb25Db25maWcgPSB1cmxTZXJ2aWNlXzEuVXJsU2VydmljZS5sb2NhdGlvbkNvbmZpZ1N0dWI7IH1cbiAgICAgICAgdGhpcy5sb2NhdGlvblNlcnZpY2UgPSBsb2NhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYXRpb25Db25maWcgPSBsb2NhdGlvbkNvbmZpZztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy4kaWQgPSBfcm91dGVySW5zdGFuY2UrKztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fZGlzcG9zYWJsZXMgPSBbXTtcbiAgICAgICAgLyoqIFByb3ZpZGVzIHRyYWNlIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlICovXG4gICAgICAgIHRoaXMudHJhY2UgPSB0cmFjZV8xLnRyYWNlO1xuICAgICAgICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byB1aS12aWV3IHN5bmNocm9uaXphdGlvbiAqL1xuICAgICAgICB0aGlzLnZpZXdTZXJ2aWNlID0gbmV3IHZpZXdfMS5WaWV3U2VydmljZSgpO1xuICAgICAgICAvKiogR2xvYmFsIHJvdXRlciBzdGF0ZSAqL1xuICAgICAgICB0aGlzLmdsb2JhbHMgPSBuZXcgZ2xvYmFsc18xLlVJUm91dGVyR2xvYmFscygpO1xuICAgICAgICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byBUcmFuc2l0aW9ucyAqL1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25TZXJ2aWNlID0gbmV3IHRyYW5zaXRpb25TZXJ2aWNlXzEuVHJhbnNpdGlvblNlcnZpY2UodGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXByZWNhdGVkIGZvciBwdWJsaWMgdXNlLiBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXJsTWF0Y2hlckZhY3RvcnkgPSBuZXcgdXJsTWF0Y2hlckZhY3RvcnlfMS5VcmxNYXRjaGVyRmFjdG9yeSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVwcmVjYXRlZCBmb3IgcHVibGljIHVzZS4gVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWQuXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW3VybFNlcnZpY2VdXSBpbnN0ZWFkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVybFJvdXRlciA9IG5ldyB1cmxSb3V0ZXJfMS5VcmxSb3V0ZXIodGhpcyk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBhIHJlZ2lzdHJ5IGZvciBzdGF0ZXMsIGFuZCByZWxhdGVkIHJlZ2lzdHJhdGlvbiBzZXJ2aWNlcyAqL1xuICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkgPSBuZXcgc3RhdGVSZWdpc3RyeV8xLlN0YXRlUmVnaXN0cnkodGhpcyk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHN0YXRlcyAqL1xuICAgICAgICB0aGlzLnN0YXRlU2VydmljZSA9IG5ldyBzdGF0ZVNlcnZpY2VfMS5TdGF0ZVNlcnZpY2UodGhpcyk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHRoZSBVUkwgKi9cbiAgICAgICAgdGhpcy51cmxTZXJ2aWNlID0gbmV3IHVybFNlcnZpY2VfMS5VcmxTZXJ2aWNlKHRoaXMpO1xuICAgICAgICAvKiogQGhpZGRlbiBwbHVnaW4gaW5zdGFuY2VzIGFyZSByZWdpc3RlcmVkIGhlcmUgKi9cbiAgICAgICAgdGhpcy5fcGx1Z2lucyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdTZXJ2aWNlLl9wbHVnaW5hcGkuX3Jvb3RWaWV3Q29udGV4dCh0aGlzLnN0YXRlUmVnaXN0cnkucm9vdCgpKTtcbiAgICAgICAgdGhpcy5nbG9iYWxzLiRjdXJyZW50ID0gdGhpcy5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxzLmN1cnJlbnQgPSB0aGlzLmdsb2JhbHMuJGN1cnJlbnQuc2VsZjtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMuZ2xvYmFscyk7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnN0YXRlU2VydmljZSk7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnN0YXRlUmVnaXN0cnkpO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUodGhpcy50cmFuc2l0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnVybFJvdXRlcik7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZShsb2NhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUobG9jYXRpb25Db25maWcpO1xuICAgIH1cbiAgICAvKiogUmVnaXN0ZXJzIGFuIG9iamVjdCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSByb3V0ZXIgaXMgZGlzcG9zZWQgKi9cbiAgICBVSVJvdXRlci5wcm90b3R5cGUuZGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChkaXNwb3NhYmxlKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzLnB1c2goZGlzcG9zYWJsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGlzIHJvdXRlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogV2hlbiBjYWxsZWQsIGNsZWFycyByZXNvdXJjZXMgcmV0YWluZWQgYnkgdGhlIHJvdXRlciBieSBjYWxsaW5nIGBkaXNwb3NlKHRoaXMpYCBvbiBhbGxcbiAgICAgKiByZWdpc3RlcmVkIFtbZGlzcG9zYWJsZV1dIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBPciwgaWYgYSBgZGlzcG9zYWJsZWAgb2JqZWN0IGlzIHByb3ZpZGVkLCBjYWxscyBgZGlzcG9zZSh0aGlzKWAgb24gdGhhdCBvYmplY3Qgb25seS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXNwb3NhYmxlIChvcHRpb25hbCkgdGhlIGRpc3Bvc2FibGUgdG8gZGlzcG9zZVxuICAgICAqL1xuICAgIFVJUm91dGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGRpc3Bvc2FibGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRpc3Bvc2FibGUgJiYgcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oZGlzcG9zYWJsZS5kaXNwb3NlKSkge1xuICAgICAgICAgICAgZGlzcG9zYWJsZS5kaXNwb3NlKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC5kaXNwb3NlID09PSAnZnVuY3Rpb24nICYmIGQuZGlzcG9zZShfdGhpcyk7XG4gICAgICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbShfdGhpcy5fZGlzcG9zYWJsZXMsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHsgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwbHVnaW4gdG8gVUktUm91dGVyXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhZGRzIGEgVUktUm91dGVyIFBsdWdpbi5cbiAgICAgKiBBIHBsdWdpbiBjYW4gZW5oYW5jZSBvciBjaGFuZ2UgVUktUm91dGVyIGJlaGF2aW9yIHVzaW5nIGFueSBwdWJsaWMgQVBJLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IHsgTXlDb29sUGx1Z2luIH0gZnJvbSBcInVpLXJvdXRlci1jb29sLXBsdWdpblwiO1xuICAgICAqXG4gICAgICogdmFyIHBsdWdpbiA9IHJvdXRlci5hZGRQbHVnaW4oTXlDb29sUGx1Z2luKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBQbHVnaW4gYXV0aG9yaW5nXG4gICAgICpcbiAgICAgKiBBIHBsdWdpbiBpcyBzaW1wbHkgYSBjbGFzcyAob3IgY29uc3RydWN0b3IgZnVuY3Rpb24pIHdoaWNoIGFjY2VwdHMgYSBbW1VJUm91dGVyXV0gaW5zdGFuY2UgYW5kIChvcHRpb25hbGx5KSBhbiBvcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRoZSBwbHVnaW4gY2FuIGltcGxlbWVudCBpdHMgZnVuY3Rpb25hbGl0eSB1c2luZyBhbnkgb2YgdGhlIHB1YmxpYyBBUElzIG9mIFtbVUlSb3V0ZXJdXS5cbiAgICAgKiBGb3IgZXhhbXBsZSwgaXQgbWF5IGNvbmZpZ3VyZSByb3V0ZXIgb3B0aW9ucyBvciBhZGQgYSBUcmFuc2l0aW9uIEhvb2suXG4gICAgICpcbiAgICAgKiBUaGUgcGx1Z2luIGNhbiB0aGVuIGJlIHB1Ymxpc2hlZCBhcyBhIHNlcGFyYXRlIG1vZHVsZS5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGV4cG9ydCBjbGFzcyBNeUF1dGhQbHVnaW4gaW1wbGVtZW50cyBVSVJvdXRlclBsdWdpbiB7XG4gICAgICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFVJUm91dGVyLCBvcHRpb25zOiBhbnkpIHtcbiAgICAgKiAgICAgdGhpcy5uYW1lID0gXCJNeUF1dGhQbHVnaW5cIjtcbiAgICAgKiAgICAgbGV0ICR0cmFuc2l0aW9ucyA9IHJvdXRlci50cmFuc2l0aW9uU2VydmljZTtcbiAgICAgKiAgICAgbGV0ICRzdGF0ZSA9IHJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgICpcbiAgICAgKiAgICAgbGV0IGF1dGhDcml0ZXJpYSA9IHtcbiAgICAgKiAgICAgICB0bzogKHN0YXRlKSA9PiBzdGF0ZS5kYXRhICYmIHN0YXRlLmRhdGEucmVxdWlyZXNBdXRoXG4gICAgICogICAgIH07XG4gICAgICpcbiAgICAgKiAgICAgZnVuY3Rpb24gYXV0aEhvb2sodHJhbnNpdGlvbjogVHJhbnNpdGlvbikge1xuICAgICAqICAgICAgIGxldCBhdXRoU2VydmljZSA9IHRyYW5zaXRpb24uaW5qZWN0b3IoKS5nZXQoJ0F1dGhTZXJ2aWNlJyk7XG4gICAgICogICAgICAgaWYgKCFhdXRoU2VydmljZS5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAqICAgICAgICAgcmV0dXJuICRzdGF0ZS50YXJnZXQoJ2xvZ2luJyk7XG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiAgICAgJHRyYW5zaXRpb25zLm9uU3RhcnQoYXV0aENyaXRlcmlhLCBhdXRoSG9vayk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHBsdWdpbiBvbmUgb2Y6XG4gICAgICogICAgICAgIC0gYSBwbHVnaW4gY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBbW1VJUm91dGVyUGx1Z2luXV1cbiAgICAgKiAgICAgICAgLSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBhIFtbVUlSb3V0ZXJQbHVnaW5dXSB3aGljaCBhY2NlcHRzIGEgW1tVSVJvdXRlcl1dIGluc3RhbmNlXG4gICAgICogICAgICAgIC0gYSBmYWN0b3J5IGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgYSBbW1VJUm91dGVyXV0gaW5zdGFuY2UgYW5kIHJldHVybnMgYSBbW1VJUm91dGVyUGx1Z2luXV0gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHBsdWdpbiBjbGFzcy9mYWN0b3J5XG4gICAgICogQHJldHVybnMgdGhlIHJlZ2lzdGVyZWQgcGx1Z2luIGluc3RhbmNlXG4gICAgICovXG4gICAgVUlSb3V0ZXIucHJvdG90eXBlLnBsdWdpbiA9IGZ1bmN0aW9uIChwbHVnaW4sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHBsdWdpbkluc3RhbmNlID0gbmV3IHBsdWdpbih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFwbHVnaW5JbnN0YW5jZS5uYW1lKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBwcm9wZXJ0eSBgbmFtZWAgbWlzc2luZyBvbiBwbHVnaW46ICcgKyBwbHVnaW5JbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzLnB1c2gocGx1Z2luSW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX3BsdWdpbnNbcGx1Z2luSW5zdGFuY2UubmFtZV0gPSBwbHVnaW5JbnN0YW5jZSk7XG4gICAgfTtcbiAgICBVSVJvdXRlci5wcm90b3R5cGUuZ2V0UGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbk5hbWUgPyB0aGlzLl9wbHVnaW5zW3BsdWdpbk5hbWVdIDogY29tbW9uXzEudmFsdWVzKHRoaXMuX3BsdWdpbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFVJUm91dGVyO1xufSgpKTtcbmV4cG9ydHMuVUlSb3V0ZXIgPSBVSVJvdXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZUJ1aWxkZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVPYmplY3RcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVNYXRjaGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlUXVldWVNYW5hZ2VyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlUmVnaXN0cnlcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVTZXJ2aWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RhcmdldFN0YXRlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcmVzb2x2YWJsZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2YWJsZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHBhcnNlVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKHVybCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcm9vdCA9IHVybC5jaGFyQXQoMCkgPT09ICdeJztcbiAgICByZXR1cm4geyB2YWw6IHJvb3QgPyB1cmwuc3Vic3RyaW5nKDEpIDogdXJsLCByb290OiByb290IH07XG59O1xuZnVuY3Rpb24gbmFtZUJ1aWxkZXIoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubmFtZTtcbn1cbmZ1bmN0aW9uIHNlbGZCdWlsZGVyKHN0YXRlKSB7XG4gICAgc3RhdGUuc2VsZi4kJHN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGU7IH07XG4gICAgcmV0dXJuIHN0YXRlLnNlbGY7XG59XG5mdW5jdGlvbiBkYXRhQnVpbGRlcihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5wYXJlbnQgJiYgc3RhdGUucGFyZW50LmRhdGEpIHtcbiAgICAgICAgc3RhdGUuZGF0YSA9IHN0YXRlLnNlbGYuZGF0YSA9IGNvbW1vbl8xLmluaGVyaXQoc3RhdGUucGFyZW50LmRhdGEsIHN0YXRlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuZGF0YTtcbn1cbnZhciBnZXRVcmxCdWlsZGVyID0gZnVuY3Rpb24gKCR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLCByb290KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVybEJ1aWxkZXIoc3RhdGUpIHtcbiAgICAgICAgdmFyIHN0YXRlRGVjID0gc3RhdGU7XG4gICAgICAgIC8vIEZvciBmdXR1cmUgc3RhdGVzLCBpLmUuLCBzdGF0ZXMgd2hvc2UgbmFtZSBlbmRzIHdpdGggYC4qKmAsXG4gICAgICAgIC8vIG1hdGNoIGFueXRoaW5nIHRoYXQgc3RhcnRzIHdpdGggdGhlIHVybCBwcmVmaXhcbiAgICAgICAgaWYgKHN0YXRlRGVjICYmIHN0YXRlRGVjLnVybCAmJiBzdGF0ZURlYy5uYW1lICYmIHN0YXRlRGVjLm5hbWUubWF0Y2goL1xcLlxcKlxcKiQvKSkge1xuICAgICAgICAgICAgc3RhdGVEZWMudXJsICs9ICd7cmVtYWluZGVyOmFueX0nOyAvLyBtYXRjaCBhbnkgcGF0aCAoLiopXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlVXJsKHN0YXRlRGVjLnVybCksIHBhcmVudCA9IHN0YXRlLnBhcmVudDtcbiAgICAgICAgdmFyIHVybCA9ICFwYXJzZWRcbiAgICAgICAgICAgID8gc3RhdGVEZWMudXJsXG4gICAgICAgICAgICA6ICR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLmNvbXBpbGUocGFyc2VkLnZhbCwge1xuICAgICAgICAgICAgICAgIHBhcmFtczogc3RhdGUucGFyYW1zIHx8IHt9LFxuICAgICAgICAgICAgICAgIHBhcmFtTWFwOiBmdW5jdGlvbiAocGFyYW1Db25maWcsIGlzU2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZURlYy5yZWxvYWRPblNlYXJjaCA9PT0gZmFsc2UgJiYgaXNTZWFyY2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbUNvbmZpZyA9IGNvbW1vbl8xLmV4dGVuZChwYXJhbUNvbmZpZyB8fCB7fSwgeyBkeW5hbWljOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1Db25maWc7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXVybClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoISR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLmlzTWF0Y2hlcih1cmwpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB1cmwgJ1wiICsgdXJsICsgXCInIGluIHN0YXRlICdcIiArIHN0YXRlICsgXCInXCIpO1xuICAgICAgICByZXR1cm4gcGFyc2VkICYmIHBhcnNlZC5yb290ID8gdXJsIDogKChwYXJlbnQgJiYgcGFyZW50Lm5hdmlnYWJsZSkgfHwgcm9vdCgpKS51cmwuYXBwZW5kKHVybCk7XG4gICAgfTtcbn07XG52YXIgZ2V0TmF2aWdhYmxlQnVpbGRlciA9IGZ1bmN0aW9uIChpc1Jvb3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmF2aWdhYmxlQnVpbGRlcihzdGF0ZSkge1xuICAgICAgICByZXR1cm4gIWlzUm9vdChzdGF0ZSkgJiYgc3RhdGUudXJsID8gc3RhdGUgOiBzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQubmF2aWdhYmxlIDogbnVsbDtcbiAgICB9O1xufTtcbnZhciBnZXRQYXJhbXNCdWlsZGVyID0gZnVuY3Rpb24gKHBhcmFtRmFjdG9yeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBwYXJhbXNCdWlsZGVyKHN0YXRlKSB7XG4gICAgICAgIHZhciBtYWtlQ29uZmlnUGFyYW0gPSBmdW5jdGlvbiAoY29uZmlnLCBpZCkgeyByZXR1cm4gcGFyYW1GYWN0b3J5LmZyb21Db25maWcoaWQsIG51bGwsIGNvbmZpZyk7IH07XG4gICAgICAgIHZhciB1cmxQYXJhbXMgPSAoc3RhdGUudXJsICYmIHN0YXRlLnVybC5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogZmFsc2UgfSkpIHx8IFtdO1xuICAgICAgICB2YXIgbm9uVXJsUGFyYW1zID0gY29tbW9uXzEudmFsdWVzKGNvbW1vbl8xLm1hcE9iaihjb21tb25fMS5vbWl0KHN0YXRlLnBhcmFtcyB8fCB7fSwgdXJsUGFyYW1zLm1hcChob2ZfMS5wcm9wKCdpZCcpKSksIG1ha2VDb25maWdQYXJhbSkpO1xuICAgICAgICByZXR1cm4gdXJsUGFyYW1zXG4gICAgICAgICAgICAuY29uY2F0KG5vblVybFBhcmFtcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIFtwLmlkLCBwXTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEuYXBwbHlQYWlycywge30pO1xuICAgIH07XG59O1xuZnVuY3Rpb24gcGF0aEJ1aWxkZXIoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUucGFyZW50ID8gc3RhdGUucGFyZW50LnBhdGguY29uY2F0KHN0YXRlKSA6IC8qcm9vdCovIFtzdGF0ZV07XG59XG5mdW5jdGlvbiBpbmNsdWRlc0J1aWxkZXIoc3RhdGUpIHtcbiAgICB2YXIgaW5jbHVkZXMgPSBzdGF0ZS5wYXJlbnQgPyBjb21tb25fMS5leHRlbmQoe30sIHN0YXRlLnBhcmVudC5pbmNsdWRlcykgOiB7fTtcbiAgICBpbmNsdWRlc1tzdGF0ZS5uYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIGluY2x1ZGVzO1xufVxuLyoqXG4gKiBUaGlzIGlzIGEgW1tTdGF0ZUJ1aWxkZXIuYnVpbGRlcl1dIGZ1bmN0aW9uIGZvciB0aGUgYHJlc29sdmU6YCBibG9jayBvbiBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dLlxuICpcbiAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcbiAqIHZhbGlkYXRlcyB0aGUgYHJlc29sdmVgIHByb3BlcnR5IGFuZCBjb252ZXJ0cyBpdCB0byBhIFtbUmVzb2x2YWJsZV1dIGFycmF5LlxuICpcbiAqIHJlc29sdmU6IGlucHV0IHZhbHVlIGNhbiBiZTpcbiAqXG4gKiB7XG4gKiAgIC8vIGFuYWx5emVkIGJ1dCBub3QgaW5qZWN0ZWRcbiAqICAgbXlGb29SZXNvbHZlOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwibXlGb29EYXRhXCI7IH0sXG4gKlxuICogICAvLyBmdW5jdGlvbi50b1N0cmluZygpIHBhcnNlZCwgXCJEZXBlbmRlbmN5TmFtZVwiIGRlcCBhcyBzdHJpbmcgKG5vdCBtaW4tc2FmZSlcbiAqICAgbXlCYXJSZXNvbHZlOiBmdW5jdGlvbihEZXBlbmRlbmN5TmFtZSkgeyByZXR1cm4gRGVwZW5kZW5jeU5hbWUuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LFxuICpcbiAqICAgLy8gQXJyYXkgc3BsaXQ7IFwiRGVwZW5kZW5jeU5hbWVcIiBkZXAgYXMgc3RyaW5nXG4gKiAgIG15QmF6UmVzb2x2ZTogWyBcIkRlcGVuZGVuY3lOYW1lXCIsIGZ1bmN0aW9uKGRlcCkgeyByZXR1cm4gZGVwLmZldGNoU29tZXRoaW5nQXNQcm9taXNlKCkgfSxcbiAqXG4gKiAgIC8vIEFycmF5IHNwbGl0OyBEZXBlbmRlbmN5VHlwZSBkZXAgYXMgdG9rZW4gKGNvbXBhcmVkIHVzaW5nID09PSlcbiAqICAgbXlRdXhSZXNvbHZlOiBbIERlcGVuZGVuY3lUeXBlLCBmdW5jdGlvbihkZXApIHsgcmV0dXJuIGRlcC5mZXRjaFNvbWV0aW5nQXNQcm9taXNlKCkgfSxcbiAqXG4gKiAgIC8vIHZhbC4kaW5qZWN0IHVzZWQgYXMgZGVwc1xuICogICAvLyB3aGVyZTpcbiAqICAgLy8gICAgIGNvcmdlUmVzb2x2ZS4kaW5qZWN0ID0gW1wiRGVwZW5kZW5jeU5hbWVcIl07XG4gKiAgIC8vICAgICBmdW5jdGlvbiBjb3JnZVJlc29sdmUoZGVwKSB7IGRlcC5mZXRjaFNvbWV0aW5nQXNQcm9taXNlKCkgfVxuICogICAvLyB0aGVuIFwiRGVwZW5kZW5jeU5hbWVcIiBkZXAgYXMgc3RyaW5nXG4gKiAgIG15Q29yZ2VSZXNvbHZlOiBjb3JnZVJlc29sdmUsXG4gKlxuICogIC8vIGluamVjdCBzZXJ2aWNlIGJ5IG5hbWVcbiAqICAvLyBXaGVuIGEgc3RyaW5nIGlzIGZvdW5kLCBkZXN1Z2FyIGNyZWF0aW5nIGEgcmVzb2x2ZSB0aGF0IGluamVjdHMgdGhlIG5hbWVkIHNlcnZpY2VcbiAqICAgbXlHcmF1bHRSZXNvbHZlOiBcIlNvbWVTZXJ2aWNlXCJcbiAqIH1cbiAqXG4gKiBvcjpcbiAqXG4gKiBbXG4gKiAgIG5ldyBSZXNvbHZhYmxlKFwibXlGb29SZXNvbHZlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJteUZvb0RhdGFcIiB9KSxcbiAqICAgbmV3IFJlc29sdmFibGUoXCJteUJhclJlc29sdmVcIiwgZnVuY3Rpb24oZGVwKSB7IHJldHVybiBkZXAuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LCBbIFwiRGVwZW5kZW5jeU5hbWVcIiBdKSxcbiAqICAgeyBwcm92aWRlOiBcIm15QmF6UmVzb2x2ZVwiLCB1c2VGYWN0b3J5OiBmdW5jdGlvbihkZXApIHsgZGVwLmZldGNoU29tZXRoaW5nQXNQcm9taXNlKCkgfSwgZGVwczogWyBcIkRlcGVuZGVuY3lOYW1lXCIgXSB9XG4gKiBdXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmFibGVzQnVpbGRlcihzdGF0ZSkge1xuICAgIC8qKiBjb252ZXJ0IHJlc29sdmU6IHt9IGFuZCByZXNvbHZlUG9saWN5OiB7fSBvYmplY3RzIHRvIGFuIGFycmF5IG9mIHR1cGxlcyAqL1xuICAgIHZhciBvYmplY3RzMlR1cGxlcyA9IGZ1bmN0aW9uIChyZXNvbHZlT2JqLCByZXNvbHZlUG9saWNpZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc29sdmVPYmogfHwge30pLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuICh7XG4gICAgICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgICAgICB2YWw6IHJlc29sdmVPYmpbdG9rZW5dLFxuICAgICAgICAgICAgZGVwczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcG9saWN5OiByZXNvbHZlUG9saWNpZXNbdG9rZW5dLFxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKiogZmV0Y2ggREkgYW5ub3RhdGlvbnMgZnJvbSBhIGZ1bmN0aW9uIG9yIG5nMS1zdHlsZSBhcnJheSAqL1xuICAgIHZhciBhbm5vdGF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgJGluamVjdG9yID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yO1xuICAgICAgICAvLyBuZzEgZG9lc24ndCBoYXZlIGFuICRpbmplY3RvciB1bnRpbCBydW50aW1lLlxuICAgICAgICAvLyBJZiB0aGUgJGluamVjdG9yIGRvZXNuJ3QgZXhpc3QsIHVzZSBcImRlZmVycmVkXCIgbGl0ZXJhbCBhcyBhXG4gICAgICAgIC8vIG1hcmtlciBpbmRpY2F0aW5nIHRoZXkgc2hvdWxkIGJlIGFubm90YXRlZCB3aGVuIHJ1bnRpbWUgc3RhcnRzXG4gICAgICAgIHJldHVybiBmblsnJGluamVjdCddIHx8ICgkaW5qZWN0b3IgJiYgJGluamVjdG9yLmFubm90YXRlKGZuLCAkaW5qZWN0b3Iuc3RyaWN0RGkpKSB8fCAnZGVmZXJyZWQnO1xuICAgIH07XG4gICAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgYm90aCBgdG9rZW5gIGFuZCBgcmVzb2x2ZUZuYCwgYW5kIGlzIHByb2JhYmx5IGEgW1tSZXNvbHZlTGl0ZXJhbF1dICovXG4gICAgdmFyIGlzUmVzb2x2ZUxpdGVyYWwgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiAhIShvYmoudG9rZW4gJiYgb2JqLnJlc29sdmVGbik7IH07XG4gICAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGEgcHJvdmlkZSBsaXRlcmFsLCBvciBhIG5nMiBQcm92aWRlciAqL1xuICAgIHZhciBpc0xpa2VOZzJQcm92aWRlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuICEhKChvYmoucHJvdmlkZSB8fCBvYmoudG9rZW4pICYmIChvYmoudXNlVmFsdWUgfHwgb2JqLnVzZUZhY3RvcnkgfHwgb2JqLnVzZUV4aXN0aW5nIHx8IG9iai51c2VDbGFzcykpO1xuICAgIH07XG4gICAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGEgdHVwbGUgZnJvbSBvYmoyVHVwbGVzICovXG4gICAgdmFyIGlzVHVwbGVGcm9tT2JqID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai52YWwgJiYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhvYmoudmFsKSB8fCBwcmVkaWNhdGVzXzEuaXNBcnJheShvYmoudmFsKSB8fCBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihvYmoudmFsKSkpO1xuICAgIH07XG4gICAgLyoqIGV4dHJhY3RzIHRoZSB0b2tlbiBmcm9tIGEgUHJvdmlkZXIgb3IgcHJvdmlkZSBsaXRlcmFsICovXG4gICAgdmFyIGdldFRva2VuID0gZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAucHJvdmlkZSB8fCBwLnRva2VuOyB9O1xuICAgIC8qKiBHaXZlbiBhIGxpdGVyYWwgcmVzb2x2ZSBvciBwcm92aWRlciBvYmplY3QsIHJldHVybnMgYSBSZXNvbHZhYmxlICovXG4gICAgdmFyIGxpdGVyYWwyUmVzb2x2YWJsZSA9IGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICBbaG9mXzEucHJvcCgncmVzb2x2ZUZuJyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUoZ2V0VG9rZW4ocCksIHAucmVzb2x2ZUZuLCBwLmRlcHMsIHAucG9saWN5KTsgfV0sXG4gICAgICAgIFtob2ZfMS5wcm9wKCd1c2VGYWN0b3J5JyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUoZ2V0VG9rZW4ocCksIHAudXNlRmFjdG9yeSwgcC5kZXBzIHx8IHAuZGVwZW5kZW5jaWVzLCBwLnBvbGljeSk7IH1dLFxuICAgICAgICBbaG9mXzEucHJvcCgndXNlQ2xhc3MnKSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZShnZXRUb2tlbihwKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IHAudXNlQ2xhc3MoKTsgfSwgW10sIHAucG9saWN5KTsgfV0sXG4gICAgICAgIFtob2ZfMS5wcm9wKCd1c2VWYWx1ZScpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKGdldFRva2VuKHApLCBmdW5jdGlvbiAoKSB7IHJldHVybiBwLnVzZVZhbHVlOyB9LCBbXSwgcC5wb2xpY3ksIHAudXNlVmFsdWUpOyB9XSxcbiAgICAgICAgW2hvZl8xLnByb3AoJ3VzZUV4aXN0aW5nJyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUoZ2V0VG9rZW4ocCksIGNvbW1vbl8xLmlkZW50aXR5LCBbcC51c2VFeGlzdGluZ10sIHAucG9saWN5KTsgfV0sXG4gICAgXSk7XG4gICAgdmFyIHR1cGxlMlJlc29sdmFibGUgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgW2hvZl8xLnBpcGUoaG9mXzEucHJvcCgndmFsJyksIHByZWRpY2F0ZXNfMS5pc1N0cmluZyksIGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHR1cGxlLnRva2VuLCBjb21tb25fMS5pZGVudGl0eSwgW3R1cGxlLnZhbF0sIHR1cGxlLnBvbGljeSk7IH1dLFxuICAgICAgICBbXG4gICAgICAgICAgICBob2ZfMS5waXBlKGhvZl8xLnByb3AoJ3ZhbCcpLCBwcmVkaWNhdGVzXzEuaXNBcnJheSksXG4gICAgICAgICAgICBmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0dXBsZS50b2tlbiwgY29tbW9uXzEudGFpbCh0dXBsZS52YWwpLCB0dXBsZS52YWwuc2xpY2UoMCwgLTEpLCB0dXBsZS5wb2xpY3kpOyB9LFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBob2ZfMS5waXBlKGhvZl8xLnByb3AoJ3ZhbCcpLCBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbiksXG4gICAgICAgICAgICBmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0dXBsZS50b2tlbiwgdHVwbGUudmFsLCBhbm5vdGF0ZSh0dXBsZS52YWwpLCB0dXBsZS5wb2xpY3kpOyB9LFxuICAgICAgICBdLFxuICAgIF0pO1xuICAgIHZhciBpdGVtMlJlc29sdmFibGUgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgW2hvZl8xLmlzKHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKSwgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHI7IH1dLFxuICAgICAgICBbaXNSZXNvbHZlTGl0ZXJhbCwgbGl0ZXJhbDJSZXNvbHZhYmxlXSxcbiAgICAgICAgW2lzTGlrZU5nMlByb3ZpZGVyLCBsaXRlcmFsMlJlc29sdmFibGVdLFxuICAgICAgICBbaXNUdXBsZUZyb21PYmosIHR1cGxlMlJlc29sdmFibGVdLFxuICAgICAgICBbXG4gICAgICAgICAgICBob2ZfMS52YWwodHJ1ZSksXG4gICAgICAgICAgICBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc29sdmUgdmFsdWU6ICcgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KG9iaikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICBdKTtcbiAgICAvLyBJZiByZXNvbHZlQmxvY2sgaXMgYWxyZWFkeSBhbiBhcnJheSwgdXNlIGl0IGFzLWlzLlxuICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIGl0J3MgYW4gb2JqZWN0IGFuZCBjb252ZXJ0IHRvIGFuIEFycmF5IG9mIHR1cGxlc1xuICAgIHZhciBkZWNsID0gc3RhdGUucmVzb2x2ZTtcbiAgICB2YXIgaXRlbXMgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShkZWNsKSA/IGRlY2wgOiBvYmplY3RzMlR1cGxlcyhkZWNsLCBzdGF0ZS5yZXNvbHZlUG9saWN5IHx8IHt9KTtcbiAgICByZXR1cm4gaXRlbXMubWFwKGl0ZW0yUmVzb2x2YWJsZSk7XG59XG5leHBvcnRzLnJlc29sdmFibGVzQnVpbGRlciA9IHJlc29sdmFibGVzQnVpbGRlcjtcbi8qKlxuICogQGludGVybmFsYXBpIEEgaW50ZXJuYWwgZ2xvYmFsIHNlcnZpY2VcbiAqXG4gKiBTdGF0ZUJ1aWxkZXIgaXMgYSBmYWN0b3J5IGZvciB0aGUgaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdHMuXG4gKlxuICogV2hlbiB5b3UgcmVnaXN0ZXIgYSBzdGF0ZSB3aXRoIHRoZSBbW1N0YXRlUmVnaXN0cnldXSwgeW91IHJlZ2lzdGVyIGEgcGxhaW4gb2xkIGphdmFzY3JpcHQgb2JqZWN0IHdoaWNoXG4gKiBjb25mb3JtcyB0byB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uXV0gaW50ZXJmYWNlLiAgVGhpcyBmYWN0b3J5IHRha2VzIHRoYXQgb2JqZWN0IGFuZCBidWlsZHMgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIFtbU3RhdGVPYmplY3RdXSBvYmplY3QsIHdoaWNoIGhhcyBhbiBBUEkgYW5kIGlzIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiBDdXN0b20gcHJvcGVydGllcyBvciBBUEkgbWF5IGJlIGFkZGVkIHRvIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGJ5IHJlZ2lzdGVyaW5nIGEgZGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiB1c2luZyB0aGUgW1tidWlsZGVyXV0gbWV0aG9kLlxuICovXG52YXIgU3RhdGVCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlQnVpbGRlcihtYXRjaGVyLCB1cmxNYXRjaGVyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLm1hdGNoZXIgPSBtYXRjaGVyO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciByb290ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0Y2hlci5maW5kKCcnKTsgfTtcbiAgICAgICAgdmFyIGlzUm9vdCA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUubmFtZSA9PT0gJyc7IH07XG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudEJ1aWxkZXIoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChpc1Jvb3Qoc3RhdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuZmluZChzZWxmLnBhcmVudE5hbWUoc3RhdGUpKSB8fCByb290KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsZGVycyA9IHtcbiAgICAgICAgICAgIG5hbWU6IFtuYW1lQnVpbGRlcl0sXG4gICAgICAgICAgICBzZWxmOiBbc2VsZkJ1aWxkZXJdLFxuICAgICAgICAgICAgcGFyZW50OiBbcGFyZW50QnVpbGRlcl0sXG4gICAgICAgICAgICBkYXRhOiBbZGF0YUJ1aWxkZXJdLFxuICAgICAgICAgICAgLy8gQnVpbGQgYSBVUkxNYXRjaGVyIGlmIG5lY2Vzc2FyeSwgZWl0aGVyIHZpYSBhIHJlbGF0aXZlIG9yIGFic29sdXRlIFVSTFxuICAgICAgICAgICAgdXJsOiBbZ2V0VXJsQnVpbGRlcih1cmxNYXRjaGVyRmFjdG9yeSwgcm9vdCldLFxuICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY2xvc2VzdCBhbmNlc3RvciBzdGF0ZSB0aGF0IGhhcyBhIFVSTCAoaS5lLiBpcyBuYXZpZ2FibGUpXG4gICAgICAgICAgICBuYXZpZ2FibGU6IFtnZXROYXZpZ2FibGVCdWlsZGVyKGlzUm9vdCldLFxuICAgICAgICAgICAgcGFyYW1zOiBbZ2V0UGFyYW1zQnVpbGRlcih1cmxNYXRjaGVyRmFjdG9yeS5wYXJhbUZhY3RvcnkpXSxcbiAgICAgICAgICAgIC8vIEVhY2ggZnJhbWV3b3JrLXNwZWNpZmljIHVpLXJvdXRlciBpbXBsZW1lbnRhdGlvbiBzaG91bGQgZGVmaW5lIGl0cyBvd24gYHZpZXdzYCBidWlsZGVyXG4gICAgICAgICAgICAvLyBlLmcuLCBzcmMvbmcxL3N0YXRlYnVpbGRlcnMvdmlld3MudHNcbiAgICAgICAgICAgIHZpZXdzOiBbXSxcbiAgICAgICAgICAgIC8vIEtlZXAgYSBmdWxsIHBhdGggZnJvbSB0aGUgcm9vdCBkb3duIHRvIHRoaXMgc3RhdGUgYXMgdGhpcyBpcyBuZWVkZWQgZm9yIHN0YXRlIGFjdGl2YXRpb24uXG4gICAgICAgICAgICBwYXRoOiBbcGF0aEJ1aWxkZXJdLFxuICAgICAgICAgICAgLy8gU3BlZWQgdXAgJHN0YXRlLmluY2x1ZGVzKCkgYXMgaXQncyB1c2VkIGEgbG90XG4gICAgICAgICAgICBpbmNsdWRlczogW2luY2x1ZGVzQnVpbGRlcl0sXG4gICAgICAgICAgICByZXNvbHZhYmxlczogW3Jlc29sdmFibGVzQnVpbGRlcl0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIFtbQnVpbGRlckZ1bmN0aW9uXV0gZm9yIGEgc3BlY2lmaWMgW1tTdGF0ZU9iamVjdF1dIHByb3BlcnR5IChlLmcuLCBgcGFyZW50YCwgYHVybGAsIG9yIGBwYXRoYCkuXG4gICAgICogTW9yZSB0aGFuIG9uZSBCdWlsZGVyRnVuY3Rpb24gY2FuIGJlIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGUgQnVpbGRlckZ1bmN0aW9uKHMpIHdpbGwgYmUgdXNlZCB0byBkZWZpbmUgdGhlIHByb3BlcnR5IG9uIGFueSBzdWJzZXF1ZW50bHkgYnVpbHQgW1tTdGF0ZU9iamVjdF1dIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgU3RhdGUgcHJvcGVydHkgYmVpbmcgcmVnaXN0ZXJlZCBmb3IuXG4gICAgICogQHBhcmFtIGZuIFRoZSBCdWlsZGVyRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIHRoZSBTdGF0ZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIEJ1aWxkZXJGdW5jdGlvblxuICAgICAqL1xuICAgIFN0YXRlQnVpbGRlci5wcm90b3R5cGUuYnVpbGRlciA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgICAgICB2YXIgYnVpbGRlcnMgPSB0aGlzLmJ1aWxkZXJzO1xuICAgICAgICB2YXIgYXJyYXkgPSBidWlsZGVyc1tuYW1lXSB8fCBbXTtcbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdDogaWYgb25seSBvbmUgYnVpbGRlciBleGlzdHMsIHJldHVybiBpdCwgZWxzZSByZXR1cm4gd2hvbGUgYXJhcnkuXG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcobmFtZSkgJiYgIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoZm4pKVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDEgPyBhcnJheSA6IGFycmF5WzBdO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc1N0cmluZyhuYW1lKSB8fCAhcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oZm4pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBidWlsZGVyc1tuYW1lXSA9IGFycmF5O1xuICAgICAgICBidWlsZGVyc1tuYW1lXS5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ1aWxkZXJzW25hbWVdLnNwbGljZShidWlsZGVyc1tuYW1lXS5pbmRleE9mKGZuLCAxKSkgJiYgbnVsbDsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbGwgb2YgdGhlIHByb3BlcnRpZXMgb24gYW4gZXNzZW50aWFsbHkgYmxhbmsgU3RhdGUgb2JqZWN0LCByZXR1cm5pbmcgYSBTdGF0ZSBvYmplY3Qgd2hpY2ggaGFzIGFsbCBpdHNcbiAgICAgKiBwcm9wZXJ0aWVzIGFuZCBBUEkgYnVpbHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGUgYW4gdW5pbml0aWFsaXplZCBTdGF0ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB0aGUgYnVpbHQgU3RhdGUgb2JqZWN0XG4gICAgICovXG4gICAgU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBtYXRjaGVyID0gX2EubWF0Y2hlciwgYnVpbGRlcnMgPSBfYS5idWlsZGVycztcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50TmFtZShzdGF0ZSk7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgIW1hdGNoZXIuZmluZChwYXJlbnQsIHVuZGVmaW5lZCwgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYnVpbGRlcnMpIHtcbiAgICAgICAgICAgIGlmICghYnVpbGRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBjaGFpbiA9IGJ1aWxkZXJzW2tleV0ucmVkdWNlKGZ1bmN0aW9uIChwYXJlbnRGbiwgc3RlcCkgeyByZXR1cm4gZnVuY3Rpb24gKF9zdGF0ZSkgeyByZXR1cm4gc3RlcChfc3RhdGUsIHBhcmVudEZuKTsgfTsgfSwgY29tbW9uXzEubm9vcCk7XG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gY2hhaW4oc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuICAgIFN0YXRlQnVpbGRlci5wcm90b3R5cGUucGFyZW50TmFtZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAvLyBuYW1lID0gJ2Zvby5iYXIuYmF6LioqJ1xuICAgICAgICB2YXIgbmFtZSA9IHN0YXRlLm5hbWUgfHwgJyc7XG4gICAgICAgIC8vIHNlZ21lbnRzID0gWydmb28nLCAnYmFyJywgJ2JheicsICcuKionXVxuICAgICAgICB2YXIgc2VnbWVudHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIC8vIHNlZ21lbnRzID0gWydmb28nLCAnYmFyJywgJ2JheiddXG4gICAgICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAvLyBzZWdtZW50cyA9IFsnZm9vJywgJ2JhciddIChpZ25vcmUgLioqIHNlZ21lbnQgZm9yIGZ1dHVyZSBzdGF0ZXMpXG4gICAgICAgIGlmIChsYXN0U2VnbWVudCA9PT0gJyoqJylcbiAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGVzIHRoYXQgc3BlY2lmeSB0aGUgJ3BhcmVudDonIHByb3BlcnR5IHNob3VsZCBub3QgaGF2ZSBhICcuJyBpbiB0aGVpciBuYW1lIChcIiArIG5hbWUgKyBcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAnZm9vLmJhcidcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50cy5qb2luKCcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0ZS5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGUucGFyZW50KSA/IHN0YXRlLnBhcmVudCA6IHN0YXRlLnBhcmVudC5uYW1lO1xuICAgIH07XG4gICAgU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBuYW1lID0gc3RhdGUubmFtZTtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpICE9PSAtMSB8fCAhc3RhdGUucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIHZhciBwYXJlbnROYW1lID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKHN0YXRlLnBhcmVudCkgPyBzdGF0ZS5wYXJlbnQgOiBzdGF0ZS5wYXJlbnQubmFtZTtcbiAgICAgICAgcmV0dXJuIHBhcmVudE5hbWUgPyBwYXJlbnROYW1lICsgJy4nICsgbmFtZSA6IG5hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVCdWlsZGVyO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVCdWlsZGVyID0gU3RhdGVCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVCdWlsZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgU3RhdGVNYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlTWF0Y2hlcihfc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IF9zdGF0ZXM7XG4gICAgfVxuICAgIFN0YXRlTWF0Y2hlci5wcm90b3R5cGUuaXNSZWxhdGl2ZSA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUpIHtcbiAgICAgICAgc3RhdGVOYW1lID0gc3RhdGVOYW1lIHx8ICcnO1xuICAgICAgICByZXR1cm4gc3RhdGVOYW1lLmluZGV4T2YoJy4nKSA9PT0gMCB8fCBzdGF0ZU5hbWUuaW5kZXhPZignXicpID09PSAwO1xuICAgIH07XG4gICAgU3RhdGVNYXRjaGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBiYXNlLCBtYXRjaEdsb2IpIHtcbiAgICAgICAgaWYgKG1hdGNoR2xvYiA9PT0gdm9pZCAwKSB7IG1hdGNoR2xvYiA9IHRydWU7IH1cbiAgICAgICAgaWYgKCFzdGF0ZU9yTmFtZSAmJiBzdGF0ZU9yTmFtZSAhPT0gJycpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgaXNTdHIgPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGVPck5hbWUpO1xuICAgICAgICB2YXIgbmFtZSA9IGlzU3RyID8gc3RhdGVPck5hbWUgOiBzdGF0ZU9yTmFtZS5uYW1lO1xuICAgICAgICBpZiAodGhpcy5pc1JlbGF0aXZlKG5hbWUpKVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucmVzb2x2ZVBhdGgobmFtZSwgYmFzZSk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHN0YXRlICYmIChpc1N0ciB8fCAoIWlzU3RyICYmIChzdGF0ZSA9PT0gc3RhdGVPck5hbWUgfHwgc3RhdGUuc2VsZiA9PT0gc3RhdGVPck5hbWUpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0ciAmJiBtYXRjaEdsb2IpIHtcbiAgICAgICAgICAgIHZhciBfc3RhdGVzID0gY29tbW9uXzEudmFsdWVzKHRoaXMuX3N0YXRlcyk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IF9zdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChfc3RhdGUpIHsgcmV0dXJuIF9zdGF0ZS5fX3N0YXRlT2JqZWN0Q2FjaGUubmFtZUdsb2IgJiYgX3N0YXRlLl9fc3RhdGVPYmplY3RDYWNoZS5uYW1lR2xvYi5tYXRjaGVzKG5hbWUpOyB9KTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhdGVNYXRjaGVyLmZpbmQ6IEZvdW5kIG11bHRpcGxlIG1hdGNoZXMgZm9yIFwiICsgbmFtZSArIFwiIHVzaW5nIGdsb2I6IFwiLCBtYXRjaGVzLm1hcChmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIG1hdGNoLm5hbWU7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBTdGF0ZU1hdGNoZXIucHJvdG90eXBlLnJlc29sdmVQYXRoID0gZnVuY3Rpb24gKG5hbWUsIGJhc2UpIHtcbiAgICAgICAgaWYgKCFiYXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVmZXJlbmNlIHBvaW50IGdpdmVuIGZvciBwYXRoICdcIiArIG5hbWUgKyBcIidcIik7XG4gICAgICAgIHZhciBiYXNlU3RhdGUgPSB0aGlzLmZpbmQoYmFzZSk7XG4gICAgICAgIHZhciBzcGxpdE5hbWUgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBwYXRoTGVuZ3RoID0gc3BsaXROYW1lLmxlbmd0aDtcbiAgICAgICAgdmFyIGkgPSAwLCBjdXJyZW50ID0gYmFzZVN0YXRlO1xuICAgICAgICBmb3IgKDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNwbGl0TmFtZVtpXSA9PT0gJycgJiYgaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBiYXNlU3RhdGU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BsaXROYW1lW2ldID09PSAnXicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnQucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoICdcIiArIG5hbWUgKyBcIicgbm90IHZhbGlkIGZvciBzdGF0ZSAnXCIgKyBiYXNlU3RhdGUubmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVsTmFtZSA9IHNwbGl0TmFtZS5zbGljZShpKS5qb2luKCcuJyk7XG4gICAgICAgIHJldHVybiBjdXJyZW50Lm5hbWUgKyAoY3VycmVudC5uYW1lICYmIHJlbE5hbWUgPyAnLicgOiAnJykgKyByZWxOYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlTWF0Y2hlcjtcbn0oKSk7XG5leHBvcnRzLlN0YXRlTWF0Y2hlciA9IFN0YXRlTWF0Y2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlTWF0Y2hlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgZ2xvYl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9nbG9iXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBVSS1Sb3V0ZXIgc3RhdGUuXG4gKlxuICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGNyZWF0ZWQgd2hlbiBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dIGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgW1tTdGF0ZVJlZ2lzdHJ5XV0uXG4gKlxuICogQSByZWdpc3RlcmVkIFtbU3RhdGVEZWNsYXJhdGlvbl1dIGlzIGF1Z21lbnRlZCB3aXRoIGEgZ2V0dGVyIChbW1N0YXRlRGVjbGFyYXRpb24uJCRzdGF0ZV1dKSB3aGljaCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIFtbU3RhdGVPYmplY3RdXSBvYmplY3QuXG4gKlxuICogVGhpcyBjbGFzcyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBbW1N0YXRlRGVjbGFyYXRpb25dXS5cbiAqIEVhY2ggb2YgaXRzIG93biBwcm9wZXJ0aWVzIChpLmUuLCBgaGFzT3duUHJvcGVydHlgKSBhcmUgYnVpbHQgdXNpbmcgYnVpbGRlcnMgZnJvbSB0aGUgW1tTdGF0ZUJ1aWxkZXJdXS5cbiAqL1xudmFyIFN0YXRlT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgU3RhdGUuY3JlYXRlKCkgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZU9iamVjdChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIFN0YXRlT2JqZWN0LmNyZWF0ZShjb25maWcgfHwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzdGF0ZSBvYmplY3QgdG8gcHV0IHRoZSBwcml2YXRlL2ludGVybmFsIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb250by5cbiAgICAgKiBUaGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIGxvb2tzIGxpa2U6XG4gICAgICogKEludGVybmFsIFN0YXRlIE9iamVjdCkgLT4gKENvcHkgb2YgU3RhdGUucHJvdG90eXBlKSAtPiAoU3RhdGUgRGVjbGFyYXRpb24gb2JqZWN0KSAtPiAoU3RhdGUgRGVjbGFyYXRpb24ncyBwcm90b3R5cGUuLi4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVEZWNsIHRoZSB1c2VyLXN1cHBsaWVkIFN0YXRlIERlY2xhcmF0aW9uXG4gICAgICogQHJldHVybnMge1N0YXRlT2JqZWN0fSBhbiBpbnRlcm5hbCBTdGF0ZSBvYmplY3RcbiAgICAgKi9cbiAgICBTdGF0ZU9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoc3RhdGVEZWNsKSB7XG4gICAgICAgIHN0YXRlRGVjbCA9IFN0YXRlT2JqZWN0LmlzU3RhdGVDbGFzcyhzdGF0ZURlY2wpID8gbmV3IHN0YXRlRGVjbCgpIDogc3RhdGVEZWNsO1xuICAgICAgICB2YXIgc3RhdGUgPSBjb21tb25fMS5pbmhlcml0KGNvbW1vbl8xLmluaGVyaXQoc3RhdGVEZWNsLCBTdGF0ZU9iamVjdC5wcm90b3R5cGUpKTtcbiAgICAgICAgc3RhdGVEZWNsLiQkc3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZTsgfTtcbiAgICAgICAgc3RhdGUuc2VsZiA9IHN0YXRlRGVjbDtcbiAgICAgICAgc3RhdGUuX19zdGF0ZU9iamVjdENhY2hlID0ge1xuICAgICAgICAgICAgbmFtZUdsb2I6IGdsb2JfMS5HbG9iLmZyb21TdHJpbmcoc3RhdGUubmFtZSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIHRoZSBzYW1lIHN0YXRlLlxuICAgICAqXG4gICAgICogQ29tcGFyZXMgdGhlIGlkZW50aXR5IG9mIHRoZSBzdGF0ZSBhZ2FpbnN0IHRoZSBwYXNzZWQgdmFsdWUsIHdoaWNoIGlzIGVpdGhlciBhbiBvYmplY3RcbiAgICAgKiByZWZlcmVuY2UgdG8gdGhlIGFjdHVhbCBgU3RhdGVgIGluc3RhbmNlLCB0aGUgb3JpZ2luYWwgZGVmaW5pdGlvbiBvYmplY3QgcGFzc2VkIHRvXG4gICAgICogYCRzdGF0ZVByb3ZpZGVyLnN0YXRlKClgLCBvciB0aGUgZnVsbHktcXVhbGlmaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVmIENhbiBiZSBvbmUgb2YgKGEpIGEgYFN0YXRlYCBpbnN0YW5jZSwgKGIpIGFuIG9iamVjdCB0aGF0IHdhcyBwYXNzZWRcbiAgICAgKiAgICAgICAgaW50byBgJHN0YXRlUHJvdmlkZXIuc3RhdGUoKWAsIChjKSB0aGUgZnVsbHktcXVhbGlmaWVkIG5hbWUgb2YgYSBzdGF0ZSBhcyBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBgcmVmYCBtYXRjaGVzIHRoZSBjdXJyZW50IGBTdGF0ZWAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgU3RhdGVPYmplY3QucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PT0gcmVmIHx8IHRoaXMuc2VsZiA9PT0gcmVmIHx8IHRoaXMuZnFuKCkgPT09IHJlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHRoaXMgZG9lcyBub3QgcHJvcGVybHkgaGFuZGxlIGRvdCBub3RhdGlvblxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYSBkb3Qtc2VwYXJhdGVkIG5hbWUgb2YgdGhlIHN0YXRlLlxuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5mcW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQgfHwgISh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcmVudC5mcW4oKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBuYW1lICsgJy4nICsgdGhpcy5uYW1lIDogdGhpcy5uYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9vdCBub2RlIG9mIHRoaXMgc3RhdGUncyB0cmVlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHJvb3Qgb2YgdGhpcyBzdGF0ZSdzIHRyZWUuXG4gICAgICovXG4gICAgU3RhdGVPYmplY3QucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucm9vdCgpKSB8fCB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdGUncyBgUGFyYW1gIG9iamVjdHNcbiAgICAgKlxuICAgICAqIEdldHMgdGhlIGxpc3Qgb2YgW1tQYXJhbV1dIG9iamVjdHMgb3duZWQgYnkgdGhlIHN0YXRlLlxuICAgICAqIElmIGBvcHRzLmluaGVyaXRgIGlzIHRydWUsIGl0IGFsc28gaW5jbHVkZXMgdGhlIGFuY2VzdG9yIHN0YXRlcycgW1tQYXJhbV1dIG9iamVjdHMuXG4gICAgICogSWYgYG9wdHMubWF0Y2hpbmdLZXlzYCBleGlzdHMsIHJldHVybnMgb25seSBgUGFyYW1gcyB3aG9zZSBgaWRgIGlzIGEga2V5IG9uIHRoZSBgbWF0Y2hpbmdLZXlzYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIG9wdGlvbnNcbiAgICAgKi9cbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRzLCB7IGluaGVyaXQ6IHRydWUsIG1hdGNoaW5nS2V5czogbnVsbCB9KTtcbiAgICAgICAgdmFyIGluaGVyaXRlZCA9IChvcHRzLmluaGVyaXQgJiYgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGFyYW1ldGVycygpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIGluaGVyaXRlZFxuICAgICAgICAgICAgLmNvbmNhdChjb21tb25fMS52YWx1ZXModGhpcy5wYXJhbXMpKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFvcHRzLm1hdGNoaW5nS2V5cyB8fCBvcHRzLm1hdGNoaW5nS2V5cy5oYXNPd25Qcm9wZXJ0eShwYXJhbS5pZCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBbW1BhcmFtXV0gdGhhdCBpcyBvd25lZCBieSB0aGUgc3RhdGVcbiAgICAgKlxuICAgICAqIElmIGBvcHRzLmluaGVyaXRgIGlzIHRydWUsIGl0IGFsc28gc2VhcmNoZXMgdGhlIGFuY2VzdG9yIHN0YXRlc2AgW1tQYXJhbV1dcy5cbiAgICAgKiBAcGFyYW0gaWQgdGhlIG5hbWUgb2YgdGhlIFtbUGFyYW1dXSB0byByZXR1cm5cbiAgICAgKiBAcGFyYW0gb3B0cyBvcHRpb25zXG4gICAgICovXG4gICAgU3RhdGVPYmplY3QucHJvdG90eXBlLnBhcmFtZXRlciA9IGZ1bmN0aW9uIChpZCwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gKCh0aGlzLnVybCAmJiB0aGlzLnVybC5wYXJhbWV0ZXIoaWQsIG9wdHMpKSB8fFxuICAgICAgICAgICAgY29tbW9uXzEuZmluZChjb21tb25fMS52YWx1ZXModGhpcy5wYXJhbXMpLCBob2ZfMS5wcm9wRXEoJ2lkJywgaWQpKSB8fFxuICAgICAgICAgICAgKG9wdHMuaW5oZXJpdCAmJiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5wYXJhbWV0ZXIoaWQpKSk7XG4gICAgfTtcbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZxbigpO1xuICAgIH07XG4gICAgLyoqIFByZWRpY2F0ZSB3aGljaCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhbiBjbGFzcyB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvciAqL1xuICAgIFN0YXRlT2JqZWN0LmlzU3RhdGVDbGFzcyA9IGZ1bmN0aW9uIChzdGF0ZURlY2wpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHN0YXRlRGVjbCkgJiYgc3RhdGVEZWNsWydfX3VpUm91dGVyU3RhdGUnXSA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKiBQcmVkaWNhdGUgd2hpY2ggcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCAqL1xuICAgIFN0YXRlT2JqZWN0LmlzU3RhdGUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBwcmVkaWNhdGVzXzEuaXNPYmplY3Qob2JqWydfX3N0YXRlT2JqZWN0Q2FjaGUnXSk7IH07XG4gICAgcmV0dXJuIFN0YXRlT2JqZWN0O1xufSgpKTtcbmV4cG9ydHMuU3RhdGVPYmplY3QgPSBTdGF0ZU9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgc3RhdGVPYmplY3RfMSA9IHJlcXVpcmUoXCIuL3N0YXRlT2JqZWN0XCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG4vKiogQGludGVybmFsYXBpICovXG52YXIgU3RhdGVRdWV1ZU1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVRdWV1ZU1hbmFnZXIoJHJlZ2lzdHJ5LCAkdXJsUm91dGVyLCBzdGF0ZXMsIGJ1aWxkZXIsIGxpc3RlbmVycykge1xuICAgICAgICB0aGlzLiRyZWdpc3RyeSA9ICRyZWdpc3RyeTtcbiAgICAgICAgdGhpcy4kdXJsUm91dGVyID0gJHVybFJvdXRlcjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMubWF0Y2hlciA9ICRyZWdpc3RyeS5tYXRjaGVyO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB9O1xuICAgIFN0YXRlUXVldWVNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChzdGF0ZURlY2wpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVPYmplY3RfMS5TdGF0ZU9iamVjdC5jcmVhdGUoc3RhdGVEZWNsKTtcbiAgICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5uYW1lO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGUgbXVzdCBoYXZlIGEgdmFsaWQgbmFtZScpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgY29tbW9uXzEuaW5BcnJheShxdWV1ZS5tYXAoaG9mXzEucHJvcCgnbmFtZScpKSwgbmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSAnXCIgKyBuYW1lICsgXCInIGlzIGFscmVhZHkgZGVmaW5lZFwiKTtcbiAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG4gICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBxdWV1ZSA9IF9hLnF1ZXVlLCBzdGF0ZXMgPSBfYS5zdGF0ZXMsIGJ1aWxkZXIgPSBfYS5idWlsZGVyO1xuICAgICAgICB2YXIgcmVnaXN0ZXJlZCA9IFtdLCAvLyBzdGF0ZXMgdGhhdCBnb3QgcmVnaXN0ZXJlZFxuICAgICAgICBvcnBoYW5zID0gW10sIC8vIHN0YXRlcyB0aGF0IGRvbid0IHlldCBoYXZlIGEgcGFyZW50IHJlZ2lzdGVyZWRcbiAgICAgICAgcHJldmlvdXNRdWV1ZUxlbmd0aCA9IHt9OyAvLyBrZWVwIHRyYWNrIG9mIGhvdyBsb25nIHRoZSBxdWV1ZSB3aGVuIGFuIG9ycGhhbiB3YXMgZmlyc3QgZW5jb3VudGVyZWRcbiAgICAgICAgdmFyIGdldFN0YXRlID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLnN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBfdGhpcy5zdGF0ZXNbbmFtZV07IH07XG4gICAgICAgIHZhciBub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmVnaXN0ZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKCdyZWdpc3RlcmVkJywgcmVnaXN0ZXJlZC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuc2VsZjsgfSkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gc3RhdGUubmFtZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBidWlsZGVyLmJ1aWxkKHN0YXRlKTtcbiAgICAgICAgICAgIHZhciBvcnBoYW5JZHggPSBvcnBoYW5zLmluZGV4T2Yoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ1N0YXRlID0gZ2V0U3RhdGUobmFtZV8xKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTdGF0ZSAmJiBleGlzdGluZ1N0YXRlLm5hbWUgPT09IG5hbWVfMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSAnXCIgKyBuYW1lXzEgKyBcIicgaXMgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdGdXR1cmVTdGF0ZSA9IGdldFN0YXRlKG5hbWVfMSArICcuKionKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdGdXR1cmVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnV0dXJlIHN0YXRlIG9mIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcmVnaXN0cnkuZGVyZWdpc3RlcihleGlzdGluZ0Z1dHVyZVN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGVzW25hbWVfMV0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFJvdXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAob3JwaGFuSWR4ID49IDApXG4gICAgICAgICAgICAgICAgICAgIG9ycGhhbnMuc3BsaWNlKG9ycGhhbklkeCwgMSk7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZC5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldmlvdXNRdWV1ZUxlbmd0aFtuYW1lXzFdO1xuICAgICAgICAgICAgcHJldmlvdXNRdWV1ZUxlbmd0aFtuYW1lXzFdID0gcXVldWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9ycGhhbklkeCA+PSAwICYmIHByZXYgPT09IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgdHdvIGNvbnNlY3V0aXZlIGl0ZXJhdGlvbnMgd2hlcmUgbm8gYWRkaXRpb25hbCBzdGF0ZXMgd2VyZSBkZXF1ZXVlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVnaXN0ZXIgb3JwaGFuZWQgc3RhdGUgJyR7bmFtZX0nYCk7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgbm90aWZ5TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9ycGhhbklkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBvcnBoYW5zLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZXM7XG4gICAgfTtcbiAgICBTdGF0ZVF1ZXVlTWFuYWdlci5wcm90b3R5cGUuYXR0YWNoUm91dGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlLmFic3RyYWN0IHx8ICFzdGF0ZS51cmwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJHVybFJvdXRlci5ydWxlKHRoaXMuJHVybFJvdXRlci51cmxSdWxlRmFjdG9yeS5jcmVhdGUoc3RhdGUpKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZVF1ZXVlTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLlN0YXRlUXVldWVNYW5hZ2VyID0gU3RhdGVRdWV1ZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZVF1ZXVlTWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgc3RhdGVcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdGF0ZU1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlTWF0Y2hlclwiKTtcbnZhciBzdGF0ZUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlQnVpbGRlclwiKTtcbnZhciBzdGF0ZVF1ZXVlTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vc3RhdGVRdWV1ZU1hbmFnZXJcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIFN0YXRlUmVnaXN0cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIGZ1bmN0aW9uIFN0YXRlUmVnaXN0cnkoX3JvdXRlcikge1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSBfcm91dGVyO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHt9O1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoZXIgPSBuZXcgc3RhdGVNYXRjaGVyXzEuU3RhdGVNYXRjaGVyKHRoaXMuc3RhdGVzKTtcbiAgICAgICAgdGhpcy5idWlsZGVyID0gbmV3IHN0YXRlQnVpbGRlcl8xLlN0YXRlQnVpbGRlcih0aGlzLm1hdGNoZXIsIF9yb3V0ZXIudXJsTWF0Y2hlckZhY3RvcnkpO1xuICAgICAgICB0aGlzLnN0YXRlUXVldWUgPSBuZXcgc3RhdGVRdWV1ZU1hbmFnZXJfMS5TdGF0ZVF1ZXVlTWFuYWdlcih0aGlzLCBfcm91dGVyLnVybFJvdXRlciwgdGhpcy5zdGF0ZXMsIHRoaXMuYnVpbGRlciwgdGhpcy5saXN0ZW5lcnMpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlclJvb3QoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLl9yZWdpc3RlclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290U3RhdGVEZWYgPSB7XG4gICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgIHVybDogJ14nLFxuICAgICAgICAgICAgdmlld3M6IG51bGwsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAnIyc6IHsgdmFsdWU6IG51bGwsIHR5cGU6ICdoYXNoJywgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFic3RyYWN0OiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3Jvb3QgPSAodGhpcy5fcm9vdCA9IHRoaXMuc3RhdGVRdWV1ZS5yZWdpc3Rlcihyb290U3RhdGVEZWYpKTtcbiAgICAgICAgX3Jvb3QubmF2aWdhYmxlID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0YXRlUXVldWUuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmdldCgpLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBfdGhpcy5nZXQoc3RhdGUpICYmIF90aGlzLmRlcmVnaXN0ZXIoc3RhdGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgYSBTdGF0ZSBSZWdpc3RyeSBldmVudHNcbiAgICAgKlxuICAgICAqIEFkZHMgYSBjYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlbiBzdGF0ZXMgYXJlIHJlZ2lzdGVyZWQgb3IgZGVyZWdpc3RlcmVkIHdpdGggdGhlIFN0YXRlUmVnaXN0cnkuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBsZXQgYWxsU3RhdGVzID0gcmVnaXN0cnkuZ2V0KCk7XG4gICAgICpcbiAgICAgKiAvLyBMYXRlciwgaW52b2tlIGRlcmVnaXN0ZXJGbigpIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgKiBsZXQgZGVyZWdpc3RlckZuID0gcmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKChldmVudCwgc3RhdGVzKSA9PiB7XG4gICAgICogICBzd2l0Y2goZXZlbnQpIHtcbiAgICAgKiAgICAgY2FzZTogJ3JlZ2lzdGVyZWQnOlxuICAgICAqICAgICAgIHN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IGFsbFN0YXRlcy5wdXNoKHN0YXRlKSk7XG4gICAgICogICAgICAgYnJlYWs7XG4gICAgICogICAgIGNhc2U6ICdkZXJlZ2lzdGVyZWQnOlxuICAgICAqICAgICAgIHN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgKiAgICAgICAgIGxldCBpZHggPSBhbGxTdGF0ZXMuaW5kZXhPZihzdGF0ZSk7XG4gICAgICogICAgICAgICBpZiAoaWR4ICE9PSAtMSkgYWxsU3RhdGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAqICAgICAgIH0pO1xuICAgICAqICAgICAgIGJyZWFrO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCB3aGVuIHRoZSByZWdpc3RlcmVkIHN0YXRlcyBjaGFuZ2VzLlxuICAgICAqICAgICAgICBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHBhcmFtZXRlcnMsIGBldmVudGAgYW5kIGBzdGF0ZWAuXG4gICAgICogICAgICAgIFNlZSBbW1N0YXRlUmVnaXN0cnlMaXN0ZW5lcl1dXG4gICAgICogQHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZGVyZWdpc3RlcnMgdGhlIGxpc3RlbmVyXG4gICAgICovXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUub25TdGF0ZXNDaGFuZ2VkID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVyZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLmxpc3RlbmVycykobGlzdGVuZXIpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbXBsaWNpdCByb290IHN0YXRlXG4gICAgICpcbiAgICAgKiBHZXRzIHRoZSByb290IG9mIHRoZSBzdGF0ZSB0cmVlLlxuICAgICAqIFRoZSByb290IHN0YXRlIGlzIGltcGxpY2l0bHkgY3JlYXRlZCBieSBVSS1Sb3V0ZXIuXG4gICAgICogTm90ZTogdGhpcyByZXR1cm5zIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gcmVwcmVzZW50YXRpb24sIG5vdCBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSByb290IFtbU3RhdGVPYmplY3RdXVxuICAgICAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0YXRlIHRvIHRoZSByZWdpc3RyeVxuICAgICAqXG4gICAgICogUmVnaXN0ZXJzIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0gb3IgcXVldWVzIGl0IGZvciByZWdpc3RyYXRpb24uXG4gICAgICpcbiAgICAgKiBOb3RlOiBhIHN0YXRlIHdpbGwgYmUgcXVldWVkIGlmIHRoZSBzdGF0ZSdzIHBhcmVudCBpc24ndCB5ZXQgcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZURlZmluaXRpb24gdGhlIGRlZmluaXRpb24gb2YgdGhlIHN0YXRlIHRvIHJlZ2lzdGVyLlxuICAgICAqIEByZXR1cm5zIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0LlxuICAgICAqICAgICAgICAgIElmIHRoZSBzdGF0ZSB3YXMgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQsIHRoZW4gdGhlIG9iamVjdCBpcyBmdWxseSBidWlsdCAoU2VlOiBbW1N0YXRlQnVpbGRlcl1dKS5cbiAgICAgKiAgICAgICAgICBJZiB0aGUgc3RhdGUgd2FzIG9ubHkgcXVldWVkLCB0aGVuIHRoZSBvYmplY3QgaXMgbm90IGZ1bGx5IGJ1aWx0LlxuICAgICAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHN0YXRlRGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVF1ZXVlLnJlZ2lzdGVyKHN0YXRlRGVmaW5pdGlvbik7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLl9kZXJlZ2lzdGVyVHJlZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWxsID0gdGhpcy5nZXQoKS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuJCRzdGF0ZSgpOyB9KTtcbiAgICAgICAgdmFyIGdldENoaWxkcmVuID0gZnVuY3Rpb24gKHN0YXRlcykge1xuICAgICAgICAgICAgdmFyIF9jaGlsZHJlbiA9IGFsbC5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHN0YXRlcy5pbmRleE9mKHMucGFyZW50KSAhPT0gLTE7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBfY2hpbGRyZW4gOiBfY2hpbGRyZW4uY29uY2F0KGdldENoaWxkcmVuKF9jaGlsZHJlbikpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihbc3RhdGVdKTtcbiAgICAgICAgdmFyIGRlcmVnaXN0ZXJlZCA9IFtzdGF0ZV0uY29uY2F0KGNoaWxkcmVuKS5yZXZlcnNlKCk7XG4gICAgICAgIGRlcmVnaXN0ZXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChfc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciAkdXIgPSBfdGhpcy5fcm91dGVyLnVybFJvdXRlcjtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBVUkwgcnVsZVxuICAgICAgICAgICAgJHVyXG4gICAgICAgICAgICAgICAgLnJ1bGVzKClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGhvZl8xLnByb3BFcSgnc3RhdGUnLCBfc3RhdGUpKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKCR1ci5yZW1vdmVSdWxlLmJpbmQoJHVyKSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3RhdGUgZnJvbSByZWdpc3RyeVxuICAgICAgICAgICAgZGVsZXRlIF90aGlzLnN0YXRlc1tfc3RhdGUubmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVyZWdpc3RlcmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHN0YXRlIGZyb20gdGhlIHJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKiBUaGlzIHJlbW92ZXMgYSBzdGF0ZSBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICAgKiBJZiB0aGUgc3RhdGUgaGFzIGNoaWxkcmVuLCB0aGV5IGFyZSBhcmUgYWxzbyByZW1vdmVkIGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlT3JOYW1lIHRoZSBzdGF0ZSdzIG5hbWUgb3Igb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAgICogQHJldHVybnMge1N0YXRlT2JqZWN0W119IGEgbGlzdCBvZiByZW1vdmVkIHN0YXRlc1xuICAgICAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmRlcmVnaXN0ZXIgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSA9IHRoaXMuZ2V0KHN0YXRlT3JOYW1lKTtcbiAgICAgICAgaWYgKCFfc3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBkZXJlZ2lzdGVyIHN0YXRlOyBub3QgZm91bmQ6IFwiICsgc3RhdGVPck5hbWUpO1xuICAgICAgICB2YXIgZGVyZWdpc3RlcmVkU3RhdGVzID0gdGhpcy5fZGVyZWdpc3RlclRyZWUoX3N0YXRlLiQkc3RhdGUoKSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcignZGVyZWdpc3RlcmVkJywgZGVyZWdpc3RlcmVkU3RhdGVzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5zZWxmOyB9KSk7IH0pO1xuICAgICAgICByZXR1cm4gZGVyZWdpc3RlcmVkU3RhdGVzO1xuICAgIH07XG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBiYXNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RhdGVzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLnN0YXRlc1tuYW1lXS5zZWxmOyB9KTtcbiAgICAgICAgdmFyIGZvdW5kID0gdGhpcy5tYXRjaGVyLmZpbmQoc3RhdGVPck5hbWUsIGJhc2UpO1xuICAgICAgICByZXR1cm4gKGZvdW5kICYmIGZvdW5kLnNlbGYpIHx8IG51bGw7XG4gICAgfTtcbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5kZWNvcmF0b3IgPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZGVyLmJ1aWxkZXIobmFtZSwgZnVuYyk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVSZWdpc3RyeTtcbn0oKSk7XG5leHBvcnRzLlN0YXRlUmVnaXN0cnkgPSBTdGF0ZVJlZ2lzdHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVSZWdpc3RyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgc3RhdGVcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgcXVldWVfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcXVldWVcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciBwYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9wYXRoL3BhdGhVdGlsc1wiKTtcbnZhciBwYXRoTm9kZV8xID0gcmVxdWlyZShcIi4uL3BhdGgvcGF0aE5vZGVcIik7XG52YXIgdHJhbnNpdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlXCIpO1xudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnlcIik7XG52YXIgdGFyZ2V0U3RhdGVfMSA9IHJlcXVpcmUoXCIuL3RhcmdldFN0YXRlXCIpO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtXCIpO1xudmFyIGdsb2JfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZ2xvYlwiKTtcbnZhciByZXNvbHZlQ29udGV4dF8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHRcIik7XG52YXIgbGF6eUxvYWRfMSA9IHJlcXVpcmUoXCIuLi9ob29rcy9sYXp5TG9hZFwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xuLyoqXG4gKiBQcm92aWRlcyBzdGF0ZSByZWxhdGVkIHNlcnZpY2UgZnVuY3Rpb25zXG4gKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHVpLXJvdXRlciBzdGF0ZXMuXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIGxvY2F0ZWQgb24gdGhlIGdsb2JhbCBbW1VJUm91dGVyXV0gb2JqZWN0LlxuICovXG52YXIgU3RhdGVTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZVNlcnZpY2Uocm91dGVyKSB7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgICAgIHRoaXMuaW52YWxpZENhbGxiYWNrcyA9IFtdO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9kZWZhdWx0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gJGRlZmF1bHRFcnJvckhhbmRsZXIoJGVycm9yJCkge1xuICAgICAgICAgICAgaWYgKCRlcnJvciQgaW5zdGFuY2VvZiBFcnJvciAmJiAkZXJyb3IkLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJGVycm9yJCBpbnN0YW5jZW9mIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCRlcnJvciQuZGV0YWlsICYmICRlcnJvciQuZGV0YWlsLnN0YWNrKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQuZGV0YWlsLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXR0ZXJzID0gWydjdXJyZW50JywgJyRjdXJyZW50JywgJ3BhcmFtcycsICd0cmFuc2l0aW9uJ107XG4gICAgICAgIHZhciBib3VuZEZucyA9IE9iamVjdC5rZXlzKFN0YXRlU2VydmljZS5wcm90b3R5cGUpLmZpbHRlcihob2ZfMS5ub3QoY29tbW9uXzEuaW5BcnJheShnZXR0ZXJzKSkpO1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhob2ZfMS52YWwoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSksIHRoaXMsIGhvZl8xLnZhbCh0aGlzKSwgYm91bmRGbnMpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJ0cmFuc2l0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBbW1RyYW5zaXRpb25dXSBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MgKG9yIG51bGwpXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0aHJvdWdoIHRvIFtbVUlSb3V0ZXJHbG9iYWxzLnRyYW5zaXRpb25dXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJwYXJhbXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhdGVzdCBzdWNjZXNzZnVsIHN0YXRlIHBhcmFtZXRlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMucGFyYW1zXV1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMucGFyYW1zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJjdXJyZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IFtbU3RhdGVEZWNsYXJhdGlvbl1dXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0aHJvdWdoIHRvIFtbVUlSb3V0ZXJHbG9iYWxzLmN1cnJlbnRdXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy5jdXJyZW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCIkY3VycmVudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBbW1N0YXRlT2JqZWN0XV1cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMuJGN1cnJlbnRdXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy4kY3VycmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyKGNvbW1vbl8xLm5vb3ApO1xuICAgICAgICB0aGlzLmludmFsaWRDYWxsYmFja3MgPSBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHdoZW4gW1t0cmFuc2l0aW9uVG9dXSBpcyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIHN0YXRlLlxuICAgICAqXG4gICAgICogSW52b2tlcyB0aGUgW1tvbkludmFsaWRdXSBjYWxsYmFja3MsIGluIG5hdHVyYWwgb3JkZXIuXG4gICAgICogRWFjaCBjYWxsYmFjaydzIHJldHVybiB2YWx1ZSBpcyBjaGVja2VkIGluIHNlcXVlbmNlIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgVGFyZ2V0U3RhdGUuXG4gICAgICogVGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrcyBhcmUgd3JhcHBlZCBpbiAkcS53aGVuKCksIHNvIHRoZSBjYWxsYmFja3MgbWF5IHJldHVybiBwcm9taXNlcy5cbiAgICAgKlxuICAgICAqIElmIGEgY2FsbGJhY2sgcmV0dXJucyBhbiBUYXJnZXRTdGF0ZSwgdGhlbiBpdCBpcyB1c2VkIGFzIGFyZ3VtZW50cyB0byAkc3RhdGUudHJhbnNpdGlvblRvKCkgYW5kIHRoZSByZXN1bHQgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLl9oYW5kbGVJbnZhbGlkVGFyZ2V0U3RhdGUgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRvU3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZyb21TdGF0ZSA9IHBhdGhVdGlsc18xLlBhdGhVdGlscy5tYWtlVGFyZ2V0U3RhdGUodGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeSwgZnJvbVBhdGgpO1xuICAgICAgICB2YXIgZ2xvYmFscyA9IHRoaXMucm91dGVyLmdsb2JhbHM7XG4gICAgICAgIHZhciBsYXRlc3RUaGluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsb2JhbHMudHJhbnNpdGlvbkhpc3RvcnkucGVla1RhaWwoKTsgfTtcbiAgICAgICAgdmFyIGxhdGVzdCA9IGxhdGVzdFRoaW5nKCk7XG4gICAgICAgIHZhciBjYWxsYmFja1F1ZXVlID0gbmV3IHF1ZXVlXzEuUXVldWUodGhpcy5pbnZhbGlkQ2FsbGJhY2tzLnNsaWNlKCkpO1xuICAgICAgICB2YXIgaW5qZWN0b3IgPSBuZXcgcmVzb2x2ZUNvbnRleHRfMS5SZXNvbHZlQ29udGV4dChmcm9tUGF0aCkuaW5qZWN0b3IoKTtcbiAgICAgICAgdmFyIGNoZWNrRm9yUmVkaXJlY3QgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoIShyZXN1bHQgaW5zdGFuY2VvZiB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSByZXN1bHQ7XG4gICAgICAgICAgICAvLyBSZWNyZWF0ZSB0aGUgVGFyZ2V0U3RhdGUsIGluIGNhc2UgdGhlIHN0YXRlIGlzIG5vdyBkZWZpbmVkLlxuICAgICAgICAgICAgdGFyZ2V0ID0gX3RoaXMudGFyZ2V0KHRhcmdldC5pZGVudGlmaWVyKCksIHRhcmdldC5wYXJhbXMoKSwgdGFyZ2V0Lm9wdGlvbnMoKSk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldC52YWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uaW52YWxpZCh0YXJnZXQuZXJyb3IoKSkudG9Qcm9taXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGF0ZXN0VGhpbmcoKSAhPT0gbGF0ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uc3VwZXJzZWRlZCgpLnRvUHJvbWlzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zaXRpb25Ubyh0YXJnZXQuaWRlbnRpZmllcigpLCB0YXJnZXQucGFyYW1zKCksIHRhcmdldC5vcHRpb25zKCkpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBpbnZva2VOZXh0Q2FsbGJhY2soKSB7XG4gICAgICAgICAgICB2YXIgbmV4dENhbGxiYWNrID0gY2FsbGJhY2tRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICBpZiAobmV4dENhbGxiYWNrID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uaW52YWxpZCh0b1N0YXRlLmVycm9yKCkpLnRvUHJvbWlzZSgpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrUmVzdWx0ID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbihuZXh0Q2FsbGJhY2sodG9TdGF0ZSwgZnJvbVN0YXRlLCBpbmplY3RvcikpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrUmVzdWx0LnRoZW4oY2hlY2tGb3JSZWRpcmVjdCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQgfHwgaW52b2tlTmV4dENhbGxiYWNrKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnZva2VOZXh0Q2FsbGJhY2soKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBJbnZhbGlkIFN0YXRlIGhhbmRsZXJcbiAgICAgKlxuICAgICAqIFJlZ2lzdGVycyBhIFtbT25JbnZhbGlkQ2FsbGJhY2tdXSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV1cbiAgICAgKiBoYXMgYmVlbiBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIHN0YXRlIHJlZmVyZW5jZSBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBzdGF0ZVNlcnZpY2Uub25JbnZhbGlkKGZ1bmN0aW9uKHRvLCBmcm9tLCBpbmplY3Rvcikge1xuICAgICAqICAgaWYgKHRvLm5hbWUoKSA9PT0gJ2ZvbycpIHtcbiAgICAgKiAgICAgbGV0IGxhenlMb2FkZXIgPSBpbmplY3Rvci5nZXQoJ0xhenlMb2FkU2VydmljZScpO1xuICAgICAqICAgICByZXR1cm4gbGF6eUxvYWRlci5sb2FkKCdmb28nKVxuICAgICAqICAgICAgICAgLnRoZW4oKCkgPT4gc3RhdGVTZXJ2aWNlLnRhcmdldCgnZm9vJykpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgaW52b2tlZCB3aGVuIHRoZSB0b1N0YXRlIGlzIGludmFsaWRcbiAgICAgKiAgIFRoaXMgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIChpbnZhbGlkKSB0b1N0YXRlLCB0aGUgZnJvbVN0YXRlLCBhbmQgYW4gaW5qZWN0b3IuXG4gICAgICogICBUaGUgZnVuY3Rpb24gbWF5IG9wdGlvbmFsbHkgcmV0dXJuIGEgW1tUYXJnZXRTdGF0ZV1dIG9yIGEgUHJvbWlzZSBmb3IgYSBUYXJnZXRTdGF0ZS5cbiAgICAgKiAgIElmIG9uZSBpcyByZXR1cm5lZCwgaXQgaXMgdHJlYXRlZCBhcyBhIHJlZGlyZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLm9uSW52YWxpZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmludmFsaWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkZXJlZ2lzdGVyTGlzdGVuZXIoKSB7XG4gICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKHRoaXMuaW52YWxpZENhbGxiYWNrcykoY2FsbGJhY2spO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICpcbiAgICAgKiBBIG1ldGhvZCB0aGF0IGZvcmNlIHJlbG9hZHMgdGhlIGN1cnJlbnQgc3RhdGUsIG9yIGEgcGFydGlhbCBzdGF0ZSBoaWVyYXJjaHkuXG4gICAgICogQWxsIHJlc29sdmVzIGFyZSByZS1yZXNvbHZlZCwgYW5kIGNvbXBvbmVudHMgcmVpbnN0YW50aWF0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBsZXQgYXBwIGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUucmVsb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgKiAgICAgJHN0YXRlLnJlbG9hZCgpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTm90ZTogYHJlbG9hZCgpYCBpcyBqdXN0IGFuIGFsaWFzIGZvcjpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogJHN0YXRlLnRyYW5zaXRpb25Ubygkc3RhdGUuY3VycmVudCwgJHN0YXRlLnBhcmFtcywge1xuICAgICAqICAgcmVsb2FkOiB0cnVlLCBpbmhlcml0OiBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbG9hZFN0YXRlIEEgc3RhdGUgbmFtZSBvciBhIHN0YXRlIG9iamVjdC5cbiAgICAgKiAgICBJZiBwcmVzZW50LCB0aGlzIHN0YXRlIGFuZCBhbGwgaXRzIGNoaWxkcmVuIHdpbGwgYmUgcmVsb2FkZWQsIGJ1dCBhbmNlc3RvcnMgd2lsbCBub3QgcmVsb2FkLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogLy9hc3N1bWluZyBhcHAgYXBwbGljYXRpb24gY29uc2lzdHMgb2YgMyBzdGF0ZXM6ICdjb250YWN0cycsICdjb250YWN0cy5kZXRhaWwnLCAnY29udGFjdHMuZGV0YWlsLml0ZW0nXG4gICAgICogLy9hbmQgY3VycmVudCBzdGF0ZSBpcyAnY29udGFjdHMuZGV0YWlsLml0ZW0nXG4gICAgICogbGV0IGFwcCBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgICAqICAgJHNjb3BlLnJlbG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICogICAgIC8vd2lsbCByZWxvYWQgJ2NvbnRhY3QuZGV0YWlsJyBhbmQgbmVzdGVkICdjb250YWN0LmRldGFpbC5pdGVtJyBzdGF0ZXNcbiAgICAgKiAgICAgJHN0YXRlLnJlbG9hZCgnY29udGFjdC5kZXRhaWwnKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi4gU2VlIFtbU3RhdGVTZXJ2aWNlLmdvXV1cbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLnJlbG9hZCA9IGZ1bmN0aW9uIChyZWxvYWRTdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8odGhpcy5jdXJyZW50LCB0aGlzLnBhcmFtcywge1xuICAgICAgICAgICAgcmVsb2FkOiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHJlbG9hZFN0YXRlKSA/IHJlbG9hZFN0YXRlIDogdHJ1ZSxcbiAgICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICAgICAgbm90aWZ5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9uIHRvIGEgZGlmZmVyZW50IHN0YXRlIGFuZC9vciBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHRyYW5zaXRpb25pbmcgdG8gYSBuZXcgc3RhdGUuXG4gICAgICpcbiAgICAgKiBgJHN0YXRlLmdvYCBjYWxscyBgJHN0YXRlLnRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSBidXQgYXV0b21hdGljYWxseSBzZXRzIG9wdGlvbnMgdG9cbiAgICAgKiBgeyBsb2NhdGlvbjogdHJ1ZSwgaW5oZXJpdDogdHJ1ZSwgcmVsYXRpdmU6IHJvdXRlci5nbG9iYWxzLiRjdXJyZW50LCBub3RpZnk6IHRydWUgfWAuXG4gICAgICogVGhpcyBhbGxvd3MgeW91IHRvIHVzZSBlaXRoZXIgYW4gYWJzb2x1dGUgb3IgcmVsYXRpdmUgYHRvYCBhcmd1bWVudCAoYmVjYXVzZSBvZiBgcmVsYXRpdmU6IHJvdXRlci5nbG9iYWxzLiRjdXJyZW50YCkuXG4gICAgICogSXQgYWxzbyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgKiBvbmx5IHRoZSBwYXJhbWV0ZXJzIHlvdSdkIGxpa2UgdG8gdXBkYXRlLCB3aGlsZSBsZXR0aW5nIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICAgKiBpbmhlcml0IGZyb20gdGhlIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcyAoYmVjYXVzZSBvZiBgaW5oZXJpdDogdHJ1ZWApLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICRzdGF0ZS5nbygnY29udGFjdC5kZXRhaWwnKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG8gQWJzb2x1dGUgc3RhdGUgbmFtZSwgc3RhdGUgb2JqZWN0LCBvciByZWxhdGl2ZSBzdGF0ZSBwYXRoIChyZWxhdGl2ZSB0byBjdXJyZW50IHN0YXRlKS5cbiAgICAgKlxuICAgICAqIFNvbWUgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAtIGAkc3RhdGUuZ28oJ2NvbnRhY3QuZGV0YWlsJylgIC0gd2lsbCBnbyB0byB0aGUgYGNvbnRhY3QuZGV0YWlsYCBzdGF0ZVxuICAgICAqIC0gYCRzdGF0ZS5nbygnXicpYCAtIHdpbGwgZ28gdG8gdGhlIHBhcmVudCBzdGF0ZVxuICAgICAqIC0gYCRzdGF0ZS5nbygnXi5zaWJsaW5nJylgIC0gaWYgY3VycmVudCBzdGF0ZSBpcyBgaG9tZS5jaGlsZGAsIHdpbGwgZ28gdG8gdGhlIGBob21lLnNpYmxpbmdgIHN0YXRlXG4gICAgICogLSBgJHN0YXRlLmdvKCcuY2hpbGQuZ3JhbmRjaGlsZCcpYCAtIGlmIGN1cnJlbnQgc3RhdGUgaXMgaG9tZSwgd2lsbCBnbyB0byB0aGUgYGhvbWUuY2hpbGQuZ3JhbmRjaGlsZGAgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQSBtYXAgb2YgdGhlIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8gdGhlIHN0YXRlLCB3aWxsIHBvcHVsYXRlICRzdGF0ZVBhcmFtcy5cbiAgICAgKlxuICAgICAqICAgIEFueSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBzcGVjaWZpZWQgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMgKGJlY2F1c2Ugb2YgYGluaGVyaXQ6IHRydWVgKS5cbiAgICAgKiAgICBUaGlzIGFsbG93cywgZm9yIGV4YW1wbGUsIGdvaW5nIHRvIGEgc2libGluZyBzdGF0ZSB0aGF0IHNoYXJlcyBwYXJhbWV0ZXJzIGRlZmluZWQgYnkgYSBwYXJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtwcm9taXNlfSBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdXRHb09wdHMgPSB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50LCBpbmhlcml0OiB0cnVlIH07XG4gICAgICAgIHZhciB0cmFuc09wdHMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCBkZWZhdXRHb09wdHMsIHRyYW5zaXRpb25TZXJ2aWNlXzEuZGVmYXVsdFRyYW5zT3B0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0bywgcGFyYW1zLCB0cmFuc09wdHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFtbVGFyZ2V0U3RhdGVdXVxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhIFRhcmdldFN0YXRlXG4gICAgICpcbiAgICAgKiBUaGlzIG1heSBiZSByZXR1cm5lZCBmcm9tIGEgVHJhbnNpdGlvbiBIb29rIHRvIHJlZGlyZWN0IGEgdHJhbnNpdGlvbiwgZm9yIGV4YW1wbGUuXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS50YXJnZXQgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIElmIHdlJ3JlIHJlbG9hZGluZywgZmluZCB0aGUgc3RhdGUgb2JqZWN0IHRvIHJlbG9hZCBmcm9tXG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNPYmplY3Qob3B0aW9ucy5yZWxvYWQpICYmICFvcHRpb25zLnJlbG9hZC5uYW1lKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlbG9hZCBzdGF0ZSBvYmplY3QnKTtcbiAgICAgICAgdmFyIHJlZyA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnk7XG4gICAgICAgIG9wdGlvbnMucmVsb2FkU3RhdGUgPVxuICAgICAgICAgICAgb3B0aW9ucy5yZWxvYWQgPT09IHRydWUgPyByZWcucm9vdCgpIDogcmVnLm1hdGNoZXIuZmluZChvcHRpb25zLnJlbG9hZCwgb3B0aW9ucy5yZWxhdGl2ZSk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlbG9hZCAmJiAhb3B0aW9ucy5yZWxvYWRTdGF0ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggcmVsb2FkIHN0YXRlICdcIiArIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcob3B0aW9ucy5yZWxvYWQpID8gb3B0aW9ucy5yZWxvYWQgOiBvcHRpb25zLnJlbG9hZC5uYW1lKSArIFwiJ1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnksIGlkZW50aWZpZXIsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldEN1cnJlbnRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ2xvYmFscyA9IHRoaXMucm91dGVyLmdsb2JhbHM7XG4gICAgICAgIHZhciBsYXRlc3RTdWNjZXNzID0gZ2xvYmFscy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMucGVla1RhaWwoKTtcbiAgICAgICAgdmFyIHJvb3RQYXRoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW25ldyBwYXRoTm9kZV8xLlBhdGhOb2RlKF90aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKSldOyB9O1xuICAgICAgICByZXR1cm4gbGF0ZXN0U3VjY2VzcyA/IGxhdGVzdFN1Y2Nlc3MudHJlZUNoYW5nZXMoKS50byA6IHJvb3RQYXRoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb3ctbGV2ZWwgbWV0aG9kIGZvciB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3IHN0YXRlLlxuICAgICAqXG4gICAgICogVGhlIFtbZ29dXSBtZXRob2QgKHdoaWNoIHVzZXMgYHRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSkgaXMgcmVjb21tZW5kZWQgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oJ2NvbnRhY3QuZGV0YWlsJyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHRvIFN0YXRlIG5hbWUgb3Igc3RhdGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB0b1BhcmFtcyBBIG1hcCBvZiB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc3RhdGUsXG4gICAgICogICAgICB3aWxsIHBvcHVsYXRlICRzdGF0ZVBhcmFtcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi4gU2VlIFtbZ29dXVxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gKHRvLCB0b1BhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodG9QYXJhbXMgPT09IHZvaWQgMCkgeyB0b1BhcmFtcyA9IHt9OyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnJvdXRlcjtcbiAgICAgICAgdmFyIGdsb2JhbHMgPSByb3V0ZXIuZ2xvYmFscztcbiAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIHRyYW5zaXRpb25TZXJ2aWNlXzEuZGVmYXVsdFRyYW5zT3B0cyk7XG4gICAgICAgIHZhciBnZXRDdXJyZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2xvYmFscy50cmFuc2l0aW9uOyB9O1xuICAgICAgICBvcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKG9wdGlvbnMsIHsgY3VycmVudDogZ2V0Q3VycmVudCB9KTtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXMudGFyZ2V0KHRvLCB0b1BhcmFtcywgb3B0aW9ucyk7XG4gICAgICAgIHZhciBjdXJyZW50UGF0aCA9IHRoaXMuZ2V0Q3VycmVudFBhdGgoKTtcbiAgICAgICAgaWYgKCFyZWYuZXhpc3RzKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlSW52YWxpZFRhcmdldFN0YXRlKGN1cnJlbnRQYXRoLCByZWYpO1xuICAgICAgICBpZiAoIXJlZi52YWxpZCgpKVxuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnNpbGVudFJlamVjdGlvbihyZWYuZXJyb3IoKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWFsIGhhbmRsaW5nIGZvciBJZ25vcmVkLCBBYm9ydGVkLCBhbmQgUmVkaXJlY3RlZCB0cmFuc2l0aW9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgc2VtYW50aWNzIGZvciB0aGUgdHJhbnNpdGlvbi5ydW4oKSBwcm9taXNlIGFuZCB0aGUgU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25UbygpXG4gICAgICAgICAqIHByb21pc2UgZGlmZmVyLiBGb3IgaW5zdGFuY2UsIHRoZSBydW4oKSBwcm9taXNlIG1heSBiZSByZWplY3RlZCBiZWNhdXNlIGl0IHdhc1xuICAgICAgICAgKiBJR05PUkVELCBidXQgdGhlIHRyYW5zaXRpb25UbygpIHByb21pc2UgaXMgcmVzb2x2ZWQgYmVjYXVzZSBmcm9tIHRoZSB1c2VyIHBlcnNwZWN0aXZlXG4gICAgICAgICAqIG5vIGVycm9yIG9jY3VycmVkLiAgTGlrZXdpc2UsIHRoZSB0cmFuc2l0aW9uLnJ1bigpIHByb21pc2UgbWF5IGJlIHJlamVjdGVkIGJlY2F1c2Ugb2ZcbiAgICAgICAgICogYSBSZWRpcmVjdCwgYnV0IHRoZSB0cmFuc2l0aW9uVG8oKSBwcm9taXNlIGlzIGNoYWluZWQgdG8gdGhlIG5ldyBUcmFuc2l0aW9uJ3MgcHJvbWlzZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciByZWplY3RlZFRyYW5zaXRpb25IYW5kbGVyID0gZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNMYXRlc3QgPSByb3V0ZXIuZ2xvYmFscy5sYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA9PT0gdHJhbnMuJGlkO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5JR05PUkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzTGF0ZXN0ICYmIHJvdXRlci51cmxSb3V0ZXIudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGlnbm9yZWQgYFRyYW5zaXRpb24ucnVuKClgIGFzIGEgc3VjY2Vzc2Z1bCBgdHJhbnNpdGlvblRvYFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbihnbG9iYWxzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGV0YWlsID0gZXJyb3IuZGV0YWlsO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5TVVBFUlNFREVEICYmIGVycm9yLnJlZGlyZWN0ZWQgJiYgZGV0YWlsIGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBgVHJhbnNpdGlvbi5ydW4oKWAgd2FzIHJlZGlyZWN0ZWQsIGFsbG93IHRoZSBgdHJhbnNpdGlvblRvKClgIHByb21pc2UgdG8gcmVzb2x2ZSBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgcmV0dXJuaW5nIHRoZSBwcm9taXNlIGZvciB0aGUgbmV3IChyZWRpcmVjdCkgYFRyYW5zaXRpb24ucnVuKClgLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVkaXJlY3QgPSB0cmFucy5yZWRpcmVjdChkZXRhaWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVkaXJlY3QucnVuKCkuY2F0Y2gocmVqZWN0ZWRUcmFuc2l0aW9uSGFuZGxlcihyZWRpcmVjdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gcmVqZWN0RmFjdG9yeV8xLlJlamVjdFR5cGUuQUJPUlRFRCkge1xuICAgICAgICAgICAgICAgICAgICBpc0xhdGVzdCAmJiByb3V0ZXIudXJsUm91dGVyLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gX3RoaXMuZGVmYXVsdEVycm9ySGFuZGxlcigpO1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9OyB9O1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZShjdXJyZW50UGF0aCwgcmVmKTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25Ub1Byb21pc2UgPSB0cmFuc2l0aW9uLnJ1bigpLmNhdGNoKHJlamVjdGVkVHJhbnNpdGlvbkhhbmRsZXIodHJhbnNpdGlvbikpO1xuICAgICAgICBjb21tb25fMS5zaWxlbmNlVW5jYXVnaHRJblByb21pc2UodHJhbnNpdGlvblRvUHJvbWlzZSk7IC8vIGlzc3VlICMyNjc2XG4gICAgICAgIC8vIFJldHVybiBhIHByb21pc2UgZm9yIHRoZSB0cmFuc2l0aW9uLCB3aGljaCBhbHNvIGhhcyB0aGUgdHJhbnNpdGlvbiBvYmplY3Qgb24gaXQuXG4gICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQodHJhbnNpdGlvblRvUHJvbWlzZSwgeyB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHN0YXRlICppcyogdGhlIHByb3ZpZGVkIHN0YXRlXG4gICAgICpcbiAgICAgKiBTaW1pbGFyIHRvIFtbaW5jbHVkZXNdXSBidXQgb25seSBjaGVja3MgZm9yIHRoZSBmdWxsIHN0YXRlIG5hbWUuXG4gICAgICogSWYgcGFyYW1zIGlzIHN1cHBsaWVkIHRoZW4gaXQgd2lsbCBiZSB0ZXN0ZWQgZm9yIHN0cmljdCBlcXVhbGl0eSBhZ2FpbnN0IHRoZSBjdXJyZW50XG4gICAgICogYWN0aXZlIHBhcmFtcyBvYmplY3QsIHNvIGFsbCBwYXJhbXMgbXVzdCBtYXRjaCB3aXRoIG5vbmUgbWlzc2luZyBhbmQgbm8gZXh0cmFzLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPSAnY29udGFjdHMuZGV0YWlscy5pdGVtJztcbiAgICAgKlxuICAgICAqIC8vIGFic29sdXRlIG5hbWVcbiAgICAgKiAkc3RhdGUuaXMoJ2NvbnRhY3QuZGV0YWlscy5pdGVtJyk7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pcyhjb250YWN0RGV0YWlsSXRlbVN0YXRlT2JqZWN0KTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAvLyByZWxhdGl2ZSBuYW1lICguIGFuZCBeKSwgdHlwaWNhbGx5IGZyb20gYSB0ZW1wbGF0ZVxuICAgICAqIC8vIEUuZy4gZnJvbSB0aGUgJ2NvbnRhY3RzLmRldGFpbHMnIHRlbXBsYXRlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgbmctY2xhc3M9XCJ7aGlnaGxpZ2h0ZWQ6ICRzdGF0ZS5pcygnLml0ZW0nKX1cIj5JdGVtPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgVGhlIHN0YXRlIG5hbWUgKGFic29sdXRlIG9yIHJlbGF0aXZlKSBvciBzdGF0ZSBvYmplY3QgeW91J2QgbGlrZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEEgcGFyYW0gb2JqZWN0LCBlLmcuIGB7c2VjdGlvbklkOiBzZWN0aW9uLmlkfWAsIHRoYXQgeW91J2QgbGlrZVxuICAgICAqIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKiAgIC0gYHJlbGF0aXZlYDogSWYgYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIG5hbWUgYW5kIGBvcHRpb25zLnJlbGF0aXZlYCBpcyBzZXQsIC5pcyB3aWxsXG4gICAgICogICAgIHRlc3QgcmVsYXRpdmUgdG8gYG9wdGlvbnMucmVsYXRpdmVgIHN0YXRlIChvciBuYW1lKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBpdCBpcyB0aGUgc3RhdGUuXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50IH0pO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChzdGF0ZSkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy4kY3VycmVudCAhPT0gc3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGFyYW1zKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogdHJ1ZSwgbWF0Y2hpbmdLZXlzOiBwYXJhbXMgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmVxdWFscyhzY2hlbWEsIHBhcmFtXzEuUGFyYW0udmFsdWVzKHNjaGVtYSwgcGFyYW1zKSwgdGhpcy5wYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHN0YXRlICppbmNsdWRlcyogdGhlIHByb3ZpZGVkIHN0YXRlXG4gICAgICpcbiAgICAgKiBBIG1ldGhvZCB0byBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgYWN0aXZlIHN0YXRlIGlzIGVxdWFsIHRvIG9yIGlzIHRoZSBjaGlsZCBvZiB0aGVcbiAgICAgKiBzdGF0ZSBzdGF0ZU5hbWUuIElmIGFueSBwYXJhbXMgYXJlIHBhc3NlZCB0aGVuIHRoZXkgd2lsbCBiZSB0ZXN0ZWQgZm9yIGEgbWF0Y2ggYXMgd2VsbC5cbiAgICAgKiBOb3QgYWxsIHRoZSBwYXJhbWV0ZXJzIG5lZWQgdG8gYmUgcGFzc2VkLCBqdXN0IHRoZSBvbmVzIHlvdSdkIGxpa2UgdG8gdGVzdCBmb3IgZXF1YWxpdHkuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGUgd2hlbiBgJHN0YXRlLiRjdXJyZW50Lm5hbWUgPT09ICdjb250YWN0cy5kZXRhaWxzLml0ZW0nYFxuICAgICAqIGBgYGpzXG4gICAgICogLy8gVXNpbmcgcGFydGlhbCBuYW1lc1xuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0cy5kZXRhaWxzXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0cy5kZXRhaWxzLml0ZW1cIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzLmxpc3RcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJhYm91dFwiKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIyBHbG9iIEV4YW1wbGVzIHdoZW4gYCogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPT09ICdjb250YWN0cy5kZXRhaWxzLml0ZW0udXJsJ2A6XG4gICAgICogYGBganNcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKi4qXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKipcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIioqLml0ZW0uKipcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy5pdGVtLnVybFwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLioudXJsXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKlwiKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIml0ZW0uKipcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSBBIHBhcnRpYWwgbmFtZSwgcmVsYXRpdmUgbmFtZSwgZ2xvYiBwYXR0ZXJuLFxuICAgICAqICAgb3Igc3RhdGUgb2JqZWN0IHRvIGJlIHNlYXJjaGVkIGZvciB3aXRoaW4gdGhlIGN1cnJlbnQgc3RhdGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEEgcGFyYW0gb2JqZWN0LCBlLmcuIGB7c2VjdGlvbklkOiBzZWN0aW9uLmlkfWAsXG4gICAgICogICB0aGF0IHlvdSdkIGxpa2UgdG8gdGVzdCBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuICAgICAqICAgLSBgcmVsYXRpdmVgOiBJZiBgc3RhdGVPck5hbWVgIGlzIGEgcmVsYXRpdmUgc3RhdGUgbmFtZSBhbmQgYG9wdGlvbnMucmVsYXRpdmVgIGlzIHNldCwgLmlzIHdpbGxcbiAgICAgKiAgICAgdGVzdCByZWxhdGl2ZSB0byBgb3B0aW9ucy5yZWxhdGl2ZWAgc3RhdGUgKG9yIG5hbWUpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBpdCBkb2VzIGluY2x1ZGUgdGhlIHN0YXRlXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50IH0pO1xuICAgICAgICB2YXIgZ2xvYiA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZU9yTmFtZSkgJiYgZ2xvYl8xLkdsb2IuZnJvbVN0cmluZyhzdGF0ZU9yTmFtZSk7XG4gICAgICAgIGlmIChnbG9iKSB7XG4gICAgICAgICAgICBpZiAoIWdsb2IubWF0Y2hlcyh0aGlzLiRjdXJyZW50Lm5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlT3JOYW1lID0gdGhpcy4kY3VycmVudC5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKSwgaW5jbHVkZSA9IHRoaXMuJGN1cnJlbnQuaW5jbHVkZXM7XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChzdGF0ZSkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoaW5jbHVkZVtzdGF0ZS5uYW1lXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGFyYW1zKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogdHJ1ZSwgbWF0Y2hpbmdLZXlzOiBwYXJhbXMgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmVxdWFscyhzY2hlbWEsIHBhcmFtXzEuUGFyYW0udmFsdWVzKHNjaGVtYSwgcGFyYW1zKSwgdGhpcy5wYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgVVJMIGZvciBhIHN0YXRlIGFuZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSB1cmwgZm9yIHRoZSBnaXZlbiBzdGF0ZSBwb3B1bGF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1zLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogZXhwZWN0KCRzdGF0ZS5ocmVmKFwiYWJvdXQucGVyc29uXCIsIHsgcGVyc29uOiBcImJvYlwiIH0pKS50b0VxdWFsKFwiL2Fib3V0L2JvYlwiKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSBUaGUgc3RhdGUgbmFtZSBvciBzdGF0ZSBvYmplY3QgeW91J2QgbGlrZSB0byBnZW5lcmF0ZSBhIHVybCBmcm9tLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IG9mIHBhcmFtZXRlciB2YWx1ZXMgdG8gZmlsbCB0aGUgc3RhdGUncyByZXF1aXJlZCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjb21waWxlZCBzdGF0ZSB1cmxcbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmhyZWYgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXVsdEhyZWZPcHRzID0ge1xuICAgICAgICAgICAgbG9zc3k6IHRydWUsXG4gICAgICAgICAgICBpbmhlcml0OiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgcmVsYXRpdmU6IHRoaXMuJGN1cnJlbnQsXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0SHJlZk9wdHMpO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHN0YXRlKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5pbmhlcml0KVxuICAgICAgICAgICAgcGFyYW1zID0gdGhpcy5wYXJhbXMuJGluaGVyaXQocGFyYW1zLCB0aGlzLiRjdXJyZW50LCBzdGF0ZSk7XG4gICAgICAgIHZhciBuYXYgPSBzdGF0ZSAmJiBvcHRpb25zLmxvc3N5ID8gc3RhdGUubmF2aWdhYmxlIDogc3RhdGU7XG4gICAgICAgIGlmICghbmF2IHx8IG5hdi51cmwgPT09IHVuZGVmaW5lZCB8fCBuYXYudXJsID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIudXJsUm91dGVyLmhyZWYobmF2LnVybCwgcGFyYW1zLCB7XG4gICAgICAgICAgICBhYnNvbHV0ZTogb3B0aW9ucy5hYnNvbHV0ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGRlZmF1bHQgW1t0cmFuc2l0aW9uVG9dXSBlcnJvciBoYW5kbGVyLlxuICAgICAqXG4gICAgICogVGhlIGVycm9yIGhhbmRsZXIgaXMgY2FsbGVkIHdoZW4gYSBbW1RyYW5zaXRpb25dXSBpcyByZWplY3RlZCBvciB3aGVuIGFueSBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIFRyYW5zaXRpb24uXG4gICAgICogVGhpcyBpbmNsdWRlcyBlcnJvcnMgY2F1c2VkIGJ5IHJlc29sdmVzIGFuZCB0cmFuc2l0aW9uIGhvb2tzLlxuICAgICAqXG4gICAgICogTm90ZTpcbiAgICAgKiBUaGlzIGhhbmRsZXIgZG9lcyBub3QgcmVjZWl2ZSBjZXJ0YWluIFRyYW5zaXRpb24gcmVqZWN0aW9ucy5cbiAgICAgKiBSZWRpcmVjdGVkIGFuZCBJZ25vcmVkIFRyYW5zaXRpb25zIGFyZSBub3QgY29uc2lkZXJlZCB0byBiZSBlcnJvcnMgYnkgW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV0uXG4gICAgICpcbiAgICAgKiBUaGUgYnVpbHQtaW4gZGVmYXVsdCBlcnJvciBoYW5kbGVyIGxvZ3MgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLlxuICAgICAqXG4gICAgICogWW91IGNhbiBwcm92aWRlIHlvdXIgb3duIGN1c3RvbSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogc3RhdGVTZXJ2aWNlLmRlZmF1bHRFcnJvckhhbmRsZXIoZnVuY3Rpb24oKSB7XG4gICAgICogICAvLyBEbyBub3QgbG9nIHRyYW5zaXRpb25UbyBlcnJvcnNcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGVyIGEgZ2xvYmFsIGVycm9yIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBnbG9iYWwgZXJyb3IgaGFuZGxlclxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuZGVmYXVsdEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZGVmYXVsdEVycm9ySGFuZGxlciA9IGhhbmRsZXIgfHwgdGhpcy5fZGVmYXVsdEVycm9ySGFuZGxlcik7XG4gICAgfTtcbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgYmFzZSkge1xuICAgICAgICB2YXIgcmVnID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gcmVnLmdldCgpO1xuICAgICAgICByZXR1cm4gcmVnLmdldChzdGF0ZU9yTmFtZSwgYmFzZSB8fCB0aGlzLiRjdXJyZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExhenkgbG9hZHMgYSBzdGF0ZVxuICAgICAqXG4gICAgICogRXhwbGljaXRseSBydW5zIGEgc3RhdGUncyBbW1N0YXRlRGVjbGFyYXRpb24ubGF6eUxvYWRdXSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSB0aGUgc3RhdGUgdGhhdCBzaG91bGQgYmUgbGF6eSBsb2FkZWRcbiAgICAgKiBAcGFyYW0gdHJhbnNpdGlvbiB0aGUgb3B0aW9uYWwgVHJhbnNpdGlvbiBjb250ZXh0IHRvIHVzZSAoaWYgdGhlIGxhenlMb2FkIGZ1bmN0aW9uIHJlcXVpcmVzIGFuIGluamVjdG9yLCBldGMpXG4gICAgICogTm90ZTogSWYgbm8gdHJhbnNpdGlvbiBpcyBwcm92aWRlZCwgYSBub29wIHRyYW5zaXRpb24gaXMgY3JlYXRlZCB1c2luZyB0aGUgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKiBUaGlzIG5vb3AgdHJhbnNpdGlvbiBpcyBub3QgYWN0dWFsbHkgcnVuLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIHRvIGxhenkgbG9hZFxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUubGF6eUxvYWQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXQoc3RhdGVPck5hbWUpO1xuICAgICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5sYXp5TG9hZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBsYXp5IGxvYWQgJyArIHN0YXRlT3JOYW1lKTtcbiAgICAgICAgdmFyIGN1cnJlbnRQYXRoID0gdGhpcy5nZXRDdXJyZW50UGF0aCgpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gcGF0aFV0aWxzXzEuUGF0aFV0aWxzLm1ha2VUYXJnZXRTdGF0ZSh0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5LCBjdXJyZW50UGF0aCk7XG4gICAgICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uIHx8IHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZShjdXJyZW50UGF0aCwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGxhenlMb2FkXzEubGF6eUxvYWRTdGF0ZSh0cmFuc2l0aW9uLCBzdGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVTZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVTZXJ2aWNlID0gU3RhdGVTZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVTZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBzdGF0ZVxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLyoqXG4gKiBFbmNhcHN1bGF0ZSB0aGUgdGFyZ2V0IChkZXN0aW5hdGlvbikgc3RhdGUvcGFyYW1zL29wdGlvbnMgb2YgYSBbW1RyYW5zaXRpb25dXS5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGZyZXF1ZW50bHkgdXNlZCB0byByZWRpcmVjdCBhIHRyYW5zaXRpb24gdG8gYSBuZXcgZGVzdGluYXRpb24uXG4gKlxuICogU2VlOlxuICpcbiAqIC0gW1tIb29rUmVzdWx0XV1cbiAqIC0gW1tUcmFuc2l0aW9uSG9va0ZuXV1cbiAqIC0gW1tUcmFuc2l0aW9uU2VydmljZS5vblN0YXJ0XV1cbiAqXG4gKiBUbyBjcmVhdGUgYSBgVGFyZ2V0U3RhdGVgLCB1c2UgW1tTdGF0ZVNlcnZpY2UudGFyZ2V0XV0uXG4gKlxuICogLS0tXG4gKlxuICogVGhpcyBjbGFzcyB3cmFwczpcbiAqXG4gKiAxKSBhbiBpZGVudGlmaWVyIGZvciBhIHN0YXRlXG4gKiAyKSBhIHNldCBvZiBwYXJhbWV0ZXJzXG4gKiAzKSBhbmQgdHJhbnNpdGlvbiBvcHRpb25zXG4gKiA0KSB0aGUgcmVnaXN0ZXJlZCBzdGF0ZSBvYmplY3QgKHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSlcbiAqXG4gKiBNYW55IFVJLVJvdXRlciBBUElzIHN1Y2ggYXMgW1tTdGF0ZVNlcnZpY2UuZ29dXSB0YWtlIGEgW1tTdGF0ZU9yTmFtZV1dIGFyZ3VtZW50IHdoaWNoIGNhblxuICogZWl0aGVyIGJlIGEgKnN0YXRlIG9iamVjdCogKGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0gb3IgW1tTdGF0ZU9iamVjdF1dKSBvciBhICpzdGF0ZSBuYW1lKiAoYSBzdHJpbmcpLlxuICogVGhlIGBUYXJnZXRTdGF0ZWAgY2xhc3Mgbm9ybWFsaXplcyB0aG9zZSBvcHRpb25zLlxuICpcbiAqIEEgYFRhcmdldFN0YXRlYCBtYXkgYmUgdmFsaWQgKHRoZSBzdGF0ZSBiZWluZyB0YXJnZXRlZCBleGlzdHMgaW4gdGhlIHJlZ2lzdHJ5KVxuICogb3IgaW52YWxpZCAodGhlIHN0YXRlIGJlaW5nIHRhcmdldGVkIGlzIG5vdCByZWdpc3RlcmVkKS5cbiAqL1xudmFyIFRhcmdldFN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBUYXJnZXRTdGF0ZSBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogTm90ZTogRG8gbm90IGNvbnN0cnVjdCBhIGBUYXJnZXRTdGF0ZWAgbWFudWFsbHkuXG4gICAgICogVG8gY3JlYXRlIGEgYFRhcmdldFN0YXRlYCwgdXNlIHRoZSBbW1N0YXRlU2VydmljZS50YXJnZXRdXSBmYWN0b3J5IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfc3RhdGVSZWdpc3RyeSBUaGUgU3RhdGVSZWdpc3RyeSB0byB1c2UgdG8gbG9vayB1cCB0aGUgX2RlZmluaXRpb25cbiAgICAgKiBAcGFyYW0gX2lkZW50aWZpZXIgQW4gaWRlbnRpZmllciBmb3IgYSBzdGF0ZS5cbiAgICAgKiAgICBFaXRoZXIgYSBmdWxseS1xdWFsaWZpZWQgc3RhdGUgbmFtZSwgb3IgdGhlIG9iamVjdCB1c2VkIHRvIGRlZmluZSB0aGUgc3RhdGUuXG4gICAgICogQHBhcmFtIF9wYXJhbXMgUGFyYW1ldGVycyBmb3IgdGhlIHRhcmdldCBzdGF0ZVxuICAgICAqIEBwYXJhbSBfb3B0aW9ucyBUcmFuc2l0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUYXJnZXRTdGF0ZShfc3RhdGVSZWdpc3RyeSwgX2lkZW50aWZpZXIsIF9wYXJhbXMsIF9vcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlUmVnaXN0cnkgPSBfc3RhdGVSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5faWRlbnRpZmllciA9IF9pZGVudGlmaWVyO1xuICAgICAgICB0aGlzLl9pZGVudGlmaWVyID0gX2lkZW50aWZpZXI7XG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IGNvbW1vbl8xLmV4dGVuZCh7fSwgX3BhcmFtcyB8fCB7fSk7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBjb21tb25fMS5leHRlbmQoe30sIF9vcHRpb25zIHx8IHt9KTtcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbiA9IF9zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChfaWRlbnRpZmllciwgdGhpcy5fb3B0aW9ucy5yZWxhdGl2ZSk7XG4gICAgfVxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdGhpcyBvYmplY3QgdGFyZ2V0cyAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5uYW1lKSB8fCB0aGlzLl9pZGVudGlmaWVyO1xuICAgIH07XG4gICAgLyoqIFRoZSBpZGVudGlmaWVyIHVzZWQgd2hlbiBjcmVhdGluZyB0aGlzIFRhcmdldFN0YXRlICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZGVudGlmaWVyO1xuICAgIH07XG4gICAgLyoqIFRoZSB0YXJnZXQgcGFyYW1ldGVyIHZhbHVlcyAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXM7XG4gICAgfTtcbiAgICAvKiogVGhlIGludGVybmFsIHN0YXRlIG9iamVjdCAoaWYgaXQgd2FzIGZvdW5kKSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS4kc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuICAgIH07XG4gICAgLyoqIFRoZSBpbnRlcm5hbCBzdGF0ZSBkZWNsYXJhdGlvbiAoaWYgaXQgd2FzIGZvdW5kKSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmO1xuICAgIH07XG4gICAgLyoqIFRoZSB0YXJnZXQgb3B0aW9ucyAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9O1xuICAgIC8qKiBUcnVlIGlmIHRoZSB0YXJnZXQgc3RhdGUgd2FzIGZvdW5kICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmKTtcbiAgICB9O1xuICAgIC8qKiBUcnVlIGlmIHRoZSBvYmplY3QgaXMgdmFsaWQgKi9cbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lcnJvcigpO1xuICAgIH07XG4gICAgLyoqIElmIHRoZSBvYmplY3QgaXMgaW52YWxpZCwgcmV0dXJucyB0aGUgcmVhc29uIHdoeSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLm9wdGlvbnMoKS5yZWxhdGl2ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uICYmICEhYmFzZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlTmFtZSA9IGJhc2UubmFtZSA/IGJhc2UubmFtZSA6IGJhc2U7XG4gICAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVzb2x2ZSAnXCIgKyB0aGlzLm5hbWUoKSArIFwiJyBmcm9tIHN0YXRlICdcIiArIHN0YXRlTmFtZSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGVmaW5pdGlvbilcbiAgICAgICAgICAgIHJldHVybiBcIk5vIHN1Y2ggc3RhdGUgJ1wiICsgdGhpcy5uYW1lKCkgKyBcIidcIjtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uLnNlbGYpXG4gICAgICAgICAgICByZXR1cm4gXCJTdGF0ZSAnXCIgKyB0aGlzLm5hbWUoKSArIFwiJyBoYXMgYW4gaW52YWxpZCBkZWZpbml0aW9uXCI7XG4gICAgfTtcbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIidcIiArIHRoaXMubmFtZSgpICsgXCInXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRoaXMucGFyYW1zKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSB3aGljaCB0YXJnZXRzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgICAqIFRoZSBuZXcgVGFyZ2V0U3RhdGUgaGFzIHRoZSBzYW1lIHBhcmFtZXRlciB2YWx1ZXMgYW5kIHRyYW5zaXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgbmV3IHN0YXRlIHRoYXQgc2hvdWxkIGJlIHRhcmdldGVkXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldFN0YXRlKHRoaXMuX3N0YXRlUmVnaXN0cnksIHN0YXRlLCB0aGlzLl9wYXJhbXMsIHRoaXMuX29wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyB0aGUgbmV3IHBhcmFtZXRlciB2YWx1ZXMgdG8gdXNlXG4gICAgICogQHBhcmFtIHJlcGxhY2UgV2hlbiBmYWxzZSAoZGVmYXVsdCkgdGhlIG5ldyBwYXJhbWV0ZXIgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgdmFsdWVzLlxuICAgICAqICAgICAgICAgICAgICAgIFdoZW4gdHJ1ZSB0aGUgcGFyYW1ldGVyIHZhbHVlcyB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgY3VycmVudCB2YWx1ZXMuXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCByZXBsYWNlKSB7XG4gICAgICAgIGlmIChyZXBsYWNlID09PSB2b2lkIDApIHsgcmVwbGFjZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSByZXBsYWNlID8gcGFyYW1zIDogY29tbW9uXzEuZXh0ZW5kKHt9LCB0aGlzLl9wYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUodGhpcy5fc3RhdGVSZWdpc3RyeSwgdGhpcy5faWRlbnRpZmllciwgbmV3UGFyYW1zLCB0aGlzLl9vcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgVGFyZ2V0U3RhdGUsIHVzaW5nIHRoZSBzcGVjaWZpZWQgVHJhbnNpdGlvbiBPcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG5ldyBvcHRpb25zIHRvIHVzZVxuICAgICAqIEBwYXJhbSByZXBsYWNlIFdoZW4gZmFsc2UgKGRlZmF1bHQpIHRoZSBuZXcgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAgICogICAgICAgICAgICAgICAgV2hlbiB0cnVlIHRoZSBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHJlcGxhY2UpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UgPT09IHZvaWQgMCkgeyByZXBsYWNlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG5ld09wdHMgPSByZXBsYWNlID8gb3B0aW9ucyA6IGNvbW1vbl8xLmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUodGhpcy5fc3RhdGVSZWdpc3RyeSwgdGhpcy5faWRlbnRpZmllciwgdGhpcy5fcGFyYW1zLCBuZXdPcHRzKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgYSBzdGF0ZSBwcm9wZXJ0eSB0aGF0IG1pZ2h0IGJlIGEgc3RhdGUgb3Igc3RhdGUgbmFtZSAqL1xuICAgIFRhcmdldFN0YXRlLmlzRGVmID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5zdGF0ZSAmJiAocHJlZGljYXRlc18xLmlzU3RyaW5nKG9iai5zdGF0ZSkgfHwgcHJlZGljYXRlc18xLmlzU3RyaW5nKG9iai5zdGF0ZS5uYW1lKSk7IH07XG4gICAgcmV0dXJuIFRhcmdldFN0YXRlO1xufSgpKTtcbmV4cG9ydHMuVGFyZ2V0U3RhdGUgPSBUYXJnZXRTdGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcmdldFN0YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB0cmFuc2l0aW9uXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7XG52YXIgdHJhbnNpdGlvbkhvb2tfMSA9IHJlcXVpcmUoXCIuL3RyYW5zaXRpb25Ib29rXCIpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIHJldHVybnMgYXBwbGljYWJsZSBUcmFuc2l0aW9uSG9va3MgZm9yIGEgc3BlY2lmaWMgVHJhbnNpdGlvbiBpbnN0YW5jZS5cbiAqXG4gKiBIb29rcyAoW1tSZWdpc3RlcmVkSG9va11dKSBtYXkgYmUgcmVnaXN0ZXJlZCBnbG9iYWxseSwgZS5nLiwgJHRyYW5zaXRpb25zLm9uRW50ZXIoLi4uKSwgb3IgbG9jYWxseSwgZS5nLlxuICogbXlUcmFuc2l0aW9uLm9uRW50ZXIoLi4uKS4gIFRoZSBIb29rQnVpbGRlciBmaW5kcyBtYXRjaGluZyBSZWdpc3RlcmVkSG9va3MgKHdoZXJlIHRoZSBtYXRjaCBjcml0ZXJpYSBpc1xuICogZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBvZiBob29rKVxuICpcbiAqIFRoZSBIb29rQnVpbGRlciBhbHNvIGNvbnZlcnRzIFJlZ2lzdGVyZWRIb29rcyBvYmplY3RzIHRvIFRyYW5zaXRpb25Ib29rIG9iamVjdHMsIHdoaWNoIGFyZSB1c2VkIHRvIHJ1biBhIFRyYW5zaXRpb24uXG4gKlxuICogVGhlIEhvb2tCdWlsZGVyIGNvbnN0cnVjdG9yIGlzIGdpdmVuIHRoZSAkdHJhbnNpdGlvbnMgc2VydmljZSBhbmQgYSBUcmFuc2l0aW9uIGluc3RhbmNlLiAgVGh1cywgYSBIb29rQnVpbGRlclxuICogaW5zdGFuY2UgbWF5IG9ubHkgYmUgdXNlZCBmb3Igb25lIHNwZWNpZmljIFRyYW5zaXRpb24gb2JqZWN0LiAoc2lkZSBub3RlOiB0aGUgX3RyZWVDaGFuZ2VzIGFjY2Vzc29yIGlzIHByaXZhdGVcbiAqIGluIHRoZSBUcmFuc2l0aW9uIGNsYXNzLCBzbyB3ZSBtdXN0IGFsc28gcHJvdmlkZSB0aGUgVHJhbnNpdGlvbidzIF90cmVlQ2hhbmdlcylcbiAqXG4gKi9cbnZhciBIb29rQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIb29rQnVpbGRlcih0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgfVxuICAgIEhvb2tCdWlsZGVyLnByb3RvdHlwZS5idWlsZEhvb2tzRm9yUGhhc2UgPSBmdW5jdGlvbiAocGhhc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyICR0cmFuc2l0aW9ucyA9IHRoaXMudHJhbnNpdGlvbi5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2U7XG4gICAgICAgIHJldHVybiAkdHJhbnNpdGlvbnMuX3BsdWdpbmFwaVxuICAgICAgICAgICAgLl9nZXRFdmVudHMocGhhc2UpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5idWlsZEhvb2tzKHR5cGUpOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBuZXdseSBidWlsdCBUcmFuc2l0aW9uSG9vayBvYmplY3RzLlxuICAgICAqXG4gICAgICogLSBGaW5kcyBhbGwgUmVnaXN0ZXJlZEhvb2tzIHJlZ2lzdGVyZWQgZm9yIHRoZSBnaXZlbiBgaG9va1R5cGVgIHdoaWNoIG1hdGNoZWQgdGhlIHRyYW5zaXRpb24ncyBbW1RyZWVDaGFuZ2VzXV0uXG4gICAgICogLSBGaW5kcyBbW1BhdGhOb2RlXV0gKG9yIGBQYXRoTm9kZVtdYCkgdG8gdXNlIGFzIHRoZSBUcmFuc2l0aW9uSG9vayBjb250ZXh0KHMpXG4gICAgICogLSBGb3IgZWFjaCBvZiB0aGUgW1tQYXRoTm9kZV1dcywgY3JlYXRlcyBhIFRyYW5zaXRpb25Ib29rXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9va1R5cGUgdGhlIHR5cGUgb2YgdGhlIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uLCBlLmcuLCAnb25FbnRlcicsICdvbkZpbmlzaCcuXG4gICAgICovXG4gICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkSG9va3MgPSBmdW5jdGlvbiAoaG9va1R5cGUpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb247XG4gICAgICAgIHZhciB0cmVlQ2hhbmdlcyA9IHRyYW5zaXRpb24udHJlZUNoYW5nZXMoKTtcbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIG1hdGNoaW5nIHJlZ2lzdGVyZWQgaG9va3MgZm9yIGEgZ2l2ZW4gaG9vayB0eXBlXG4gICAgICAgIHZhciBtYXRjaGluZ0hvb2tzID0gdGhpcy5nZXRNYXRjaGluZ0hvb2tzKGhvb2tUeXBlLCB0cmVlQ2hhbmdlcyk7XG4gICAgICAgIGlmICghbWF0Y2hpbmdIb29rcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdmFyIGJhc2VIb29rT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICAgICAgICBjdXJyZW50OiB0cmFuc2l0aW9uLm9wdGlvbnMoKS5jdXJyZW50LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbWFrZVRyYW5zaXRpb25Ib29rcyA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgTm9kZXMgdGhhdCBjYXVzZWQgdGhpcyBob29rIHRvIG1hdGNoLlxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBob29rLm1hdGNoZXModHJlZUNoYW5nZXMpO1xuICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBQYXRoTm9kZVtdIHRoYXQgd2lsbCBiZSB1c2VkIGFzIFRyYW5zaXRpb25Ib29rIGNvbnRleHQgb2JqZWN0c1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nTm9kZXMgPSBtYXRjaGVzW2hvb2tUeXBlLmNyaXRlcmlhTWF0Y2hQYXRoLm5hbWVdO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIEhvb2tUdXBsZXNcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ05vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBfb3B0aW9ucyA9IGNvbW1vbl8xLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6IGhvb2suYmluZCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VEYXRhOiB7IGhvb2tUeXBlOiBob29rVHlwZS5uYW1lLCBjb250ZXh0OiBub2RlIH0sXG4gICAgICAgICAgICAgICAgfSwgYmFzZUhvb2tPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBob29rVHlwZS5jcml0ZXJpYU1hdGNoUGF0aC5zY29wZSA9PT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSA/IG5vZGUuc3RhdGUuc2VsZiA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25Ib29rID0gbmV3IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2sodHJhbnNpdGlvbiwgc3RhdGUsIGhvb2ssIF9vcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBob29rOiBob29rLCBub2RlOiBub2RlLCB0cmFuc2l0aW9uSG9vazogdHJhbnNpdGlvbkhvb2sgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWF0Y2hpbmdIb29rc1xuICAgICAgICAgICAgLm1hcChtYWtlVHJhbnNpdGlvbkhvb2tzKVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5zb3J0KHR1cGxlU29ydChob29rVHlwZS5yZXZlcnNlU29ydCkpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gdHVwbGUudHJhbnNpdGlvbkhvb2s7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZHMgYWxsIFJlZ2lzdGVyZWRIb29rcyBmcm9tOlxuICAgICAqIC0gVGhlIFRyYW5zaXRpb24gb2JqZWN0IGluc3RhbmNlIGhvb2sgcmVnaXN0cnlcbiAgICAgKiAtIFRoZSBUcmFuc2l0aW9uU2VydmljZSAoJHRyYW5zaXRpb25zKSBnbG9iYWwgaG9vayByZWdpc3RyeVxuICAgICAqXG4gICAgICogd2hpY2ggbWF0Y2hlZDpcbiAgICAgKiAtIHRoZSBldmVudFR5cGVcbiAgICAgKiAtIHRoZSBtYXRjaENyaXRlcmlhICh0bywgZnJvbSwgZXhpdGluZywgcmV0YWluZWQsIGVudGVyaW5nKVxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlZCBbW1JlZ2lzdGVyZWRIb29rXV1zXG4gICAgICovXG4gICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmdldE1hdGNoaW5nSG9va3MgPSBmdW5jdGlvbiAoaG9va1R5cGUsIHRyZWVDaGFuZ2VzKSB7XG4gICAgICAgIHZhciBpc0NyZWF0ZSA9IGhvb2tUeXBlLmhvb2tQaGFzZSA9PT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEU7XG4gICAgICAgIC8vIEluc3RhbmNlIGFuZCBHbG9iYWwgaG9vayByZWdpc3RyaWVzXG4gICAgICAgIHZhciAkdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xuICAgICAgICB2YXIgcmVnaXN0cmllcyA9IGlzQ3JlYXRlID8gWyR0cmFuc2l0aW9uc10gOiBbdGhpcy50cmFuc2l0aW9uLCAkdHJhbnNpdGlvbnNdO1xuICAgICAgICByZXR1cm4gcmVnaXN0cmllc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocmVnKSB7IHJldHVybiByZWcuZ2V0SG9va3MoaG9va1R5cGUubmFtZSk7IH0pIC8vIEdldCBuYW1lZCBob29rcyBmcm9tIHJlZ2lzdHJpZXNcbiAgICAgICAgICAgIC5maWx0ZXIoY29tbW9uXzEuYXNzZXJ0UHJlZGljYXRlKHByZWRpY2F0ZXNfMS5pc0FycmF5LCBcImJyb2tlbiBldmVudCBuYW1lZDogXCIgKyBob29rVHlwZS5uYW1lKSkgLy8gU2FuaXR5IGNoZWNrXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKSAvLyBVbi1uZXN0IFJlZ2lzdGVyZWRIb29rW11bXSB0byBSZWdpc3RlcmVkSG9va1tdIGFycmF5XG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBob29rLm1hdGNoZXModHJlZUNoYW5nZXMpOyB9KTsgLy8gT25seSB0aG9zZSBzYXRpc2Z5aW5nIG1hdGNoQ3JpdGVyaWFcbiAgICB9O1xuICAgIHJldHVybiBIb29rQnVpbGRlcjtcbn0oKSk7XG5leHBvcnRzLkhvb2tCdWlsZGVyID0gSG9va0J1aWxkZXI7XG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgYSBzb3J0IGZ1bmN0aW9uIGZvciBIb29rVHVwbGVzLlxuICpcbiAqIFRoZSBzb3J0IGZ1bmN0aW9uIGZpcnN0IGNvbXBhcmVzIHRoZSBQYXRoTm9kZSBkZXB0aCAoaG93IGRlZXAgaW4gdGhlIHN0YXRlIHRyZWUgYSBub2RlIGlzKSwgdGhlbiBjb21wYXJlc1xuICogdGhlIEV2ZW50SG9vayBwcmlvcml0eS5cbiAqXG4gKiBAcGFyYW0gcmV2ZXJzZURlcHRoU29ydCBhIGJvb2xlYW4sIHdoZW4gdHJ1ZSwgcmV2ZXJzZXMgdGhlIHNvcnQgb3JkZXIgZm9yIHRoZSBub2RlIGRlcHRoXG4gKiBAcmV0dXJucyBhIHR1cGxlIHNvcnQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdHVwbGVTb3J0KHJldmVyc2VEZXB0aFNvcnQpIHtcbiAgICBpZiAocmV2ZXJzZURlcHRoU29ydCA9PT0gdm9pZCAwKSB7IHJldmVyc2VEZXB0aFNvcnQgPSBmYWxzZTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiBub2RlRGVwdGhUaGVuUHJpb3JpdHkobCwgcikge1xuICAgICAgICB2YXIgZmFjdG9yID0gcmV2ZXJzZURlcHRoU29ydCA/IC0xIDogMTtcbiAgICAgICAgdmFyIGRlcHRoRGVsdGEgPSAobC5ub2RlLnN0YXRlLnBhdGgubGVuZ3RoIC0gci5ub2RlLnN0YXRlLnBhdGgubGVuZ3RoKSAqIGZhY3RvcjtcbiAgICAgICAgcmV0dXJuIGRlcHRoRGVsdGEgIT09IDAgPyBkZXB0aERlbHRhIDogci5ob29rLnByaW9yaXR5IC0gbC5ob29rLnByaW9yaXR5O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rQnVpbGRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gc3RhdGUgbWF0Y2hlcyB0aGUgbWF0Y2hDcml0ZXJpYVxuICpcbiAqIEBoaWRkZW5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgYSBTdGF0ZSBPYmplY3QgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0gY3JpdGVyaW9uXG4gKiAtIElmIGEgc3RyaW5nLCBtYXRjaFN0YXRlIHVzZXMgdGhlIHN0cmluZyBhcyBhIGdsb2ItbWF0Y2hlciBhZ2FpbnN0IHRoZSBzdGF0ZSBuYW1lXG4gKiAtIElmIGFuIGFycmF5IChvZiBzdHJpbmdzKSwgbWF0Y2hTdGF0ZSB1c2VzIGVhY2ggc3RyaW5nIGluIHRoZSBhcnJheSBhcyBhIGdsb2ItbWF0Y2hlcnMgYWdhaW5zdCB0aGUgc3RhdGUgbmFtZVxuICogICBhbmQgcmV0dXJucyBhIHBvc2l0aXZlIG1hdGNoIGlmIGFueSBvZiB0aGUgZ2xvYnMgbWF0Y2guXG4gKiAtIElmIGEgZnVuY3Rpb24sIG1hdGNoU3RhdGUgY2FsbHMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN0YXRlIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0IGlzIHRydXRoeS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBtYXRjaFN0YXRlKHN0YXRlLCBjcml0ZXJpb24pIHtcbiAgICB2YXIgdG9NYXRjaCA9IGNvbW1vbl8xLmlzU3RyaW5nKGNyaXRlcmlvbikgPyBbY3JpdGVyaW9uXSA6IGNyaXRlcmlvbjtcbiAgICBmdW5jdGlvbiBtYXRjaEdsb2JzKF9zdGF0ZSkge1xuICAgICAgICB2YXIgZ2xvYlN0cmluZ3MgPSB0b01hdGNoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsb2JTdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ2xvYiA9IG5ldyBjb21tb25fMS5HbG9iKGdsb2JTdHJpbmdzW2ldKTtcbiAgICAgICAgICAgIGlmICgoZ2xvYiAmJiBnbG9iLm1hdGNoZXMoX3N0YXRlLm5hbWUpKSB8fCAoIWdsb2IgJiYgZ2xvYlN0cmluZ3NbaV0gPT09IF9zdGF0ZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG1hdGNoRm4gPSAoY29tbW9uXzEuaXNGdW5jdGlvbih0b01hdGNoKSA/IHRvTWF0Y2ggOiBtYXRjaEdsb2JzKTtcbiAgICByZXR1cm4gISFtYXRjaEZuKHN0YXRlKTtcbn1cbmV4cG9ydHMubWF0Y2hTdGF0ZSA9IG1hdGNoU3RhdGU7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogVGhlIHJlZ2lzdHJhdGlvbiBkYXRhIGZvciBhIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbiBob29rXG4gKi9cbnZhciBSZWdpc3RlcmVkSG9vayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkSG9vayh0cmFuU3ZjLCBldmVudFR5cGUsIGNhbGxiYWNrLCBtYXRjaENyaXRlcmlhLCByZW1vdmVIb29rRnJvbVJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMudHJhblN2YyA9IHRyYW5TdmM7XG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMubWF0Y2hDcml0ZXJpYSA9IG1hdGNoQ3JpdGVyaWE7XG4gICAgICAgIHRoaXMucmVtb3ZlSG9va0Zyb21SZWdpc3RyeSA9IHJlbW92ZUhvb2tGcm9tUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuaW52b2tlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IG9wdGlvbnMucHJpb3JpdHkgfHwgMDtcbiAgICAgICAgdGhpcy5iaW5kID0gb3B0aW9ucy5iaW5kIHx8IG51bGw7XG4gICAgICAgIHRoaXMuaW52b2tlTGltaXQgPSBvcHRpb25zLmludm9rZUxpbWl0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXRjaGluZyBbW1BhdGhOb2RlXV1zXG4gICAgICpcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBbW1BhdGhOb2RlXV1zLCBhbmQgYSBbW0hvb2tNYXRjaENyaXRlcmlvbl1dLCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmdcbiAgICAgKiB0aGUgW1tQYXRoTm9kZV1dcyB0aGF0IHRoZSBjcml0ZXJpYSBtYXRjaGVzLCBvciBgbnVsbGAgaWYgdGhlcmUgd2VyZSBubyBtYXRjaGluZyBub2Rlcy5cbiAgICAgKlxuICAgICAqIFJldHVybmluZyBgbnVsbGAgaXMgc2lnbmlmaWNhbnQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgZGVmYXVsdFxuICAgICAqIFwibWF0Y2gtYWxsIGNyaXRlcmlvbiB2YWx1ZVwiIG9mIGB0cnVlYCBjb21wYXJlZCB0byBhIGAoKSA9PiB0cnVlYCBmdW5jdGlvbixcbiAgICAgKiB3aGVuIHRoZSBub2RlcyBpcyBhbiBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHRvIGFsbG93IGEgdHJhbnNpdGlvbiBtYXRjaCBjcml0ZXJpYSBvZiBgZW50ZXJpbmc6IHRydWVgXG4gICAgICogdG8gc3RpbGwgbWF0Y2ggYSB0cmFuc2l0aW9uLCBldmVuIHdoZW4gYGVudGVyaW5nID09PSBbXWAuICBDb250cmFzdCB0aGF0XG4gICAgICogd2l0aCBgZW50ZXJpbmc6IChzdGF0ZSkgPT4gdHJ1ZWAgd2hpY2ggb25seSBtYXRjaGVzIHdoZW4gYSBzdGF0ZSBpcyBhY3R1YWxseVxuICAgICAqIGJlaW5nIGVudGVyZWQuXG4gICAgICovXG4gICAgUmVnaXN0ZXJlZEhvb2sucHJvdG90eXBlLl9tYXRjaGluZ05vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBjcml0ZXJpb24pIHtcbiAgICAgICAgaWYgKGNyaXRlcmlvbiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBtYXRjaFN0YXRlKG5vZGUuc3RhdGUsIGNyaXRlcmlvbik7IH0pO1xuICAgICAgICByZXR1cm4gbWF0Y2hpbmcubGVuZ3RoID8gbWF0Y2hpbmcgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCBtYXRjaCBjcml0ZXJpYSAoYWxsIGB0cnVlYClcbiAgICAgKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGhhcyBhbGwgdGhlIGNyaXRlcmlhIG1hdGNoIHBhdGhzIGFzIGtleXMgYW5kIGB0cnVlYCBhcyB2YWx1ZXMsIGkuZS46XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHtcbiAgICAgKiAgIHRvOiB0cnVlLFxuICAgICAqICAgZnJvbTogdHJ1ZSxcbiAgICAgKiAgIGVudGVyaW5nOiB0cnVlLFxuICAgICAqICAgZXhpdGluZzogdHJ1ZSxcbiAgICAgKiAgIHJldGFpbmVkOiB0cnVlLFxuICAgICAqIH1cbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuX2dldERlZmF1bHRNYXRjaENyaXRlcmlhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwT2JqKHRoaXMudHJhblN2Yy5fcGx1Z2luYXBpLl9nZXRQYXRoVHlwZXMoKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIG1hdGNoaW5nIG5vZGVzIGFzIFtbSU1hdGNoaW5nTm9kZXNdXVxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgSU1hdGNoaW5nTm9kZXMgb2JqZWN0IGZyb20gdGhlIFRyYW5zaXRpb25Ib29rVHlwZXMgdGhhdCBpcyByb3VnaGx5IGVxdWl2YWxlbnQgdG86XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCBtYXRjaGVzOiBJTWF0Y2hpbmdOb2RlcyA9IHtcbiAgICAgKiAgIHRvOiAgICAgICBfbWF0Y2hpbmdOb2RlcyhbdGFpbCh0cmVlQ2hhbmdlcy50byldLCAgIG1jLnRvKSxcbiAgICAgKiAgIGZyb206ICAgICBfbWF0Y2hpbmdOb2RlcyhbdGFpbCh0cmVlQ2hhbmdlcy5mcm9tKV0sIG1jLmZyb20pLFxuICAgICAqICAgZXhpdGluZzogIF9tYXRjaGluZ05vZGVzKHRyZWVDaGFuZ2VzLmV4aXRpbmcsICAgICAgbWMuZXhpdGluZyksXG4gICAgICogICByZXRhaW5lZDogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMucmV0YWluZWQsICAgICBtYy5yZXRhaW5lZCksXG4gICAgICogICBlbnRlcmluZzogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMuZW50ZXJpbmcsICAgICBtYy5lbnRlcmluZyksXG4gICAgICogfTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuX2dldE1hdGNoaW5nTm9kZXMgPSBmdW5jdGlvbiAodHJlZUNoYW5nZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gY29tbW9uXzEuZXh0ZW5kKHRoaXMuX2dldERlZmF1bHRNYXRjaENyaXRlcmlhKCksIHRoaXMubWF0Y2hDcml0ZXJpYSk7XG4gICAgICAgIHZhciBwYXRocyA9IGNvbW1vbl8xLnZhbHVlcyh0aGlzLnRyYW5TdmMuX3BsdWdpbmFwaS5fZ2V0UGF0aFR5cGVzKCkpO1xuICAgICAgICByZXR1cm4gcGF0aHMucmVkdWNlKGZ1bmN0aW9uIChtbiwgcGF0aHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFNUQVRFIHNjb3BlIGNyaXRlcmlhIG1hdGNoZXMgYWdhaW5zdCBldmVyeSBub2RlIGluIHRoZSBwYXRoLlxuICAgICAgICAgICAgLy8gVFJBTlNJVElPTiBzY29wZSBjcml0ZXJpYSBtYXRjaGVzIGFnYWluc3Qgb25seSB0aGUgbGFzdCBub2RlIGluIHRoZSBwYXRoXG4gICAgICAgICAgICB2YXIgaXNTdGF0ZUhvb2sgPSBwYXRodHlwZS5zY29wZSA9PT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdHJlZUNoYW5nZXNbcGF0aHR5cGUubmFtZV0gfHwgW107XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBpc1N0YXRlSG9vayA/IHBhdGggOiBbY29tbW9uXzEudGFpbChwYXRoKV07XG4gICAgICAgICAgICBtbltwYXRodHlwZS5uYW1lXSA9IF90aGlzLl9tYXRjaGluZ05vZGVzKG5vZGVzLCBjcml0ZXJpYVtwYXRodHlwZS5uYW1lXSk7XG4gICAgICAgICAgICByZXR1cm4gbW47XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhpcyBob29rJ3MgW1ttYXRjaENyaXRlcmlhXV0gbWF0Y2ggdGhlIGdpdmVuIFtbVHJlZUNoYW5nZXNdXVxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gSU1hdGNoaW5nTm9kZXMgb2JqZWN0LCBvciBudWxsLiBJZiBhbiBJTWF0Y2hpbmdOb2RlcyBvYmplY3QgaXMgcmV0dXJuZWQsIGl0cyB2YWx1ZXNcbiAgICAgKiBhcmUgdGhlIG1hdGNoaW5nIFtbUGF0aE5vZGVdXXMgZm9yIGVhY2ggW1tIb29rTWF0Y2hDcml0ZXJpb25dXSAodG8sIGZyb20sIGV4aXRpbmcsIHJldGFpbmVkLCBlbnRlcmluZylcbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uICh0cmVlQ2hhbmdlcykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IHRoaXMuX2dldE1hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMpO1xuICAgICAgICAvLyBDaGVjayBpZiBhbGwgdGhlIGNyaXRlcmlhIG1hdGNoZWQgdGhlIFRyZWVDaGFuZ2VzIG9iamVjdFxuICAgICAgICB2YXIgYWxsTWF0Y2hlZCA9IGNvbW1vbl8xLnZhbHVlcyhtYXRjaGVzKS5ldmVyeShjb21tb25fMS5pZGVudGl0eSk7XG4gICAgICAgIHJldHVybiBhbGxNYXRjaGVkID8gbWF0Y2hlcyA6IG51bGw7XG4gICAgfTtcbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuZGVyZWdpc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVIb29rRnJvbVJlZ2lzdHJ5KHRoaXMpO1xuICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ2lzdGVyZWRIb29rO1xufSgpKTtcbmV4cG9ydHMuUmVnaXN0ZXJlZEhvb2sgPSBSZWdpc3RlcmVkSG9vaztcbi8qKiBAaGlkZGVuIFJldHVybiBhIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBvZiB0aGUgcmVxdWVzdGVkIHR5cGUuICovXG5mdW5jdGlvbiBtYWtlRXZlbnQocmVnaXN0cnksIHRyYW5zaXRpb25TZXJ2aWNlLCBldmVudFR5cGUpIHtcbiAgICAvLyBDcmVhdGUgdGhlIG9iamVjdCB3aGljaCBob2xkcyB0aGUgcmVnaXN0ZXJlZCB0cmFuc2l0aW9uIGhvb2tzLlxuICAgIHZhciBfcmVnaXN0ZXJlZEhvb2tzID0gKHJlZ2lzdHJ5Ll9yZWdpc3RlcmVkSG9va3MgPSByZWdpc3RyeS5fcmVnaXN0ZXJlZEhvb2tzIHx8IHt9KTtcbiAgICB2YXIgaG9va3MgPSAoX3JlZ2lzdGVyZWRIb29rc1tldmVudFR5cGUubmFtZV0gPSBbXSk7XG4gICAgdmFyIHJlbW92ZUhvb2tGbiA9IGNvbW1vbl8xLnJlbW92ZUZyb20oaG9va3MpO1xuICAgIC8vIENyZWF0ZSBob29rIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBvbiB0aGUgSUhvb2tSZWdpc3RyeSBmb3IgdGhlIGV2ZW50XG4gICAgcmVnaXN0cnlbZXZlbnRUeXBlLm5hbWVdID0gaG9va1JlZ2lzdHJhdGlvbkZuO1xuICAgIGZ1bmN0aW9uIGhvb2tSZWdpc3RyYXRpb25GbihtYXRjaE9iamVjdCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHJlZ2lzdGVyZWRIb29rID0gbmV3IFJlZ2lzdGVyZWRIb29rKHRyYW5zaXRpb25TZXJ2aWNlLCBldmVudFR5cGUsIGNhbGxiYWNrLCBtYXRjaE9iamVjdCwgcmVtb3ZlSG9va0ZuLCBvcHRpb25zKTtcbiAgICAgICAgaG9va3MucHVzaChyZWdpc3RlcmVkSG9vayk7XG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkSG9vay5kZXJlZ2lzdGVyLmJpbmQocmVnaXN0ZXJlZEhvb2spO1xuICAgIH1cbiAgICByZXR1cm4gaG9va1JlZ2lzdHJhdGlvbkZuO1xufVxuZXhwb3J0cy5tYWtlRXZlbnQgPSBtYWtlRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rUmVnaXN0cnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiAjIFRyYW5zaXRpb24gc3Vic3lzdGVtXG4gKlxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgQVBJcyByZWxhdGVkIHRvIGEgVHJhbnNpdGlvbi5cbiAqXG4gKiBTZWU6XG4gKiAtIFtbVHJhbnNpdGlvblNlcnZpY2VdXVxuICogLSBbW1RyYW5zaXRpb25dXVxuICogLSBbW0hvb2tGbl1dLCBbW1RyYW5zaXRpb25Ib29rRm5dXSwgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSwgW1tIb29rTWF0Y2hDcml0ZXJpYV1dLCBbW0hvb2tSZXN1bHRdXVxuICpcbiAqIEBjb3JlYXBpXG4gKiBAcHJlZmVycmVkXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ob29rQnVpbGRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ob29rUmVnaXN0cnlcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVqZWN0RmFjdG9yeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmFuc2l0aW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zaXRpb25Ib29rXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zaXRpb25FdmVudFR5cGVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNpdGlvblNlcnZpY2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVHJhbnNpdGlvbkhvb2tQaGFzZTtcbihmdW5jdGlvbiAoVHJhbnNpdGlvbkhvb2tQaGFzZSkge1xuICAgIFRyYW5zaXRpb25Ib29rUGhhc2VbVHJhbnNpdGlvbkhvb2tQaGFzZVtcIkNSRUFURVwiXSA9IDBdID0gXCJDUkVBVEVcIjtcbiAgICBUcmFuc2l0aW9uSG9va1BoYXNlW1RyYW5zaXRpb25Ib29rUGhhc2VbXCJCRUZPUkVcIl0gPSAxXSA9IFwiQkVGT1JFXCI7XG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiUlVOXCJdID0gMl0gPSBcIlJVTlwiO1xuICAgIFRyYW5zaXRpb25Ib29rUGhhc2VbVHJhbnNpdGlvbkhvb2tQaGFzZVtcIlNVQ0NFU1NcIl0gPSAzXSA9IFwiU1VDQ0VTU1wiO1xuICAgIFRyYW5zaXRpb25Ib29rUGhhc2VbVHJhbnNpdGlvbkhvb2tQaGFzZVtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XG59KShUcmFuc2l0aW9uSG9va1BoYXNlID0gZXhwb3J0cy5UcmFuc2l0aW9uSG9va1BoYXNlIHx8IChleHBvcnRzLlRyYW5zaXRpb25Ib29rUGhhc2UgPSB7fSkpO1xudmFyIFRyYW5zaXRpb25Ib29rU2NvcGU7XG4oZnVuY3Rpb24gKFRyYW5zaXRpb25Ib29rU2NvcGUpIHtcbiAgICBUcmFuc2l0aW9uSG9va1Njb3BlW1RyYW5zaXRpb25Ib29rU2NvcGVbXCJUUkFOU0lUSU9OXCJdID0gMF0gPSBcIlRSQU5TSVRJT05cIjtcbiAgICBUcmFuc2l0aW9uSG9va1Njb3BlW1RyYW5zaXRpb25Ib29rU2NvcGVbXCJTVEFURVwiXSA9IDFdID0gXCJTVEFURVwiO1xufSkoVHJhbnNpdGlvbkhvb2tTY29wZSA9IGV4cG9ydHMuVHJhbnNpdGlvbkhvb2tTY29wZSB8fCAoZXhwb3J0cy5UcmFuc2l0aW9uSG9va1Njb3BlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCIvKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIFJlamVjdFR5cGU7XG4oZnVuY3Rpb24gKFJlamVjdFR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBIG5ldyB0cmFuc2l0aW9uIHN1cGVyc2VkZWQgdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBXaGlsZSB0aGlzIHRyYW5zaXRpb24gd2FzIHJ1bm5pbmcsIGEgbmV3IHRyYW5zaXRpb24gc3RhcnRlZC5cbiAgICAgKiBUaGlzIHRyYW5zaXRpb24gaXMgY2FuY2VsbGVkIGJlY2F1c2UgaXQgd2FzIHN1cGVyc2VkZWQgYnkgbmV3IHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgUmVqZWN0VHlwZVtSZWplY3RUeXBlW1wiU1VQRVJTRURFRFwiXSA9IDJdID0gXCJTVVBFUlNFREVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zaXRpb24gd2FzIGFib3J0ZWRcbiAgICAgKlxuICAgICAqIFRoZSB0cmFuc2l0aW9uIHdhcyBhYm9ydGVkIGJ5IGEgaG9vayB3aGljaCByZXR1cm5lZCBgZmFsc2VgXG4gICAgICovXG4gICAgUmVqZWN0VHlwZVtSZWplY3RUeXBlW1wiQUJPUlRFRFwiXSA9IDNdID0gXCJBQk9SVEVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zaXRpb24gd2FzIGludmFsaWRcbiAgICAgKlxuICAgICAqIFRoZSB0cmFuc2l0aW9uIHdhcyBuZXZlciBzdGFydGVkIGJlY2F1c2UgaXQgd2FzIGludmFsaWRcbiAgICAgKi9cbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJJTlZBTElEXCJdID0gNF0gPSBcIklOVkFMSURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNpdGlvbiB3YXMgaWdub3JlZFxuICAgICAqXG4gICAgICogVGhlIHRyYW5zaXRpb24gd2FzIGlnbm9yZWQgYmVjYXVzZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEVpdGhlcjpcbiAgICAgKlxuICAgICAqIC0gVGhlIHRyYW5zaXRpb24gaXMgdGFyZ2V0aW5nIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBwYXJhbWV0ZXIgdmFsdWVzXG4gICAgICogLSBUaGUgdHJhbnNpdGlvbiBpcyB0YXJnZXRpbmcgdGhlIHNhbWUgc3RhdGUgYW5kIHBhcmFtZXRlciB2YWx1ZXMgYXMgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgUmVqZWN0VHlwZVtSZWplY3RUeXBlW1wiSUdOT1JFRFwiXSA9IDVdID0gXCJJR05PUkVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zaXRpb24gZXJyb3JlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgZ2VuZXJhbGx5IG1lYW5zIGEgaG9vayB0aHJldyBhbiBlcnJvciBvciByZXR1cm5lZCBhIHJlamVjdGVkIHByb21pc2VcbiAgICAgKi9cbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJFUlJPUlwiXSA9IDZdID0gXCJFUlJPUlwiO1xufSkoUmVqZWN0VHlwZSA9IGV4cG9ydHMuUmVqZWN0VHlwZSB8fCAoZXhwb3J0cy5SZWplY3RUeXBlID0ge30pKTtcbi8qKiBAaGlkZGVuICovXG52YXIgaWQgPSAwO1xudmFyIFJlamVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWplY3Rpb24odHlwZSwgbWVzc2FnZSwgZGV0YWlsKSB7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuJGlkID0gaWQrKztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5kZXRhaWwgPSBkZXRhaWw7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iaiBpcyBhIHJlamVjdGVkIHByb21pc2UgY3JlYXRlZCBmcm9tIHRoZSBgYXNQcm9taXNlYCBmYWN0b3J5ICovXG4gICAgUmVqZWN0aW9uLmlzUmVqZWN0aW9uUHJvbWlzZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgaG9mXzEuaXMoUmVqZWN0aW9uKShvYmouX3RyYW5zaXRpb25SZWplY3Rpb24pO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIHRyYW5zaXRpb24gc3VwZXJzZWRlZCAqL1xuICAgIFJlamVjdGlvbi5zdXBlcnNlZGVkID0gZnVuY3Rpb24gKGRldGFpbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdUaGUgdHJhbnNpdGlvbiBoYXMgYmVlbiBzdXBlcnNlZGVkIGJ5IGEgZGlmZmVyZW50IHRyYW5zaXRpb24nO1xuICAgICAgICB2YXIgcmVqZWN0aW9uID0gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLlNVUEVSU0VERUQsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVkaXJlY3RlZCkge1xuICAgICAgICAgICAgcmVqZWN0aW9uLnJlZGlyZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3Rpb247XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gcmVkaXJlY3RlZCB0cmFuc2l0aW9uICovXG4gICAgUmVqZWN0aW9uLnJlZGlyZWN0ZWQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICAgIHJldHVybiBSZWplY3Rpb24uc3VwZXJzZWRlZChkZXRhaWwsIHsgcmVkaXJlY3RlZDogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBpbnZhbGlkIHRyYW5zaXRpb24gKi9cbiAgICBSZWplY3Rpb24uaW52YWxpZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnVGhpcyB0cmFuc2l0aW9uIGlzIGludmFsaWQnO1xuICAgICAgICByZXR1cm4gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLklOVkFMSUQsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gaWdub3JlZCB0cmFuc2l0aW9uICovXG4gICAgUmVqZWN0aW9uLmlnbm9yZWQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ1RoZSB0cmFuc2l0aW9uIHdhcyBpZ25vcmVkJztcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5JR05PUkVELCBtZXNzYWdlLCBkZXRhaWwpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGFib3J0ZWQgdHJhbnNpdGlvbiAqL1xuICAgIFJlamVjdGlvbi5hYm9ydGVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdUaGUgdHJhbnNpdGlvbiBoYXMgYmVlbiBhYm9ydGVkJztcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5BQk9SVEVELCBtZXNzYWdlLCBkZXRhaWwpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGFib3J0ZWQgdHJhbnNpdGlvbiAqL1xuICAgIFJlamVjdGlvbi5lcnJvcmVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdUaGUgdHJhbnNpdGlvbiBlcnJvcmVkJztcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5FUlJPUiwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBSZWplY3Rpb25cbiAgICAgKlxuICAgICAqIE5vcm1hbGl6ZXMgYSB2YWx1ZSBhcyBhIFJlamVjdGlvbi5cbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSBhIFJlamVjdGlvbiwgcmV0dXJucyBpdC5cbiAgICAgKiBPdGhlcndpc2UsIHdyYXBzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBhcyBhIFJlamVjdGlvbiAoUmVqZWN0aW9uIHR5cGU6IEVSUk9SKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGBkZXRhaWxgIGlmIGl0IGlzIGFscmVhZHkgYSBgUmVqZWN0aW9uYCwgZWxzZSByZXR1cm5zIGFuIEVSUk9SIFJlamVjdGlvbi5cbiAgICAgKi9cbiAgICBSZWplY3Rpb24ubm9ybWFsaXplID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICByZXR1cm4gaG9mXzEuaXMoUmVqZWN0aW9uKShkZXRhaWwpID8gZGV0YWlsIDogUmVqZWN0aW9uLmVycm9yZWQoZGV0YWlsKTtcbiAgICB9O1xuICAgIFJlamVjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXRhaWxTdHJpbmcgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gKGQgJiYgZC50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA/IGQudG9TdHJpbmcoKSA6IHN0cmluZ3NfMS5zdHJpbmdpZnkoZCkpOyB9O1xuICAgICAgICB2YXIgZGV0YWlsID0gZGV0YWlsU3RyaW5nKHRoaXMuZGV0YWlsKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgJGlkID0gX2EuJGlkLCB0eXBlID0gX2EudHlwZSwgbWVzc2FnZSA9IF9hLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBcIlRyYW5zaXRpb24gUmVqZWN0aW9uKCRpZDogXCIgKyAkaWQgKyBcIiB0eXBlOiBcIiArIHR5cGUgKyBcIiwgbWVzc2FnZTogXCIgKyBtZXNzYWdlICsgXCIsIGRldGFpbDogXCIgKyBkZXRhaWwgKyBcIilcIjtcbiAgICB9O1xuICAgIFJlamVjdGlvbi5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGNvbW1vbl8xLnNpbGVudFJlamVjdGlvbih0aGlzKSwgeyBfdHJhbnNpdGlvblJlamVjdGlvbjogdGhpcyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZWplY3Rpb247XG59KCkpO1xuZXhwb3J0cy5SZWplY3Rpb24gPSBSZWplY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWplY3RGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB0cmFuc2l0aW9uXG4gKi9cbi8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7IC8vIGhhcyBvciBpcyB1c2luZ1xudmFyIHRyYW5zaXRpb25Ib29rXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uSG9va1wiKTtcbnZhciBob29rUmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL2hvb2tSZWdpc3RyeVwiKTtcbnZhciBob29rQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vaG9va0J1aWxkZXJcIik7XG52YXIgcGF0aFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoVXRpbHNcIik7XG52YXIgcGFyYW1fMSA9IHJlcXVpcmUoXCIuLi9wYXJhbXMvcGFyYW1cIik7XG52YXIgcmVzb2x2YWJsZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2YWJsZVwiKTtcbnZhciByZXNvbHZlQ29udGV4dF8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHRcIik7XG52YXIgcmVqZWN0RmFjdG9yeV8xID0gcmVxdWlyZShcIi4vcmVqZWN0RmFjdG9yeVwiKTtcbi8qKiBAaGlkZGVuICovXG52YXIgc3RhdGVTZWxmID0gaG9mXzEucHJvcCgnc2VsZicpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNpdGlvbiBiZXR3ZWVuIHR3byBzdGF0ZXMuXG4gKlxuICogV2hlbiBuYXZpZ2F0aW5nIHRvIGEgc3RhdGUsIHdlIGFyZSB0cmFuc2l0aW9uaW5nICoqZnJvbSoqIHRoZSBjdXJyZW50IHN0YXRlICoqdG8qKiB0aGUgbmV3IHN0YXRlLlxuICpcbiAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGFsbCBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0by9mcm9tIHN0YXRlcywgcGFyYW1ldGVycywgcmVzb2x2ZXMuXG4gKiBJdCBoYXMgaW5mb3JtYXRpb24gYWJvdXQgYWxsIHN0YXRlcyBiZWluZyBlbnRlcmVkIGFuZCBleGl0ZWQgYXMgYSByZXN1bHQgb2YgdGhlIHRyYW5zaXRpb24uXG4gKi9cbnZhciBUcmFuc2l0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHJhbnNpdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGFyZ2V0IHN0YXRlIGlzIG5vdCB2YWxpZCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbVBhdGggVGhlIHBhdGggb2YgW1tQYXRoTm9kZV1dcyBmcm9tIHdoaWNoIHRoZSB0cmFuc2l0aW9uIGlzIGxlYXZpbmcuICBUaGUgbGFzdCBub2RlIGluIHRoZSBgZnJvbVBhdGhgXG4gICAgICogICAgICAgIGVuY2Fwc3VsYXRlcyB0aGUgXCJmcm9tIHN0YXRlXCIuXG4gICAgICogQHBhcmFtIHRhcmdldFN0YXRlIFRoZSB0YXJnZXQgc3RhdGUgYW5kIHBhcmFtZXRlcnMgYmVpbmcgdHJhbnNpdGlvbmVkIHRvIChhbHNvLCB0aGUgdHJhbnNpdGlvbiBvcHRpb25zKVxuICAgICAqIEBwYXJhbSByb3V0ZXIgVGhlIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb24oZnJvbVBhdGgsIHRhcmdldFN0YXRlLCByb3V0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fZGVmZXJyZWQgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5kZWZlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBwcm9taXNlIGlzIHJlc29sdmVkIG9yIHJlamVjdGVkIGJhc2VkIG9uIHRoZSBvdXRjb21lIG9mIHRoZSBUcmFuc2l0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHRoZSB0cmFuc2l0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkXG4gICAgICAgICAqIFdoZW4gdGhlIHRyYW5zaXRpb24gaXMgdW5zdWNjZXNzZnVsLCB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIHRoZSBbW1JlamVjdGlvbl1dIG9yIGphdmFzY3JpcHQgZXJyb3JcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMuX2RlZmVycmVkLnByb21pc2U7XG4gICAgICAgIC8qKiBAaGlkZGVuIEhvbGRzIHRoZSBob29rIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgc3VjaCBhcyB0aG9zZSBwYXNzZWQgdG8gVHJhbnNpdGlvbi5vblN0YXJ0KCkgKi9cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZEhvb2tzID0ge307XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2hvb2tCdWlsZGVyID0gbmV3IGhvb2tCdWlsZGVyXzEuSG9va0J1aWxkZXIodGhpcyk7XG4gICAgICAgIC8qKiBDaGVja3MgaWYgdGhpcyB0cmFuc2l0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUvcnVubmluZy4gKi9cbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb24gPT09IF90aGlzOyB9O1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5fdGFyZ2V0U3RhdGUgPSB0YXJnZXRTdGF0ZTtcbiAgICAgICAgaWYgKCF0YXJnZXRTdGF0ZS52YWxpZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFyZ2V0U3RhdGUuZXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VycmVudCgpIGlzIGFzc3VtZWQgdG8gY29tZSBmcm9tIHRhcmdldFN0YXRlLm9wdGlvbnMsIGJ1dCBwcm92aWRlIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gb3RoZXJ3aXNlLlxuICAgICAgICB0aGlzLl9vcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHsgY3VycmVudDogaG9mXzEudmFsKHRoaXMpIH0sIHRhcmdldFN0YXRlLm9wdGlvbnMoKSk7XG4gICAgICAgIHRoaXMuJGlkID0gcm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLl90cmFuc2l0aW9uQ291bnQrKztcbiAgICAgICAgdmFyIHRvUGF0aCA9IHBhdGhVdGlsc18xLlBhdGhVdGlscy5idWlsZFRvUGF0aChmcm9tUGF0aCwgdGFyZ2V0U3RhdGUpO1xuICAgICAgICB0aGlzLl90cmVlQ2hhbmdlcyA9IHBhdGhVdGlsc18xLlBhdGhVdGlscy50cmVlQ2hhbmdlcyhmcm9tUGF0aCwgdG9QYXRoLCB0aGlzLl9vcHRpb25zLnJlbG9hZFN0YXRlKTtcbiAgICAgICAgdGhpcy5jcmVhdGVUcmFuc2l0aW9uSG9va1JlZ0ZucygpO1xuICAgICAgICB2YXIgb25DcmVhdGVIb29rcyA9IHRoaXMuX2hvb2tCdWlsZGVyLmJ1aWxkSG9va3NGb3JQaGFzZShpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLkNSRUFURSk7XG4gICAgICAgIHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suaW52b2tlSG9va3Mob25DcmVhdGVIb29rcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7XG4gICAgICAgIHRoaXMuYXBwbHlWaWV3Q29uZmlncyhyb3V0ZXIpO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uQmVmb3JlID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkV4aXQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uUmV0YWluID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkVudGVyID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGhpZGRlblxuICAgICAqIENyZWF0ZXMgdGhlIHRyYW5zaXRpb24tbGV2ZWwgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb25zXG4gICAgICogKHdoaWNoIGNhbiB0aGVuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgaG9va3MpXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuY3JlYXRlVHJhbnNpdGlvbkhvb2tSZWdGbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLl9wbHVnaW5hcGlcbiAgICAgICAgICAgIC5fZ2V0RXZlbnRzKClcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUuaG9va1BoYXNlICE9PSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLkNSRUFURTsgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBob29rUmVnaXN0cnlfMS5tYWtlRXZlbnQoX3RoaXMsIF90aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZSwgdHlwZSk7IH0pO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmdldEhvb2tzID0gZnVuY3Rpb24gKGhvb2tOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkSG9va3NbaG9va05hbWVdO1xuICAgIH07XG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuYXBwbHlWaWV3Q29uZmlncyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nU3RhdGVzID0gdGhpcy5fdHJlZUNoYW5nZXMuZW50ZXJpbmcubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnN0YXRlOyB9KTtcbiAgICAgICAgcGF0aFV0aWxzXzEuUGF0aFV0aWxzLmFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLiR2aWV3LCB0aGlzLl90cmVlQ2hhbmdlcy50bywgZW50ZXJpbmdTdGF0ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgaW50ZXJuYWwgZnJvbSBbU3RhdGVdIG9iamVjdFxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLiRmcm9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbCh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tKS5zdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIGludGVybmFsIHRvIFtTdGF0ZV0gb2JqZWN0XG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuJHRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbCh0aGlzLl90cmVlQ2hhbmdlcy50bykuc3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBcImZyb20gc3RhdGVcIlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBjb21pbmcgKmZyb20qLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyAoXCJmcm9tIHN0YXRlXCIpLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcm9tKCkuc2VsZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFwidG8gc3RhdGVcIlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBnb2luZyAqdG8qLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyB0YXJnZXQgc3RhdGUgKFwidG8gc3RhdGVcIikuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0bygpLnNlbGY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBUYXJnZXQgU3RhdGVcbiAgICAgKlxuICAgICAqIEEgdHJhbnNpdGlvbidzIFtbVGFyZ2V0U3RhdGVdXSBlbmNhcHN1bGF0ZXMgdGhlIFtbdG9dXSBzdGF0ZSwgdGhlIFtbcGFyYW1zXV0sIGFuZCB0aGUgW1tvcHRpb25zXV0gYXMgYSBzaW5nbGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIFtbVGFyZ2V0U3RhdGVdXSBvZiB0aGlzIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50YXJnZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFN0YXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byB0cmFuc2l0aW9ucyBhcmUgZXF1aXZhbGVudC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGNvbXBhcmUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbHNvIGNvbXBhcmUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXMoeyB0bzogY29tcGFyZS4kdG8oKS5uYW1lLCBmcm9tOiBjb21wYXJlLiRmcm9tKCkubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISgoY29tcGFyZS50byAmJiAhaG9va1JlZ2lzdHJ5XzEubWF0Y2hTdGF0ZSh0aGlzLiR0bygpLCBjb21wYXJlLnRvKSkgfHxcbiAgICAgICAgICAgIChjb21wYXJlLmZyb20gJiYgIWhvb2tSZWdpc3RyeV8xLm1hdGNoU3RhdGUodGhpcy4kZnJvbSgpLCBjb21wYXJlLmZyb20pKSk7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgaWYgKHBhdGhuYW1lID09PSB2b2lkIDApIHsgcGF0aG5hbWUgPSAndG8nOyB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhuYW1lXS5tYXAoaG9mXzEucHJvcCgncGFyYW1WYWx1ZXMnKSkucmVkdWNlKGNvbW1vbl8xLm1lcmdlUiwge30pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBbW1VJSW5qZWN0b3JdXSBEZXBlbmRlbmN5IEluamVjdG9yXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgRGVwZW5kZW5jeSBJbmplY3RvciBmb3IgdGhlIFRyYW5zaXRpb24ncyB0YXJnZXQgc3RhdGUgKHRvIHN0YXRlKS5cbiAgICAgKiBUaGUgaW5qZWN0b3IgcHJvdmlkZXMgcmVzb2x2ZSB2YWx1ZXMgd2hpY2ggdGhlIHRhcmdldCBzdGF0ZSBoYXMgYWNjZXNzIHRvLlxuICAgICAqXG4gICAgICogVGhlIGBVSUluamVjdG9yYCBjYW4gYWxzbyBwcm92aWRlIHZhbHVlcyBmcm9tIHRoZSBuYXRpdmUgcm9vdC9nbG9iYWwgaW5qZWN0b3IgKG5nMS9uZzIpLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogLm9uRW50ZXIoeyBlbnRlcmluZzogJ215U3RhdGUnIH0sIHRyYW5zID0+IHtcbiAgICAgKiAgIHZhciBteVJlc29sdmVWYWx1ZSA9IHRyYW5zLmluamVjdG9yKCkuZ2V0KCdteVJlc29sdmUnKTtcbiAgICAgKiAgIC8vIEluamVjdCBhIGdsb2JhbCBzZXJ2aWNlIGZyb20gdGhlIGdsb2JhbC9uYXRpdmUgaW5qZWN0b3IgKGlmIGl0IGV4aXN0cylcbiAgICAgKiAgIHZhciBNeVNlcnZpY2UgPSB0cmFucy5pbmplY3RvcigpLmdldCgnTXlTZXJ2aWNlJyk7XG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEluIHNvbWUgY2FzZXMgKHN1Y2ggYXMgYG9uQmVmb3JlYCksIHlvdSBtYXkgbmVlZCBhY2Nlc3MgdG8gc29tZSByZXNvbHZlIGRhdGEgYnV0IGl0IGhhcyBub3QgeWV0IGJlZW4gZmV0Y2hlZC5cbiAgICAgKiBZb3UgY2FuIHVzZSBbW1VJSW5qZWN0b3IuZ2V0QXN5bmNdXSB0byBnZXQgYSBwcm9taXNlIGZvciB0aGUgZGF0YS5cbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAub25CZWZvcmUoe30sIHRyYW5zID0+IHtcbiAgICAgKiAgIHJldHVybiB0cmFucy5pbmplY3RvcigpLmdldEFzeW5jKCdteVJlc29sdmUnKS50aGVuKG15UmVzb2x2ZVZhbHVlID0+XG4gICAgICogICAgIHJldHVybiBteVJlc29sdmVWYWx1ZSAhPT0gJ0FCT1JUJztcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSWYgYSBgc3RhdGVgIGlzIHByb3ZpZGVkLCB0aGUgaW5qZWN0b3IgdGhhdCBpcyByZXR1cm5lZCB3aWxsIGJlIGxpbWl0ZWQgdG8gcmVzb2x2ZSB2YWx1ZXMgdGhhdCB0aGUgcHJvdmlkZWQgc3RhdGUgaGFzIGFjY2VzcyB0by5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgYm90aCBhIHBhcmVudCBzdGF0ZSBgZm9vYCBhbmQgYSBjaGlsZCBzdGF0ZSBgZm9vLmJhcmAgaGF2ZSBib3RoIGRlZmluZWQgYSByZXNvbHZlIHN1Y2ggYXMgYGRhdGFgLlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC5vbkVudGVyKHsgdG86ICdmb28uYmFyJyB9LCB0cmFucyA9PiB7XG4gICAgICogICAvLyByZXR1cm5zIHJlc3VsdCBvZiBgZm9vYCBzdGF0ZSdzIGBteVJlc29sdmVgIHJlc29sdmVcbiAgICAgKiAgIC8vIGV2ZW4gdGhvdWdoIGBmb28uYmFyYCBhbHNvIGhhcyBhIGBteVJlc29sdmVgIHJlc29sdmVcbiAgICAgKiAgIHZhciBmb29EYXRhID0gdHJhbnMuaW5qZWN0b3IoJ2ZvbycpLmdldCgnbXlSZXNvbHZlJyk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJZiB5b3UgbmVlZCByZXNvbHZlIGRhdGEgZnJvbSB0aGUgZXhpdGluZyBzdGF0ZXMsIHBhc3MgYCdmcm9tJ2AgYXMgYHBhdGhOYW1lYC5cbiAgICAgKiBUaGUgcmVzb2x2ZSBkYXRhIGZyb20gdGhlIGBmcm9tYCBwYXRoIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogLm9uRXhpdCh7IGV4aXRpbmc6ICdmb28uYmFyJyB9LCB0cmFucyA9PiB7XG4gICAgICogICAvLyBHZXRzIHRoZSByZXNvbHZlIHZhbHVlIG9mIGBteVJlc29sdmVgIGZyb20gdGhlIHN0YXRlIGJlaW5nIGV4aXRlZFxuICAgICAqICAgdmFyIGZvb0RhdGEgPSB0cmFucy5pbmplY3RvcihudWxsLCAnZnJvbScpLmdldCgnbXlSZXNvbHZlJyk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBMaW1pdHMgdGhlIHJlc29sdmVzIHByb3ZpZGVkIHRvIG9ubHkgdGhlIHJlc29sdmVzIHRoZSBwcm92aWRlZCBzdGF0ZSBoYXMgYWNjZXNzIHRvLlxuICAgICAqIEBwYXJhbSBwYXRoTmFtZSBEZWZhdWx0OiBgJ3RvJ2A6IENob29zZXMgdGhlIHBhdGggZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgaW5qZWN0b3IuIFVzZSB0aGlzIHRvIGFjY2VzcyByZXNvbHZlcyBmb3IgYGV4aXRpbmdgIHN0YXRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgW1tVSUluamVjdG9yXV1cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5pbmplY3RvciA9IGZ1bmN0aW9uIChzdGF0ZSwgcGF0aE5hbWUpIHtcbiAgICAgICAgaWYgKHBhdGhOYW1lID09PSB2b2lkIDApIHsgcGF0aE5hbWUgPSAndG8nOyB9XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aE5hbWVdO1xuICAgICAgICBpZiAoc3RhdGUpXG4gICAgICAgICAgICBwYXRoID0gcGF0aFV0aWxzXzEuUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGUgPT09IHN0YXRlIHx8IG5vZGUuc3RhdGUubmFtZSA9PT0gc3RhdGU7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQocGF0aCkuaW5qZWN0b3IoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGF2YWlsYWJsZSByZXNvbHZlIHRva2VucyAoa2V5cylcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggW1tpbmplY3Rvcl1dIHRvIGluc3BlY3QgdGhlIHJlc29sdmUgdmFsdWVzXG4gICAgICogYXZhaWxhYmxlIHRvIHRoZSBUcmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyByZXR1cm5zIGFsbCB0aGUgdG9rZW5zIGRlZmluZWQgb24gW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSBibG9ja3MsIGZvciB0aGUgc3RhdGVzXG4gICAgICogaW4gdGhlIFRyYW5zaXRpb24ncyBbW1RyZWVDaGFuZ2VzLnRvXV0gcGF0aC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBUaGlzIGV4YW1wbGUgbG9ncyBhbGwgcmVzb2x2ZSB2YWx1ZXNcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCB0b2tlbnMgPSB0cmFucy5nZXRSZXNvbHZlVG9rZW5zKCk7XG4gICAgICogdG9rZW5zLmZvckVhY2godG9rZW4gPT4gY29uc29sZS5sb2codG9rZW4gKyBcIiA9IFwiICsgdHJhbnMuaW5qZWN0b3IoKS5nZXQodG9rZW4pKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgcHJvbWlzZXMgZm9yIGVhY2ggcmVzb2x2ZSB2YWx1ZS5cbiAgICAgKiBUaGlzIHRyaWdnZXJzIGZldGNoZXMgb2YgcmVzb2x2ZXMgKGlmIGFueSBoYXZlIG5vdCB5ZXQgYmVlbiBmZXRjaGVkKS5cbiAgICAgKiBXaGVuIGFsbCBwcm9taXNlcyBoYXZlIGFsbCBzZXR0bGVkLCBpdCBsb2dzIHRoZSByZXNvbHZlIHZhbHVlcy5cbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCB0b2tlbnMgPSB0cmFucy5nZXRSZXNvbHZlVG9rZW5zKCk7XG4gICAgICogbGV0IHByb21pc2UgPSB0b2tlbnMubWFwKHRva2VuID0+IHRyYW5zLmluamVjdG9yKCkuZ2V0QXN5bmModG9rZW4pKTtcbiAgICAgKiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbih2YWx1ZXMgPT4gY29uc29sZS5sb2coXCJSZXNvbHZlZCB2YWx1ZXM6IFwiICsgdmFsdWVzKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlOiBBbmd1bGFyIDEgdXNlcnMgd2hvdWxkIHVzZSBgJHEuYWxsKClgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aG5hbWUgcmVzb2x2ZSBjb250ZXh0J3MgcGF0aCBuYW1lIChlLmcuLCBgdG9gIG9yIGBmcm9tYClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHJlc29sdmUgdG9rZW5zIChrZXlzKVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmdldFJlc29sdmVUb2tlbnMgPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgaWYgKHBhdGhuYW1lID09PSB2b2lkIDApIHsgcGF0aG5hbWUgPSAndG8nOyB9XG4gICAgICAgIHJldHVybiBuZXcgcmVzb2x2ZUNvbnRleHRfMS5SZXNvbHZlQ29udGV4dCh0aGlzLl90cmVlQ2hhbmdlc1twYXRobmFtZV0pLmdldFRva2VucygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHluYW1pY2FsbHkgYWRkcyBhIG5ldyBbW1Jlc29sdmFibGVdXSAoaS5lLiwgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSkgdG8gdGhpcyB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogQWxsb3dzIGEgdHJhbnNpdGlvbiBob29rIHRvIGR5bmFtaWNhbGx5IGFkZCBhIFJlc29sdmFibGUgdG8gdGhpcyBUcmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogVXNlIHRoZSBbW1RyYW5zaXRpb24uaW5qZWN0b3JdXSB0byByZXRyaWV2ZSB0aGUgcmVzb2x2ZWQgZGF0YSBpbiBzdWJzZXF1ZW50IGhvb2tzIChbW1VJSW5qZWN0b3IuZ2V0XV0pLlxuICAgICAqXG4gICAgICogSWYgYSBgc3RhdGVgIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB0aGUgUmVzb2x2YWJsZSBpcyBwcm9jZXNzZWQgd2hlbiB0aGF0IHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXG4gICAgICogSWYgbm8gYHN0YXRlYCBpcyBwcm92aWRlZCB0aGVuIHRoZSByb290IHN0YXRlIGlzIHVzZWQuXG4gICAgICogSWYgdGhlIGdpdmVuIGBzdGF0ZWAgaGFzIGFscmVhZHkgYmVlbiBlbnRlcmVkLCB0aGUgUmVzb2x2YWJsZSBpcyBwcm9jZXNzZWQgd2hlbiBhbnkgY2hpbGQgc3RhdGUgaXMgZW50ZXJlZC5cbiAgICAgKiBJZiBubyBjaGlsZCBzdGF0ZXMgd2lsbCBiZSBlbnRlcmVkLCB0aGUgUmVzb2x2YWJsZSBpcyBwcm9jZXNzZWQgZHVyaW5nIHRoZSBgb25GaW5pc2hgIHBoYXNlIG9mIHRoZSBUcmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGBzdGF0ZWAgYXJndW1lbnQgYWxzbyBzY29wZXMgdGhlIHJlc29sdmVkIGRhdGEuXG4gICAgICogVGhlIHJlc29sdmVkIGRhdGEgaXMgYXZhaWxhYmxlIGZyb20gdGhlIGluamVjdG9yIGZvciB0aGF0IGBzdGF0ZWAgYW5kIGFueSBjaGlsZHJlbiBzdGF0ZXMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgdHJhbnNpdGlvbiA9PiB7XG4gICAgICogICB0cmFuc2l0aW9uLmFkZFJlc29sdmFibGUoe1xuICAgICAqICAgICB0b2tlbjogJ215UmVzb2x2ZScsXG4gICAgICogICAgIGRlcHM6IFsnTXlTZXJ2aWNlJ10sXG4gICAgICogICAgIHJlc29sdmVGbjogbXlTZXJ2aWNlID0+IG15U2VydmljZS5nZXREYXRhKClcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc29sdmFibGUgYSBbW1Jlc29sdmFibGVMaXRlcmFsXV0gb2JqZWN0IChvciBhIFtbUmVzb2x2YWJsZV1dKVxuICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgc3RhdGUgaW4gdGhlIFwidG8gcGF0aFwiIHdoaWNoIHNob3VsZCByZWNlaXZlIHRoZSBuZXcgcmVzb2x2ZSAob3RoZXJ3aXNlLCB0aGUgcm9vdCBzdGF0ZSlcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5hZGRSZXNvbHZhYmxlID0gZnVuY3Rpb24gKHJlc29sdmFibGUsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7IHN0YXRlID0gJyc7IH1cbiAgICAgICAgcmVzb2x2YWJsZSA9IGhvZl8xLmlzKHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKShyZXNvbHZhYmxlKSA/IHJlc29sdmFibGUgOiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUocmVzb2x2YWJsZSk7XG4gICAgICAgIHZhciBzdGF0ZU5hbWUgPSB0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnID8gc3RhdGUgOiBzdGF0ZS5uYW1lO1xuICAgICAgICB2YXIgdG9wYXRoID0gdGhpcy5fdHJlZUNoYW5nZXMudG87XG4gICAgICAgIHZhciB0YXJnZXROb2RlID0gY29tbW9uXzEuZmluZCh0b3BhdGgsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnN0YXRlLm5hbWUgPT09IHN0YXRlTmFtZTsgfSk7XG4gICAgICAgIHZhciByZXNvbHZlQ29udGV4dCA9IG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRvcGF0aCk7XG4gICAgICAgIHJlc29sdmVDb250ZXh0LmFkZFJlc29sdmFibGVzKFtyZXNvbHZhYmxlXSwgdGFyZ2V0Tm9kZS5zdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0cmFuc2l0aW9uIGZyb20gd2hpY2ggdGhpcyB0cmFuc2l0aW9uIHdhcyByZWRpcmVjdGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBpcyBhIHJlZGlyZWN0LCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0cmFuc2l0aW9uIHRoYXQgd2FzIHJlZGlyZWN0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBsZXQgdHJhbnNpdGlvbkEgPSAkc3RhdGUuZ28oJ0EnKS50cmFuc2l0aW9uXG4gICAgICogdHJhbnNpdGlvbkEub25TdGFydCh7fSwgKCkgPT4gJHN0YXRlLnRhcmdldCgnQicpKTtcbiAgICAgKiAkdHJhbnNpdGlvbnMub25TdWNjZXNzKHsgdG86ICdCJyB9LCAodHJhbnMpID0+IHtcbiAgICAgKiAgIHRyYW5zLnRvKCkubmFtZSA9PT0gJ0InOyAvLyB0cnVlXG4gICAgICogICB0cmFucy5yZWRpcmVjdGVkRnJvbSgpID09PSB0cmFuc2l0aW9uQTsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHByZXZpb3VzIFRyYW5zaXRpb24sIG9yIG51bGwgaWYgdGhpcyBUcmFuc2l0aW9uIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGEgcmVkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5yZWRpcmVjdGVkRnJvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMucmVkaXJlY3RlZEZyb20gfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gaW4gYSByZWRpcmVjdCBjaGFpblxuICAgICAqXG4gICAgICogQSB0cmFuc2l0aW9uIG1pZ2h0IGJlbG9uZyB0byBhIGxvbmcgY2hhaW4gb2YgbXVsdGlwbGUgcmVkaXJlY3RzLlxuICAgICAqIFRoaXMgbWV0aG9kIHdhbGtzIHRoZSBbW3JlZGlyZWN0ZWRGcm9tXV0gY2hhaW4gYmFjayB0byB0aGUgb3JpZ2luYWwgKGZpcnN0KSB0cmFuc2l0aW9uIGluIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIHN0YXRlc1xuICAgICAqIHJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ0EnLCByZWRpcmVjdFRvOiAnQicgfSk7XG4gICAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnQicsIHJlZGlyZWN0VG86ICdDJyB9KTtcbiAgICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdDJywgcmVkaXJlY3RUbzogJ0QnIH0pO1xuICAgICAqIHJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ0QnIH0pO1xuICAgICAqXG4gICAgICogbGV0IHRyYW5zaXRpb25BID0gJHN0YXRlLmdvKCdBJykudHJhbnNpdGlvblxuICAgICAqXG4gICAgICogJHRyYW5zaXRpb25zLm9uU3VjY2Vzcyh7IHRvOiAnRCcgfSwgKHRyYW5zKSA9PiB7XG4gICAgICogICB0cmFucy50bygpLm5hbWUgPT09ICdEJzsgLy8gdHJ1ZVxuICAgICAqICAgdHJhbnMucmVkaXJlY3RlZEZyb20oKS50bygpLm5hbWUgPT09ICdDJzsgLy8gdHJ1ZVxuICAgICAqICAgdHJhbnMub3JpZ2luYWxUcmFuc2l0aW9uKCkgPT09IHRyYW5zaXRpb25BOyAvLyB0cnVlXG4gICAgICogICB0cmFucy5vcmlnaW5hbFRyYW5zaXRpb24oKS50bygpLm5hbWUgPT09ICdBJzsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG9yaWdpbmFsIFRyYW5zaXRpb24gdGhhdCBzdGFydGVkIGEgcmVkaXJlY3QgY2hhaW5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vcmlnaW5hbFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZiA9IHRoaXMucmVkaXJlY3RlZEZyb20oKTtcbiAgICAgICAgcmV0dXJuIChyZiAmJiByZi5vcmlnaW5hbFRyYW5zaXRpb24oKSkgfHwgdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHJhbnNpdGlvbiBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgb3B0aW9ucyBmb3IgdGhpcyBUcmFuc2l0aW9uLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdGVzIGJlaW5nIGVudGVyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCB3aWxsIGJlIGVudGVyZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5lbnRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZywgaG9mXzEucHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgZXhpdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRoYXQgd2lsbCBiZSBleGl0ZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5leGl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMuX3RyZWVDaGFuZ2VzLmV4aXRpbmcsIGhvZl8xLnByb3AoJ3N0YXRlJykpXG4gICAgICAgICAgICAubWFwKHN0YXRlU2VsZilcbiAgICAgICAgICAgIC5yZXZlcnNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgcmV0YWluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCBhcmUgYWxyZWFkeSBlbnRlcmVkIGZyb20gYSBwcmV2aW91cyBUcmFuc2l0aW9uLCB0aGF0IHdpbGwgbm90IGJlXG4gICAgICogICAgZXhpdGVkIGR1cmluZyB0aGlzIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5yZXRhaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5yZXRhaW5lZCwgaG9mXzEucHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFtbVmlld0NvbmZpZ11dcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBUcmFuc2l0aW9uXG4gICAgICpcbiAgICAgKiBFYWNoIHN0YXRlIGNhbiBkZWZpbmUgb25lIG9yIG1vcmUgdmlld3MgKHRlbXBsYXRlL2NvbnRyb2xsZXIpLCB3aGljaCBhcmUgZW5jYXBzdWxhdGVkIGFzIGBWaWV3Q29uZmlnYCBvYmplY3RzLlxuICAgICAqIFRoaXMgbWV0aG9kIGZldGNoZXMgdGhlIGBWaWV3Q29uZmlnc2AgZm9yIGEgZ2l2ZW4gcGF0aCBpbiB0aGUgVHJhbnNpdGlvbiAoZS5nLiwgXCJ0b1wiIG9yIFwiZW50ZXJpbmdcIikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aG5hbWUgdGhlIG5hbWUgb2YgdGhlIHBhdGggdG8gZmV0Y2ggdmlld3MgZm9yOlxuICAgICAqICAgKGAndG8nYCwgYCdmcm9tJ2AsIGAnZW50ZXJpbmcnYCwgYCdleGl0aW5nJ2AsIGAncmV0YWluZWQnYClcbiAgICAgKiBAcGFyYW0gc3RhdGUgSWYgcHJvdmlkZWQsIG9ubHkgcmV0dXJucyB0aGUgYFZpZXdDb25maWdgcyBmb3IgYSBzaW5nbGUgc3RhdGUgaW4gdGhlIHBhdGhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgbGlzdCBvZiBWaWV3Q29uZmlnIG9iamVjdHMgZm9yIHRoZSBnaXZlbiBwYXRoLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnZpZXdzID0gZnVuY3Rpb24gKHBhdGhuYW1lLCBzdGF0ZSkge1xuICAgICAgICBpZiAocGF0aG5hbWUgPT09IHZvaWQgMCkgeyBwYXRobmFtZSA9ICdlbnRlcmluZyc7IH1cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLl90cmVlQ2hhbmdlc1twYXRobmFtZV07XG4gICAgICAgIHBhdGggPSAhc3RhdGUgPyBwYXRoIDogcGF0aC5maWx0ZXIoaG9mXzEucHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgICAgIHJldHVybiBwYXRoXG4gICAgICAgICAgICAubWFwKGhvZl8xLnByb3AoJ3ZpZXdzJykpXG4gICAgICAgICAgICAuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSk7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50cmVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWUgPyB0aGlzLl90cmVlQ2hhbmdlc1twYXRobmFtZV0gOiB0aGlzLl90cmVlQ2hhbmdlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdHJhbnNpdGlvbiB0aGF0IGlzIGEgcmVkaXJlY3Rpb24gb2YgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqXG4gICAgICogVGhpcyB0cmFuc2l0aW9uIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgW1tUcmFuc2l0aW9uU2VydmljZV1dIGhvb2sgdG9cbiAgICAgKiByZWRpcmVjdCBhIHRyYW5zaXRpb24gdG8gYSBuZXcgc3RhdGUgYW5kL29yIHNldCBvZiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgbmV3IFtbVHJhbnNpdGlvbl1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgICAgIHZhciByZWRpcmVjdHMgPSAxLCB0cmFucyA9IHRoaXM7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25kaXRpb25hbC1hc3NpZ25tZW50XG4gICAgICAgIHdoaWxlICgodHJhbnMgPSB0cmFucy5yZWRpcmVjdGVkRnJvbSgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKytyZWRpcmVjdHMgPiAyMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSBjb25zZWN1dGl2ZSBUcmFuc2l0aW9uIHJlZGlyZWN0cyAoMjArKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVkaXJlY3RPcHRzID0geyByZWRpcmVjdGVkRnJvbTogdGhpcywgc291cmNlOiAncmVkaXJlY3QnIH07XG4gICAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIHdhcyBjYXVzZWQgYnkgVVJMIHN5bmMsIHRoZW4gdXNlIHsgbG9jYXRpb246ICdyZXBsYWNlJyB9XG4gICAgICAgIC8vIG9uIHRoZSBuZXcgdHJhbnNpdGlvbiAodW5sZXNzIHRoZSB0YXJnZXQgc3RhdGUgZXhwbGljaXRseSBzcGVjaWZpZXMgbG9jYXRpb246IGZhbHNlKS5cbiAgICAgICAgLy8gVGhpcyBjYXVzZXMgdGhlIG9yaWdpbmFsIHVybCB0byBiZSByZXBsYWNlZCB3aXRoIHRoZSB1cmwgZm9yIHRoZSByZWRpcmVjdCB0YXJnZXRcbiAgICAgICAgLy8gc28gdGhlIG9yaWdpbmFsIHVybCBkaXNhcHBlYXJzIGZyb20gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucygpLnNvdXJjZSA9PT0gJ3VybCcgJiYgdGFyZ2V0U3RhdGUub3B0aW9ucygpLmxvY2F0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVkaXJlY3RPcHRzLmxvY2F0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdPcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMoKSwgdGFyZ2V0U3RhdGUub3B0aW9ucygpLCByZWRpcmVjdE9wdHMpO1xuICAgICAgICB0YXJnZXRTdGF0ZSA9IHRhcmdldFN0YXRlLndpdGhPcHRpb25zKG5ld09wdGlvbnMsIHRydWUpO1xuICAgICAgICB2YXIgbmV3VHJhbnNpdGlvbiA9IHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZSh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tLCB0YXJnZXRTdGF0ZSk7XG4gICAgICAgIHZhciBvcmlnaW5hbEVudGVyaW5nTm9kZXMgPSB0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZztcbiAgICAgICAgdmFyIHJlZGlyZWN0RW50ZXJpbmdOb2RlcyA9IG5ld1RyYW5zaXRpb24uX3RyZWVDaGFuZ2VzLmVudGVyaW5nO1xuICAgICAgICAvLyAtLS0gUmUtdXNlIHJlc29sdmUgZGF0YSBmcm9tIG9yaWdpbmFsIHRyYW5zaXRpb24gLS0tXG4gICAgICAgIC8vIFdoZW4gcmVkaXJlY3RpbmcgZnJvbSBhIHBhcmVudCBzdGF0ZSB0byBhIGNoaWxkIHN0YXRlIHdoZXJlIHRoZSBwYXJlbnQgcGFyYW1ldGVyIHZhbHVlcyBoYXZlbid0IGNoYW5nZWRcbiAgICAgICAgLy8gKGJlY2F1c2Ugb2YgdGhlIHJlZGlyZWN0KSwgdGhlIHJlc29sdmVzIGZldGNoZWQgYnkgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gYXJlIHN0aWxsIHZhbGlkIGluIHRoZVxuICAgICAgICAvLyByZWRpcmVjdGVkIHRyYW5zaXRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHlvdSB0byBkZWZpbmUgYSByZWRpcmVjdCBvbiBhIHBhcmVudCBzdGF0ZSB3aGljaCBkZXBlbmRzIG9uIGFuIGFzeW5jIHJlc29sdmUgdmFsdWUuXG4gICAgICAgIC8vIFlvdSBjYW4gd2FpdCBmb3IgdGhlIHJlc29sdmUsIHRoZW4gcmVkaXJlY3QgdG8gYSBjaGlsZCBzdGF0ZSBiYXNlZCBvbiB0aGUgcmVzdWx0LlxuICAgICAgICAvLyBUaGUgcmVkaXJlY3RlZCB0cmFuc2l0aW9uIGRvZXMgbm90IGhhdmUgdG8gcmUtZmV0Y2ggdGhlIHJlc29sdmUuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgbm9kZUlzUmVsb2FkaW5nID0gZnVuY3Rpb24gKHJlbG9hZFN0YXRlKSB7IHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbG9hZFN0YXRlICYmIG5vZGUuc3RhdGUuaW5jbHVkZXNbcmVsb2FkU3RhdGUubmFtZV07XG4gICAgICAgIH07IH07XG4gICAgICAgIC8vIEZpbmQgYW55IFwiZW50ZXJpbmdcIiBub2RlcyBpbiB0aGUgcmVkaXJlY3QgcGF0aCB0aGF0IG1hdGNoIHRoZSBvcmlnaW5hbCBwYXRoIGFuZCBhcmVuJ3QgYmVpbmcgcmVsb2FkZWRcbiAgICAgICAgdmFyIG1hdGNoaW5nRW50ZXJpbmdOb2RlcyA9IHBhdGhVdGlsc18xLlBhdGhVdGlscy5tYXRjaGluZyhyZWRpcmVjdEVudGVyaW5nTm9kZXMsIG9yaWdpbmFsRW50ZXJpbmdOb2RlcywgcGF0aFV0aWxzXzEuUGF0aFV0aWxzLm5vbkR5bmFtaWNQYXJhbXMpLmZpbHRlcihob2ZfMS5ub3Qobm9kZUlzUmVsb2FkaW5nKHRhcmdldFN0YXRlLm9wdGlvbnMoKS5yZWxvYWRTdGF0ZSkpKTtcbiAgICAgICAgLy8gVXNlIHRoZSBleGlzdGluZyAocG9zc2libHkgcHJlLXJlc29sdmVkKSByZXNvbHZhYmxlcyBmb3IgdGhlIG1hdGNoaW5nIGVudGVyaW5nIG5vZGVzLlxuICAgICAgICBtYXRjaGluZ0VudGVyaW5nTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgaWR4KSB7XG4gICAgICAgICAgICBub2RlLnJlc29sdmFibGVzID0gb3JpZ2luYWxFbnRlcmluZ05vZGVzW2lkeF0ucmVzb2x2YWJsZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3VHJhbnNpdGlvbjtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuIElmIGEgdHJhbnNpdGlvbiBkb2Vzbid0IGV4aXQvZW50ZXIgYW55IHN0YXRlcywgcmV0dXJucyBhbnkgW1tQYXJhbV1dIHdob3NlIHZhbHVlIGNoYW5nZWQgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5fY2hhbmdlZFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRjID0gdGhpcy5fdHJlZUNoYW5nZXM7XG4gICAgICAgIC8qKiBSZXR1cm4gdW5kZWZpbmVkIGlmIGl0J3Mgbm90IGEgXCJkeW5hbWljXCIgdHJhbnNpdGlvbiwgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29ucyAqL1xuICAgICAgICAvLyBJZiB1c2VyIGV4cGxpY2l0bHkgd2FudHMgYSByZWxvYWRcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucmVsb2FkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSWYgYW55IHN0YXRlcyBhcmUgZXhpdGluZyBvciBlbnRlcmluZ1xuICAgICAgICBpZiAodGMuZXhpdGluZy5sZW5ndGggfHwgdGMuZW50ZXJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSWYgdG8vZnJvbSBwYXRoIGxlbmd0aHMgZGlmZmVyXG4gICAgICAgIGlmICh0Yy50by5sZW5ndGggIT09IHRjLmZyb20ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSWYgdGhlIHRvL2Zyb20gcGF0aHMgYXJlIGRpZmZlcmVudFxuICAgICAgICB2YXIgcGF0aHNEaWZmZXIgPSBjb21tb25fMS5hcnJheVR1cGxlcyh0Yy50bywgdGMuZnJvbSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiB0dXBsZVswXS5zdGF0ZSAhPT0gdHVwbGVbMV0uc3RhdGU7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLmFueVRydWVSLCBmYWxzZSk7XG4gICAgICAgIGlmIChwYXRoc0RpZmZlcilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEZpbmQgYW55IHBhcmFtZXRlciB2YWx1ZXMgdGhhdCBkaWZmZXJcbiAgICAgICAgdmFyIG5vZGVTY2hlbWFzID0gdGMudG8ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnBhcmFtU2NoZW1hOyB9KTtcbiAgICAgICAgdmFyIF9hID0gW3RjLnRvLCB0Yy5mcm9tXS5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGgubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnBhcmFtVmFsdWVzOyB9KTsgfSksIHRvVmFsdWVzID0gX2FbMF0sIGZyb21WYWx1ZXMgPSBfYVsxXTtcbiAgICAgICAgdmFyIHR1cGxlcyA9IGNvbW1vbl8xLmFycmF5VHVwbGVzKG5vZGVTY2hlbWFzLCB0b1ZhbHVlcywgZnJvbVZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0dXBsZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IF9hWzBdLCB0b1ZhbHMgPSBfYVsxXSwgZnJvbVZhbHMgPSBfYVsyXTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmNoYW5nZWQoc2NoZW1hLCB0b1ZhbHMsIGZyb21WYWxzKTtcbiAgICAgICAgfSkucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNpdGlvbiBpcyBkeW5hbWljLlxuICAgICAqXG4gICAgICogQSB0cmFuc2l0aW9uIGlzIGR5bmFtaWMgaWYgbm8gc3RhdGVzIGFyZSBlbnRlcmVkIG5vciBleGl0ZWQsIGJ1dCBhdCBsZWFzdCBvbmUgZHluYW1pYyBwYXJhbWV0ZXIgaGFzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUcmFuc2l0aW9uIGlzIGR5bmFtaWNcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5keW5hbWljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZWRQYXJhbXMoKTtcbiAgICAgICAgcmV0dXJuICFjaGFuZ2VzID8gZmFsc2UgOiBjaGFuZ2VzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5keW5hbWljOyB9KS5yZWR1Y2UoY29tbW9uXzEuYW55VHJ1ZVIsIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNpdGlvbiBpcyBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQgaWYgbm8gc3RhdGVzIGFyZSBlbnRlcmVkIG5vciBleGl0ZWQsIGFuZCBubyBwYXJhbWV0ZXIgdmFsdWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgaWdub3JlZC5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5pZ25vcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9pZ25vcmVkUmVhc29uKCk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLl9pZ25vcmVkUmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGVuZGluZyA9IHRoaXMucm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbjtcbiAgICAgICAgdmFyIHJlbG9hZFN0YXRlID0gdGhpcy5fb3B0aW9ucy5yZWxvYWRTdGF0ZTtcbiAgICAgICAgdmFyIHNhbWUgPSBmdW5jdGlvbiAocGF0aEEsIHBhdGhCKSB7XG4gICAgICAgICAgICBpZiAocGF0aEEubGVuZ3RoICE9PSBwYXRoQi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gcGF0aFV0aWxzXzEuUGF0aFV0aWxzLm1hdGNoaW5nKHBhdGhBLCBwYXRoQik7XG4gICAgICAgICAgICByZXR1cm4gcGF0aEEubGVuZ3RoID09PSBtYXRjaGluZy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuICFyZWxvYWRTdGF0ZSB8fCAhbm9kZS5zdGF0ZS5pbmNsdWRlc1tyZWxvYWRTdGF0ZS5uYW1lXTsgfSkubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbmV3VEMgPSB0aGlzLnRyZWVDaGFuZ2VzKCk7XG4gICAgICAgIHZhciBwZW5kVEMgPSBwZW5kaW5nICYmIHBlbmRpbmcudHJlZUNoYW5nZXMoKTtcbiAgICAgICAgaWYgKHBlbmRUQyAmJiBzYW1lKHBlbmRUQy50bywgbmV3VEMudG8pICYmIHNhbWUocGVuZFRDLmV4aXRpbmcsIG5ld1RDLmV4aXRpbmcpKVxuICAgICAgICAgICAgcmV0dXJuICdTYW1lQXNQZW5kaW5nJztcbiAgICAgICAgaWYgKG5ld1RDLmV4aXRpbmcubGVuZ3RoID09PSAwICYmIG5ld1RDLmVudGVyaW5nLmxlbmd0aCA9PT0gMCAmJiBzYW1lKG5ld1RDLmZyb20sIG5ld1RDLnRvKSlcbiAgICAgICAgICAgIHJldHVybiAnU2FtZUFzQ3VycmVudCc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSB0cmFuc2l0aW9uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBnZW5lcmFsbHkgY2FsbGVkIGZyb20gdGhlIFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25Ub11dXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgYSBzdWNjZXNzZnVsIHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcnVuQWxsSG9va3MgPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLnJ1bkFsbEhvb2tzO1xuICAgICAgICAvLyBHZXRzIHRyYW5zaXRpb24gaG9va3MgYXJyYXkgZm9yIHRoZSBnaXZlbiBwaGFzZVxuICAgICAgICB2YXIgZ2V0SG9va3NGb3IgPSBmdW5jdGlvbiAocGhhc2UpIHsgcmV0dXJuIF90aGlzLl9ob29rQnVpbGRlci5idWlsZEhvb2tzRm9yUGhhc2UocGhhc2UpOyB9O1xuICAgICAgICAvLyBXaGVuIHRoZSBjaGFpbiBpcyBjb21wbGV0ZSwgdGhlbiByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAgICAgICAgdmFyIHRyYW5zaXRpb25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVN1Y2Nlc3MoX3RoaXMuJHRvKCksIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX2RlZmVycmVkLnJlc29sdmUoX3RoaXMudG8oKSk7XG4gICAgICAgICAgICBydW5BbGxIb29rcyhnZXRIb29rc0ZvcihpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLlNVQ0NFU1MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25FcnJvciA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VFcnJvcihyZWFzb24sIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9kZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIF90aGlzLl9lcnJvciA9IHJlYXNvbjtcbiAgICAgICAgICAgIHJ1bkFsbEhvb2tzKGdldEhvb2tzRm9yKGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuRVJST1IpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJ1blRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBXYWl0IHRvIGJ1aWxkIHRoZSBSVU4gaG9vayBjaGFpbiB1bnRpbCB0aGUgQkVGT1JFIGhvb2tzIGFyZSBkb25lXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBhIEJFRk9SRSBob29rIHRvIGR5bmFtaWNhbGx5IGFkZCBhZGRpdGlvbmFsIFJVTiBob29rcyB2aWEgdGhlIFRyYW5zaXRpb24gb2JqZWN0LlxuICAgICAgICAgICAgdmFyIGFsbFJ1bkhvb2tzID0gZ2V0SG9va3NGb3IoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5SVU4pO1xuICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHVuZGVmaW5lZCk7IH07XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5pbnZva2VIb29rcyhhbGxSdW5Ib29rcywgZG9uZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ2xvYmFscyA9IF90aGlzLnJvdXRlci5nbG9iYWxzO1xuICAgICAgICAgICAgZ2xvYmFscy5sYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA9IF90aGlzLiRpZDtcbiAgICAgICAgICAgIGdsb2JhbHMudHJhbnNpdGlvbiA9IF90aGlzO1xuICAgICAgICAgICAgZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5lbnF1ZXVlKF90aGlzKTtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VUcmFuc2l0aW9uU3RhcnQoX3RoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4odW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFsbEJlZm9yZUhvb2tzID0gZ2V0SG9va3NGb3IoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5CRUZPUkUpO1xuICAgICAgICB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKGFsbEJlZm9yZUhvb2tzLCBzdGFydFRyYW5zaXRpb24pXG4gICAgICAgICAgICAudGhlbihydW5UcmFuc2l0aW9uKVxuICAgICAgICAgICAgLnRoZW4odHJhbnNpdGlvblN1Y2Nlc3MsIHRyYW5zaXRpb25FcnJvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVycm9yKCkgfHwgdGhpcy5zdWNjZXNzICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhpcyB0cmFuc2l0aW9uXG4gICAgICpcbiAgICAgKiBJbXBlcmF0aXZlIEFQSSB0byBhYm9ydCBhIFRyYW5zaXRpb24uXG4gICAgICogVGhpcyBvbmx5IGFwcGxpZXMgdG8gVHJhbnNpdGlvbnMgdGhhdCBhcmUgbm90IHlldCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRG8gbm90IHNldCBmbGFnIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgY29tcGxldGVcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1VuZGVmaW5lZCh0aGlzLnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIFRyYW5zaXRpb24gZXJyb3IgcmVhc29uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZCAoYW5kIGNvdWxkIG5vdCBiZSBydW4pLCByZXR1cm5zIHRoZSByZWFzb24gdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZC5cbiAgICAgKiBJZiB0aGUgdHJhbnNpdGlvbiB3YXMgdmFsaWQgYW5kIHJhbiwgYnV0IHdhcyBub3Qgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGUgcmVhc29uIHRoZSB0cmFuc2l0aW9uIGZhaWxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgdHJhbnNpdGlvbiByZWplY3Rpb24gZXhwbGFpbmluZyB3aHkgdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZCwgb3IgdGhlIHJlYXNvbiB0aGUgdHJhbnNpdGlvbiBmYWlsZWQuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHRvKCk7XG4gICAgICAgIGlmIChzdGF0ZS5zZWxmLmFic3RyYWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5pbnZhbGlkKFwiQ2Fubm90IHRyYW5zaXRpb24gdG8gYWJzdHJhY3Qgc3RhdGUgJ1wiICsgc3RhdGUubmFtZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1EZWZzID0gc3RhdGUucGFyYW1ldGVycygpO1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5wYXJhbXMoKTtcbiAgICAgICAgdmFyIGludmFsaWRQYXJhbXMgPSBwYXJhbURlZnMuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gIXBhcmFtLnZhbGlkYXRlcyh2YWx1ZXNbcGFyYW0uaWRdKTsgfSk7XG4gICAgICAgIGlmIChpbnZhbGlkUGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGludmFsaWRWYWx1ZXMgPSBpbnZhbGlkUGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIFwiW1wiICsgcGFyYW0uaWQgKyBcIjpcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodmFsdWVzW3BhcmFtLmlkXSkgKyBcIl1cIjsgfSkuam9pbignLCAnKTtcbiAgICAgICAgICAgIHZhciBkZXRhaWwgPSBcIlRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyIHZhbHVlcyBhcmUgbm90IHZhbGlkIGZvciBzdGF0ZSAnXCIgKyBzdGF0ZS5uYW1lICsgXCInOiBcIiArIGludmFsaWRWYWx1ZXM7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5pbnZhbGlkKGRldGFpbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3VjY2VzcyA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNpdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZyb21TdGF0ZU9yTmFtZSA9IHRoaXMuZnJvbSgpO1xuICAgICAgICB2YXIgdG9TdGF0ZU9yTmFtZSA9IHRoaXMudG8oKTtcbiAgICAgICAgdmFyIGF2b2lkRW1wdHlIYXNoID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtc1snIyddICE9PSBudWxsICYmIHBhcmFtc1snIyddICE9PSB1bmRlZmluZWQgPyBwYXJhbXMgOiBjb21tb25fMS5vbWl0KHBhcmFtcywgWycjJ10pO1xuICAgICAgICB9O1xuICAgICAgICAvLyAoWCkgbWVhbnMgdGhlIHRvIHN0YXRlIGlzIGludmFsaWQuXG4gICAgICAgIHZhciBpZCA9IHRoaXMuJGlkLCBmcm9tID0gcHJlZGljYXRlc18xLmlzT2JqZWN0KGZyb21TdGF0ZU9yTmFtZSkgPyBmcm9tU3RhdGVPck5hbWUubmFtZSA6IGZyb21TdGF0ZU9yTmFtZSwgZnJvbVBhcmFtcyA9IHN0cmluZ3NfMS5zdHJpbmdpZnkoYXZvaWRFbXB0eUhhc2godGhpcy5fdHJlZUNoYW5nZXMuZnJvbS5tYXAoaG9mXzEucHJvcCgncGFyYW1WYWx1ZXMnKSkucmVkdWNlKGNvbW1vbl8xLm1lcmdlUiwge30pKSksIHRvVmFsaWQgPSB0aGlzLnZhbGlkKCkgPyAnJyA6ICcoWCkgJywgdG8gPSBwcmVkaWNhdGVzXzEuaXNPYmplY3QodG9TdGF0ZU9yTmFtZSkgPyB0b1N0YXRlT3JOYW1lLm5hbWUgOiB0b1N0YXRlT3JOYW1lLCB0b1BhcmFtcyA9IHN0cmluZ3NfMS5zdHJpbmdpZnkoYXZvaWRFbXB0eUhhc2godGhpcy5wYXJhbXMoKSkpO1xuICAgICAgICByZXR1cm4gXCJUcmFuc2l0aW9uI1wiICsgaWQgKyBcIiggJ1wiICsgZnJvbSArIFwiJ1wiICsgZnJvbVBhcmFtcyArIFwiIC0+IFwiICsgdG9WYWxpZCArIFwiJ1wiICsgdG8gKyBcIidcIiArIHRvUGFyYW1zICsgXCIgKVwiO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uLmRpVG9rZW4gPSBUcmFuc2l0aW9uO1xuICAgIHJldHVybiBUcmFuc2l0aW9uO1xufSgpKTtcbmV4cG9ydHMuVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRyYW5zaXRpb25Ib29rXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uSG9va1wiKTtcbi8qKlxuICogVGhpcyBjbGFzcyBkZWZpbmVzIGEgdHlwZSBvZiBob29rLCBzdWNoIGFzIGBvbkJlZm9yZWAgb3IgYG9uRW50ZXJgLlxuICogUGx1Z2lucyBjYW4gZGVmaW5lIGN1c3RvbSBob29rIHR5cGVzLCBzdWNoIGFzIHN0aWNreSBzdGF0ZXMgZG9lcyBmb3IgYG9uSW5hY3RpdmVgLlxuICpcbiAqIEBpbnRlcmFsYXBpXG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWluZmVycmFibGUtdHlwZXMgKi9cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uRXZlbnRUeXBlKG5hbWUsIGhvb2tQaGFzZSwgaG9va09yZGVyLCBjcml0ZXJpYU1hdGNoUGF0aCwgcmV2ZXJzZVNvcnQsIGdldFJlc3VsdEhhbmRsZXIsIGdldEVycm9ySGFuZGxlciwgc3luY2hyb25vdXMpIHtcbiAgICAgICAgaWYgKHJldmVyc2VTb3J0ID09PSB2b2lkIDApIHsgcmV2ZXJzZVNvcnQgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoZ2V0UmVzdWx0SGFuZGxlciA9PT0gdm9pZCAwKSB7IGdldFJlc3VsdEhhbmRsZXIgPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLkhBTkRMRV9SRVNVTFQ7IH1cbiAgICAgICAgaWYgKGdldEVycm9ySGFuZGxlciA9PT0gdm9pZCAwKSB7IGdldEVycm9ySGFuZGxlciA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suUkVKRUNUX0VSUk9SOyB9XG4gICAgICAgIGlmIChzeW5jaHJvbm91cyA9PT0gdm9pZCAwKSB7IHN5bmNocm9ub3VzID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5ob29rUGhhc2UgPSBob29rUGhhc2U7XG4gICAgICAgIHRoaXMuaG9va09yZGVyID0gaG9va09yZGVyO1xuICAgICAgICB0aGlzLmNyaXRlcmlhTWF0Y2hQYXRoID0gY3JpdGVyaWFNYXRjaFBhdGg7XG4gICAgICAgIHRoaXMucmV2ZXJzZVNvcnQgPSByZXZlcnNlU29ydDtcbiAgICAgICAgdGhpcy5nZXRSZXN1bHRIYW5kbGVyID0gZ2V0UmVzdWx0SGFuZGxlcjtcbiAgICAgICAgdGhpcy5nZXRFcnJvckhhbmRsZXIgPSBnZXRFcnJvckhhbmRsZXI7XG4gICAgICAgIHRoaXMuc3luY2hyb25vdXMgPSBzeW5jaHJvbm91cztcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zaXRpb25FdmVudFR5cGU7XG59KCkpO1xuZXhwb3J0cy5UcmFuc2l0aW9uRXZlbnRUeXBlID0gVHJhbnNpdGlvbkV2ZW50VHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zaXRpb25FdmVudFR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciByZWplY3RGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9yZWplY3RGYWN0b3J5XCIpO1xudmFyIHRhcmdldFN0YXRlXzEgPSByZXF1aXJlKFwiLi4vc3RhdGUvdGFyZ2V0U3RhdGVcIik7XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgY3VycmVudDogY29tbW9uXzEubm9vcCxcbiAgICB0cmFuc2l0aW9uOiBudWxsLFxuICAgIHRyYWNlRGF0YToge30sXG4gICAgYmluZDogbnVsbCxcbn07XG4vKiogQGhpZGRlbiAqL1xudmFyIFRyYW5zaXRpb25Ib29rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25Ib29rKHRyYW5zaXRpb24sIHN0YXRlQ29udGV4dCwgcmVnaXN0ZXJlZEhvb2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZUNvbnRleHQgPSBzdGF0ZUNvbnRleHQ7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEhvb2sgPSByZWdpc3RlcmVkSG9vaztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pc1N1cGVyc2VkZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50eXBlLmhvb2tQaGFzZSA9PT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5SVU4gJiYgIV90aGlzLm9wdGlvbnMudHJhbnNpdGlvbi5pc0FjdGl2ZSgpOyB9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgIHRoaXMudHlwZSA9IHJlZ2lzdGVyZWRIb29rLmV2ZW50VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhaW5zIHRvZ2V0aGVyIGFuIGFycmF5IG9mIFRyYW5zaXRpb25Ib29rcy5cbiAgICAgKlxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBbW1RyYW5zaXRpb25Ib29rXV0gb2JqZWN0cywgY2hhaW5zIHRoZW0gdG9nZXRoZXIuXG4gICAgICogRWFjaCBob29rIGlzIGludm9rZWQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZSBjb21wbGV0ZXMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgaG9va3M6IFRyYW5zaXRpb25Ib29rW10gPSBnZXRIb29rcygpO1xuICAgICAqIGxldCBwcm9taXNlOiBQcm9taXNlPGFueT4gPSBUcmFuc2l0aW9uSG9vay5jaGFpbihob29rcyk7XG4gICAgICpcbiAgICAgKiBwcm9taXNlLnRoZW4oaGFuZGxlU3VjY2VzcywgaGFuZGxlRXJyb3IpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGhvb2tzIHRoZSBsaXN0IG9mIGhvb2tzIHRvIGNoYWluIHRvZ2V0aGVyXG4gICAgICogQHBhcmFtIHdhaXRGb3IgaWYgcHJvdmlkZWQsIHRoZSBjaGFpbiBpcyBgLnRoZW4oKWAnZWQgb2ZmIHRoaXMgcHJvbWlzZVxuICAgICAqIEByZXR1cm5zIGEgYFByb21pc2VgIGZvciBzZXF1ZW50aWFsbHkgaW52b2tpbmcgdGhlIGhvb2tzIChpbiBvcmRlcilcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5jaGFpbiA9IGZ1bmN0aW9uIChob29rcywgd2FpdEZvcikge1xuICAgICAgICAvLyBDaGFpbiB0aGUgbmV4dCBob29rIG9mZiB0aGUgcHJldmlvdXNcbiAgICAgICAgdmFyIGNyZWF0ZUhvb2tDaGFpblIgPSBmdW5jdGlvbiAocHJldiwgbmV4dEhvb2spIHsgcmV0dXJuIHByZXYudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBuZXh0SG9vay5pbnZva2VIb29rKCk7IH0pOyB9O1xuICAgICAgICByZXR1cm4gaG9va3MucmVkdWNlKGNyZWF0ZUhvb2tDaGFpblIsIHdhaXRGb3IgfHwgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbigpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludm9rZXMgYWxsIHRoZSBwcm92aWRlZCBUcmFuc2l0aW9uSG9va3MsIGluIG9yZGVyLlxuICAgICAqIEVhY2ggaG9vaydzIHJldHVybiB2YWx1ZSBpcyBjaGVja2VkLlxuICAgICAqIElmIGFueSBob29rIHJldHVybnMgYSBwcm9taXNlLCB0aGVuIHRoZSByZXN0IG9mIHRoZSBob29rcyBhcmUgY2hhaW5lZCBvZmYgdGhhdCBwcm9taXNlLCBhbmQgdGhlIHByb21pc2UgaXMgcmV0dXJuZWQuXG4gICAgICogSWYgbm8gaG9vayByZXR1cm5zIGEgcHJvbWlzZSwgdGhlbiBhbGwgaG9va3MgYXJlIHByb2Nlc3NlZCBzeW5jaHJvbm91c2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGhvb2tzIHRoZSBsaXN0IG9mIFRyYW5zaXRpb25Ib29rcyB0byBpbnZva2VcbiAgICAgKiBAcGFyYW0gZG9uZUNhbGxiYWNrIGEgY2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIGFmdGVyIGFsbCB0aGUgaG9va3MgaGF2ZSBzdWNjZXNzZnVsbHkgY29tcGxldGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBhc3luYyByZXN1bHQsIG9yIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2suaW52b2tlSG9va3MgPSBmdW5jdGlvbiAoaG9va3MsIGRvbmVDYWxsYmFjaykge1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBob29rcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICB2YXIgaG9va1Jlc3VsdCA9IGhvb2tzW2lkeF0uaW52b2tlSG9vaygpO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1Byb21pc2UoaG9va1Jlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nSG9va3MgPSBob29rcy5zbGljZShpZHggKyAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNpdGlvbkhvb2suY2hhaW4ocmVtYWluaW5nSG9va3MsIGhvb2tSZXN1bHQpLnRoZW4oZG9uZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSdW4gYWxsIFRyYW5zaXRpb25Ib29rcywgaWdub3JpbmcgdGhlaXIgcmV0dXJuIHZhbHVlLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLnJ1bkFsbEhvb2tzID0gZnVuY3Rpb24gKGhvb2tzKSB7XG4gICAgICAgIGhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGhvb2suaW52b2tlSG9vaygpOyB9KTtcbiAgICB9O1xuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5sb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uLnJvdXRlci5zdGF0ZVNlcnZpY2UuZGVmYXVsdEVycm9ySGFuZGxlcigpKGVycik7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uSG9vay5wcm90b3R5cGUuaW52b2tlSG9vayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGhvb2sgPSB0aGlzLnJlZ2lzdGVyZWRIb29rO1xuICAgICAgICBpZiAoaG9vay5fZGVyZWdpc3RlcmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbm90Q3VycmVudCA9IHRoaXMuZ2V0Tm90Q3VycmVudFJlamVjdGlvbigpO1xuICAgICAgICBpZiAobm90Q3VycmVudClcbiAgICAgICAgICAgIHJldHVybiBub3RDdXJyZW50O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZUhvb2tJbnZvY2F0aW9uKHRoaXMsIHRoaXMudHJhbnNpdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBpbnZva2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhvb2suY2FsbGJhY2suY2FsbChvcHRpb25zLmJpbmQsIF90aGlzLnRyYW5zaXRpb24sIF90aGlzLnN0YXRlQ29udGV4dCk7IH07XG4gICAgICAgIHZhciBub3JtYWxpemVFcnIgPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLm5vcm1hbGl6ZShlcnIpLnRvUHJvbWlzZSgpOyB9O1xuICAgICAgICB2YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBob29rLmV2ZW50VHlwZS5nZXRFcnJvckhhbmRsZXIoX3RoaXMpKGVycik7IH07XG4gICAgICAgIHZhciBoYW5kbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBob29rLmV2ZW50VHlwZS5nZXRSZXN1bHRIYW5kbGVyKF90aGlzKShyZXN1bHQpOyB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGludm9rZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5zeW5jaHJvbm91cyAmJiBwcmVkaWNhdGVzXzEuaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNhdGNoKG5vcm1hbGl6ZUVycikudGhlbihoYW5kbGVSZXN1bHQsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiBjYWxsYmFjayB0aHJvd3MgKHN5bmNocm9ub3VzbHkpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IocmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5ub3JtYWxpemUoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoaG9vay5pbnZva2VMaW1pdCAmJiArK2hvb2suaW52b2tlQ291bnQgPj0gaG9vay5pbnZva2VMaW1pdCkge1xuICAgICAgICAgICAgICAgIGhvb2suZGVyZWdpc3RlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBoYW5kbGVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBUcmFuc2l0aW9uIEhvb2suXG4gICAgICpcbiAgICAgKiBBIGhvb2sgY2FuIHJldHVybiBmYWxzZSAoY2FuY2VsKSwgYSBUYXJnZXRTdGF0ZSAocmVkaXJlY3QpLFxuICAgICAqIG9yIGEgcHJvbWlzZSAod2hpY2ggbWF5IGxhdGVyIHJlc29sdmUgdG8gZmFsc2Ugb3IgYSByZWRpcmVjdClcbiAgICAgKlxuICAgICAqIFRoaXMgYWxzbyBoYW5kbGVzIFwidHJhbnNpdGlvbiBzdXBlcnNlZGVkXCIgLS0gd2hlbiBhIG5ldyB0cmFuc2l0aW9uXG4gICAgICogd2FzIHN0YXJ0ZWQgd2hpbGUgdGhlIGhvb2sgd2FzIHN0aWxsIHJ1bm5pbmdcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5wcm90b3R5cGUuaGFuZGxlSG9va1Jlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vdEN1cnJlbnQgPSB0aGlzLmdldE5vdEN1cnJlbnRSZWplY3Rpb24oKTtcbiAgICAgICAgaWYgKG5vdEN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbm90Q3VycmVudDtcbiAgICAgICAgLy8gSG9vayByZXR1cm5lZCBhIHByb21pc2VcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHByb21pc2UsIHRoZW4gcmVwcm9jZXNzIHdpdGggdGhlIHJlc3VsdGluZyB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUhvb2tSZXN1bHQodmFsKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZUhvb2tSZXN1bHQocmVzdWx0LCB0aGlzLnRyYW5zaXRpb24sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIC8vIEhvb2sgcmV0dXJuZWQgZmFsc2VcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIEFib3J0IHRoaXMgVHJhbnNpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uYWJvcnRlZCgnSG9vayBhYm9ydGVkIHRyYW5zaXRpb24nKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNUYXJnZXRTdGF0ZSA9IGhvZl8xLmlzKHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpO1xuICAgICAgICAvLyBob29rIHJldHVybmVkIGEgVGFyZ2V0U3RhdGVcbiAgICAgICAgaWYgKGlzVGFyZ2V0U3RhdGUocmVzdWx0KSkge1xuICAgICAgICAgICAgLy8gSGFsdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uIGFuZCByZWRpcmVjdCAoYSBuZXcgVHJhbnNpdGlvbikgdG8gdGhlIFRhcmdldFN0YXRlLlxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24ucmVkaXJlY3RlZChyZXN1bHQpLnRvUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBSZWplY3Rpb24gcHJvbWlzZSBpZiB0aGUgdHJhbnNpdGlvbiBpcyBubyBsb25nZXIgY3VycmVudCBkdWVcbiAgICAgKiB0byBhIHN0b3BwZWQgcm91dGVyIChkaXNwb3NlZCksIG9yIGEgbmV3IHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWQgYW5kIHN1cGVyc2VkZWQgdGhpcyBvbmUuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLmdldE5vdEN1cnJlbnRSZWplY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyO1xuICAgICAgICAvLyBUaGUgcm91dGVyIGlzIHN0b3BwZWRcbiAgICAgICAgaWYgKHJvdXRlci5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoXCJVSVJvdXRlciBpbnN0YW5jZSAjXCIgKyByb3V0ZXIuJGlkICsgXCIgaGFzIGJlZW4gc3RvcHBlZCAoZGlzcG9zZWQpXCIpLnRvUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb24uX2Fib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRyYW5zaXRpb24gaXMgbm8gbG9uZ2VyIGN1cnJlbnQuXG4gICAgICAgIC8vIEFub3RoZXIgdHJhbnNpdGlvbiBzdGFydGVkIHdoaWxlIHRoaXMgaG9vayB3YXMgc3RpbGwgcnVubmluZy5cbiAgICAgICAgaWYgKHRoaXMuaXNTdXBlcnNlZGVkKCkpIHtcbiAgICAgICAgICAgIC8vIEFib3J0IHRoaXMgdHJhbnNpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uc3VwZXJzZWRlZCh0aGlzLm9wdGlvbnMuY3VycmVudCgpKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBvcHRpb25zID0gX2Eub3B0aW9ucywgcmVnaXN0ZXJlZEhvb2sgPSBfYS5yZWdpc3RlcmVkSG9vaztcbiAgICAgICAgdmFyIGV2ZW50ID0gaG9mXzEucGFyc2UoJ3RyYWNlRGF0YS5ob29rVHlwZScpKG9wdGlvbnMpIHx8ICdpbnRlcm5hbCcsIGNvbnRleHQgPSBob2ZfMS5wYXJzZSgndHJhY2VEYXRhLmNvbnRleHQuc3RhdGUubmFtZScpKG9wdGlvbnMpIHx8IGhvZl8xLnBhcnNlKCd0cmFjZURhdGEuY29udGV4dCcpKG9wdGlvbnMpIHx8ICd1bmtub3duJywgbmFtZSA9IHN0cmluZ3NfMS5mblRvU3RyaW5nKHJlZ2lzdGVyZWRIb29rLmNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50ICsgXCIgY29udGV4dDogXCIgKyBjb250ZXh0ICsgXCIsIFwiICsgc3RyaW5nc18xLm1heExlbmd0aCgyMDAsIG5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlc2UgR2V0UmVzdWx0SGFuZGxlcihzKSBhcmUgdXNlZCBieSBbW2ludm9rZUhvb2tdXSBiZWxvd1xuICAgICAqIEVhY2ggSG9va1R5cGUgY2hvb3NlcyBhIEdldFJlc3VsdEhhbmRsZXIgKFNlZTogW1tUcmFuc2l0aW9uU2VydmljZS5fZGVmaW5lQ29yZUV2ZW50c11dKVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLkhBTkRMRV9SRVNVTFQgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gaG9vay5oYW5kbGVIb29rUmVzdWx0KHJlc3VsdCk7XG4gICAgfTsgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcmVzdWx0IGlzIGEgcHJvbWlzZSByZWplY3Rpb24sIGxvZyBpdC5cbiAgICAgKiBPdGhlcndpc2UsIGlnbm9yZSB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLkxPR19SRUpFQ1RFRF9SRVNVTFQgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBwcmVkaWNhdGVzXzEuaXNQcm9taXNlKHJlc3VsdCkgJiYgcmVzdWx0LmNhdGNoKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGhvb2subG9nRXJyb3IocmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5ub3JtYWxpemUoZXJyKSk7IH0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07IH07XG4gICAgLyoqXG4gICAgICogVGhlc2UgR2V0RXJyb3JIYW5kbGVyKHMpIGFyZSB1c2VkIGJ5IFtbaW52b2tlSG9va11dIGJlbG93XG4gICAgICogRWFjaCBIb29rVHlwZSBjaG9vc2VzIGEgR2V0RXJyb3JIYW5kbGVyIChTZWU6IFtbVHJhbnNpdGlvblNlcnZpY2UuX2RlZmluZUNvcmVFdmVudHNdXSlcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5MT0dfRVJST1IgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBob29rLmxvZ0Vycm9yKGVycm9yKTsgfTsgfTtcbiAgICBUcmFuc2l0aW9uSG9vay5SRUpFQ1RfRVJST1IgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBjb21tb25fMS5zaWxlbnRSZWplY3Rpb24oZXJyb3IpOyB9OyB9O1xuICAgIFRyYW5zaXRpb25Ib29rLlRIUk9XX0VSUk9SID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9OyB9O1xuICAgIHJldHVybiBUcmFuc2l0aW9uSG9vaztcbn0oKSk7XG5leHBvcnRzLlRyYW5zaXRpb25Ib29rID0gVHJhbnNpdGlvbkhvb2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uSG9vay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbnZhciB0cmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uXCIpO1xudmFyIGhvb2tSZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vaG9va1JlZ2lzdHJ5XCIpO1xudmFyIGNvcmVSZXNvbHZhYmxlc18xID0gcmVxdWlyZShcIi4uL2hvb2tzL2NvcmVSZXNvbHZhYmxlc1wiKTtcbnZhciByZWRpcmVjdFRvXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvcmVkaXJlY3RUb1wiKTtcbnZhciBvbkVudGVyRXhpdFJldGFpbl8xID0gcmVxdWlyZShcIi4uL2hvb2tzL29uRW50ZXJFeGl0UmV0YWluXCIpO1xudmFyIHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuLi9ob29rcy9yZXNvbHZlXCIpO1xudmFyIHZpZXdzXzEgPSByZXF1aXJlKFwiLi4vaG9va3Mvdmlld3NcIik7XG52YXIgdXBkYXRlR2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2hvb2tzL3VwZGF0ZUdsb2JhbHNcIik7XG52YXIgdXJsXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvdXJsXCIpO1xudmFyIGxhenlMb2FkXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvbGF6eUxvYWRcIik7XG52YXIgdHJhbnNpdGlvbkV2ZW50VHlwZV8xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkV2ZW50VHlwZVwiKTtcbnZhciB0cmFuc2l0aW9uSG9va18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBpZ25vcmVkVHJhbnNpdGlvbl8xID0gcmVxdWlyZShcIi4uL2hvb2tzL2lnbm9yZWRUcmFuc2l0aW9uXCIpO1xudmFyIGludmFsaWRUcmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvaW52YWxpZFRyYW5zaXRpb25cIik7XG4vKipcbiAqIFRoZSBkZWZhdWx0IFtbVHJhbnNpdGlvbl1dIG9wdGlvbnMuXG4gKlxuICogSW5jbHVkZSB0aGlzIG9iamVjdCB3aGVuIGFwcGx5aW5nIGN1c3RvbSBkZWZhdWx0czpcbiAqIGxldCByZWxvYWRPcHRzID0geyByZWxvYWQ6IHRydWUsIG5vdGlmeTogdHJ1ZSB9XG4gKiBsZXQgb3B0aW9ucyA9IGRlZmF1bHRzKHRoZWlyT3B0cywgY3VzdG9tRGVmYXVsdHMsIGRlZmF1bHRPcHRpb25zKTtcbiAqL1xuZXhwb3J0cy5kZWZhdWx0VHJhbnNPcHRzID0ge1xuICAgIGxvY2F0aW9uOiB0cnVlLFxuICAgIHJlbGF0aXZlOiBudWxsLFxuICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgIG5vdGlmeTogdHJ1ZSxcbiAgICByZWxvYWQ6IGZhbHNlLFxuICAgIGN1c3RvbToge30sXG4gICAgY3VycmVudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICBzb3VyY2U6ICd1bmtub3duJyxcbn07XG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byBUcmFuc2l0aW9ucy5cbiAqXG4gKiAtIE1vc3QgaW1wb3J0YW50bHksIGl0IGFsbG93cyBnbG9iYWwgVHJhbnNpdGlvbiBIb29rcyB0byBiZSByZWdpc3RlcmVkLlxuICogLSBJdCBhbGxvd3MgdGhlIGRlZmF1bHQgdHJhbnNpdGlvbiBlcnJvciBoYW5kbGVyIHRvIGJlIHNldC5cbiAqIC0gSXQgYWxzbyBoYXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgW1tUcmFuc2l0aW9uXV0gb2JqZWN0cywgKHVzZWQgaW50ZXJuYWxseSBieSB0aGUgW1tTdGF0ZVNlcnZpY2VdXSkuXG4gKlxuICogQXQgYm9vdHN0cmFwLCBbW1VJUm91dGVyXV0gY3JlYXRlcyBhIHNpbmdsZSBpbnN0YW5jZSAoc2luZ2xldG9uKSBvZiB0aGlzIGNsYXNzLlxuICovXG52YXIgVHJhbnNpdGlvblNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uU2VydmljZShfcm91dGVyKSB7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25Db3VudCA9IDA7XG4gICAgICAgIC8qKiBAaGlkZGVuIFRoZSB0cmFuc2l0aW9uIGhvb2sgdHlwZXMsIHN1Y2ggYXMgYG9uRW50ZXJgLCBgb25TdGFydGAsIGV0YyAqL1xuICAgICAgICB0aGlzLl9ldmVudFR5cGVzID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuIFRoZSByZWdpc3RlcmVkIHRyYW5zaXRpb24gaG9va3MgKi9cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZEhvb2tzID0ge307XG4gICAgICAgIC8qKiBAaGlkZGVuIFRoZSAgcGF0aHMgb24gYSBjcml0ZXJpYSBvYmplY3QgKi9cbiAgICAgICAgdGhpcy5fY3JpdGVyaWFQYXRocyA9IHt9O1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSBfcm91dGVyO1xuICAgICAgICB0aGlzLiR2aWV3ID0gX3JvdXRlci52aWV3U2VydmljZTtcbiAgICAgICAgdGhpcy5fZGVyZWdpc3Rlckhvb2tGbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGx1Z2luYXBpID0gY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMoaG9mXzEudmFsKHRoaXMpLCB7fSwgaG9mXzEudmFsKHRoaXMpLCBbXG4gICAgICAgICAgICAnX2RlZmluZVBhdGhUeXBlJyxcbiAgICAgICAgICAgICdfZGVmaW5lRXZlbnQnLFxuICAgICAgICAgICAgJ19nZXRQYXRoVHlwZXMnLFxuICAgICAgICAgICAgJ19nZXRFdmVudHMnLFxuICAgICAgICAgICAgJ2dldEhvb2tzJyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuX2RlZmluZUNvcmVQYXRocygpO1xuICAgICAgICB0aGlzLl9kZWZpbmVDb3JlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29yZVRyYW5zaXRpb25Ib29rcygpO1xuICAgICAgICBfcm91dGVyLmdsb2JhbHMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zLm9uRXZpY3QoY29yZVJlc29sdmFibGVzXzEudHJlZUNoYW5nZXNDbGVhbnVwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgW1tUcmFuc2l0aW9uSG9va0ZuXV0sIGNhbGxlZCAqd2hpbGUgYSB0cmFuc2l0aW9uIGlzIGJlaW5nIGNvbnN0cnVjdGVkKi5cbiAgICAgKlxuICAgICAqIFJlZ2lzdGVycyBhIHRyYW5zaXRpb24gbGlmZWN5Y2xlIGhvb2ssIHdoaWNoIGlzIGludm9rZWQgZHVyaW5nIHRyYW5zaXRpb24gY29uc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBsb3cgbGV2ZWwgaG9vayBzaG91bGQgb25seSBiZSB1c2VkIGJ5IHBsdWdpbnMuXG4gICAgICogVGhpcyBjYW4gYmUgYSB1c2VmdWwgdGltZSBmb3IgcGx1Z2lucyB0byBhZGQgcmVzb2x2ZXMgb3IgbXV0YXRlIHRoZSB0cmFuc2l0aW9uIGFzIG5lZWRlZC5cbiAgICAgKiBUaGUgU3RpY2t5IFN0YXRlcyBwbHVnaW4gdXNlcyB0aGlzIGhvb2sgdG8gbW9kaWZ5IHRoZSB0cmVlY2hhbmdlcy5cbiAgICAgKlxuICAgICAqICMjIyBMaWZlY3ljbGVcbiAgICAgKlxuICAgICAqIGBvbkNyZWF0ZWAgaG9va3MgYXJlIGludm9rZWQgKndoaWxlIGEgdHJhbnNpdGlvbiBpcyBiZWluZyBjb25zdHJ1Y3RlZCouXG4gICAgICpcbiAgICAgKiAjIyMgUmV0dXJuIHZhbHVlXG4gICAgICpcbiAgICAgKiBUaGUgaG9vaydzIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKiBAcGFyYW0gY3JpdGVyaWEgZGVmaW5lcyB3aGljaCBUcmFuc2l0aW9ucyB0aGUgSG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBob29rIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgcmVnaXN0cmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBob29rLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkNyZWF0ZSA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uQmVmb3JlID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uRXhpdCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uUmV0YWluID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25FbnRlciA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uRmluaXNoID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZGlzcG9zZVxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICBjb21tb25fMS52YWx1ZXModGhpcy5fcmVnaXN0ZXJlZEhvb2tzKS5mb3JFYWNoKGZ1bmN0aW9uIChob29rc0FycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3NBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgICAgICAgICAgaG9vay5fZGVyZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKGhvb2tzQXJyYXksIGhvb2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBbW1RyYW5zaXRpb25dXSBvYmplY3RcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgVHJhbnNpdGlvbiBvYmplY3RzLlxuICAgICAqIEl0IGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgW1tTdGF0ZVNlcnZpY2VdXSBhbmQgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgY2FsbGVkIGJ5IGFwcGxpY2F0aW9uIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbVBhdGggdGhlIHBhdGggdG8gdGhlIGN1cnJlbnQgc3RhdGUgKHRoZSBmcm9tIHN0YXRlKVxuICAgICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSB0aGUgdGFyZ2V0IHN0YXRlIChkZXN0aW5hdGlvbilcbiAgICAgKiBAcmV0dXJucyBhIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zaXRpb25fMS5UcmFuc2l0aW9uKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSwgdGhpcy5fcm91dGVyKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9kZWZpbmVDb3JlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgUGhhc2UgPSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlO1xuICAgICAgICB2YXIgVEggPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rO1xuICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLl9jcml0ZXJpYVBhdGhzO1xuICAgICAgICB2YXIgTk9STUFMX1NPUlQgPSBmYWxzZSwgUkVWRVJTRV9TT1JUID0gdHJ1ZTtcbiAgICAgICAgdmFyIFNZTkNIUk9OT1VTID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoJ29uQ3JlYXRlJywgUGhhc2UuQ1JFQVRFLCAwLCBwYXRocy50bywgTk9STUFMX1NPUlQsIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsIFRILlRIUk9XX0VSUk9SLCBTWU5DSFJPTk9VUyk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvbkJlZm9yZScsIFBoYXNlLkJFRk9SRSwgMCwgcGF0aHMudG8pO1xuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudCgnb25TdGFydCcsIFBoYXNlLlJVTiwgMCwgcGF0aHMudG8pO1xuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudCgnb25FeGl0JywgUGhhc2UuUlVOLCAxMDAsIHBhdGhzLmV4aXRpbmcsIFJFVkVSU0VfU09SVCk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvblJldGFpbicsIFBoYXNlLlJVTiwgMjAwLCBwYXRocy5yZXRhaW5lZCk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvbkVudGVyJywgUGhhc2UuUlVOLCAzMDAsIHBhdGhzLmVudGVyaW5nKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoJ29uRmluaXNoJywgUGhhc2UuUlVOLCA0MDAsIHBhdGhzLnRvKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoJ29uU3VjY2VzcycsIFBoYXNlLlNVQ0NFU1MsIDAsIHBhdGhzLnRvLCBOT1JNQUxfU09SVCwgVEguTE9HX1JFSkVDVEVEX1JFU1VMVCwgVEguTE9HX0VSUk9SLCBTWU5DSFJPTk9VUyk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvbkVycm9yJywgUGhhc2UuRVJST1IsIDAsIHBhdGhzLnRvLCBOT1JNQUxfU09SVCwgVEguTE9HX1JFSkVDVEVEX1JFU1VMVCwgVEguTE9HX0VSUk9SLCBTWU5DSFJPTk9VUyk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZGVmaW5lQ29yZVBhdGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgU1RBVEUgPSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFLCBUUkFOU0lUSU9OID0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5UUkFOU0lUSU9OO1xuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZSgndG8nLCBUUkFOU0lUSU9OKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoJ2Zyb20nLCBUUkFOU0lUSU9OKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoJ2V4aXRpbmcnLCBTVEFURSk7XG4gICAgICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKCdyZXRhaW5lZCcsIFNUQVRFKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoJ2VudGVyaW5nJywgU1RBVEUpO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2RlZmluZUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGhvb2tQaGFzZSwgaG9va09yZGVyLCBjcml0ZXJpYU1hdGNoUGF0aCwgcmV2ZXJzZVNvcnQsIGdldFJlc3VsdEhhbmRsZXIsIGdldEVycm9ySGFuZGxlciwgc3luY2hyb25vdXMpIHtcbiAgICAgICAgaWYgKHJldmVyc2VTb3J0ID09PSB2b2lkIDApIHsgcmV2ZXJzZVNvcnQgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoZ2V0UmVzdWx0SGFuZGxlciA9PT0gdm9pZCAwKSB7IGdldFJlc3VsdEhhbmRsZXIgPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLkhBTkRMRV9SRVNVTFQ7IH1cbiAgICAgICAgaWYgKGdldEVycm9ySGFuZGxlciA9PT0gdm9pZCAwKSB7IGdldEVycm9ySGFuZGxlciA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suUkVKRUNUX0VSUk9SOyB9XG4gICAgICAgIGlmIChzeW5jaHJvbm91cyA9PT0gdm9pZCAwKSB7IHN5bmNocm9ub3VzID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IG5ldyB0cmFuc2l0aW9uRXZlbnRUeXBlXzEuVHJhbnNpdGlvbkV2ZW50VHlwZShuYW1lLCBob29rUGhhc2UsIGhvb2tPcmRlciwgY3JpdGVyaWFNYXRjaFBhdGgsIHJldmVyc2VTb3J0LCBnZXRSZXN1bHRIYW5kbGVyLCBnZXRFcnJvckhhbmRsZXIsIHN5bmNocm9ub3VzKTtcbiAgICAgICAgdGhpcy5fZXZlbnRUeXBlcy5wdXNoKGV2ZW50VHlwZSk7XG4gICAgICAgIGhvb2tSZWdpc3RyeV8xLm1ha2VFdmVudCh0aGlzLCB0aGlzLCBldmVudFR5cGUpO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2dldEV2ZW50cyA9IGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbkhvb2tUeXBlcyA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQocGhhc2UpXG4gICAgICAgICAgICA/IHRoaXMuX2V2ZW50VHlwZXMuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmhvb2tQaGFzZSA9PT0gcGhhc2U7IH0pXG4gICAgICAgICAgICA6IHRoaXMuX2V2ZW50VHlwZXMuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zaXRpb25Ib29rVHlwZXMuc29ydChmdW5jdGlvbiAobCwgcikge1xuICAgICAgICAgICAgdmFyIGNtcEJ5UGhhc2UgPSBsLmhvb2tQaGFzZSAtIHIuaG9va1BoYXNlO1xuICAgICAgICAgICAgcmV0dXJuIGNtcEJ5UGhhc2UgPT09IDAgPyBsLmhvb2tPcmRlciAtIHIuaG9va09yZGVyIDogY21wQnlQaGFzZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgUGF0aCB0byBiZSB1c2VkIGFzIGEgY3JpdGVyaW9uIGFnYWluc3QgYSBUcmVlQ2hhbmdlcyBwYXRoXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZTogdGhlIGBleGl0aW5nYCBwYXRoIGluIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyBhIFNUQVRFIHNjb3BlZCBwYXRoLlxuICAgICAqIEl0IHdhcyBkZWZpbmVkIGJ5IGNhbGxpbmcgYGRlZmluZVRyZWVDaGFuZ2VzQ3JpdGVyaW9uKCdleGl0aW5nJywgVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSlgXG4gICAgICogRWFjaCBzdGF0ZSBpbiB0aGUgZXhpdGluZyBwYXRoIGlzIGNoZWNrZWQgYWdhaW5zdCB0aGUgY3JpdGVyaWEgYW5kIHJldHVybmVkIGFzIHBhcnQgb2YgdGhlIG1hdGNoLlxuICAgICAqXG4gICAgICogQW5vdGhlciBleGFtcGxlOiB0aGUgYHRvYCBwYXRoIGluIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyBhIFRSQU5TSVRJT04gc2NvcGVkIHBhdGguXG4gICAgICogSXQgd2FzIGRlZmluZWQgYnkgY2FsbGluZyBgZGVmaW5lVHJlZUNoYW5nZXNDcml0ZXJpb24oJ3RvJywgVHJhbnNpdGlvbkhvb2tTY29wZS5UUkFOU0lUSU9OKWBcbiAgICAgKiBPbmx5IHRoZSB0YWlsIG9mIHRoZSBgdG9gIHBhdGggaXMgY2hlY2tlZCBhZ2FpbnN0IHRoZSBjcml0ZXJpYSBhbmQgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGUgbWF0Y2guXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9kZWZpbmVQYXRoVHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBob29rU2NvcGUpIHtcbiAgICAgICAgdGhpcy5fY3JpdGVyaWFQYXRoc1tuYW1lXSA9IHsgbmFtZTogbmFtZSwgc2NvcGU6IGhvb2tTY29wZSB9O1xuICAgIH07XG4gICAgLyoqICogQGhpZGRlbiAqL1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0UGF0aFR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JpdGVyaWFQYXRocztcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLmdldEhvb2tzID0gZnVuY3Rpb24gKGhvb2tOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkSG9va3NbaG9va05hbWVdO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX3JlZ2lzdGVyQ29yZVRyYW5zaXRpb25Ib29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZucyA9IHRoaXMuX2RlcmVnaXN0ZXJIb29rRm5zO1xuICAgICAgICBmbnMuYWRkQ29yZVJlc29sdmVzID0gY29yZVJlc29sdmFibGVzXzEucmVnaXN0ZXJBZGRDb3JlUmVzb2x2YWJsZXModGhpcyk7XG4gICAgICAgIGZucy5pZ25vcmVkID0gaWdub3JlZFRyYW5zaXRpb25fMS5yZWdpc3Rlcklnbm9yZWRUcmFuc2l0aW9uSG9vayh0aGlzKTtcbiAgICAgICAgZm5zLmludmFsaWQgPSBpbnZhbGlkVHJhbnNpdGlvbl8xLnJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIHJlZGlyZWN0VG8gaG9va1xuICAgICAgICBmbnMucmVkaXJlY3RUbyA9IHJlZGlyZWN0VG9fMS5yZWdpc3RlclJlZGlyZWN0VG9Ib29rKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIG9uRXhpdC9SZXRhaW4vRW50ZXIgc3RhdGUgaG9va3NcbiAgICAgICAgZm5zLm9uRXhpdCA9IG9uRW50ZXJFeGl0UmV0YWluXzEucmVnaXN0ZXJPbkV4aXRIb29rKHRoaXMpO1xuICAgICAgICBmbnMub25SZXRhaW4gPSBvbkVudGVyRXhpdFJldGFpbl8xLnJlZ2lzdGVyT25SZXRhaW5Ib29rKHRoaXMpO1xuICAgICAgICBmbnMub25FbnRlciA9IG9uRW50ZXJFeGl0UmV0YWluXzEucmVnaXN0ZXJPbkVudGVySG9vayh0aGlzKTtcbiAgICAgICAgLy8gV2lyZSB1cCBSZXNvbHZlIGhvb2tzXG4gICAgICAgIGZucy5lYWdlclJlc29sdmUgPSByZXNvbHZlXzEucmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoKHRoaXMpO1xuICAgICAgICBmbnMubGF6eVJlc29sdmUgPSByZXNvbHZlXzEucmVnaXN0ZXJMYXp5UmVzb2x2ZVN0YXRlKHRoaXMpO1xuICAgICAgICBmbnMucmVzb2x2ZUFsbCA9IHJlc29sdmVfMS5yZWdpc3RlclJlc29sdmVSZW1haW5pbmcodGhpcyk7XG4gICAgICAgIC8vIFdpcmUgdXAgdGhlIFZpZXcgbWFuYWdlbWVudCBob29rc1xuICAgICAgICBmbnMubG9hZFZpZXdzID0gdmlld3NfMS5yZWdpc3RlckxvYWRFbnRlcmluZ1ZpZXdzKHRoaXMpO1xuICAgICAgICBmbnMuYWN0aXZhdGVWaWV3cyA9IHZpZXdzXzEucmVnaXN0ZXJBY3RpdmF0ZVZpZXdzKHRoaXMpO1xuICAgICAgICAvLyBVcGRhdGVzIGdsb2JhbCBzdGF0ZSBhZnRlciBhIHRyYW5zaXRpb25cbiAgICAgICAgZm5zLnVwZGF0ZUdsb2JhbHMgPSB1cGRhdGVHbG9iYWxzXzEucmVnaXN0ZXJVcGRhdGVHbG9iYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgLy8gQWZ0ZXIgZ2xvYmFscy5jdXJyZW50IGlzIHVwZGF0ZWQgYXQgcHJpb3JpdHk6IDEwMDAwXG4gICAgICAgIGZucy51cGRhdGVVcmwgPSB1cmxfMS5yZWdpc3RlclVwZGF0ZVVybCh0aGlzKTtcbiAgICAgICAgLy8gTGF6eSBsb2FkIHN0YXRlIHRyZWVzXG4gICAgICAgIGZucy5sYXp5TG9hZCA9IGxhenlMb2FkXzEucmVnaXN0ZXJMYXp5TG9hZEhvb2sodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNpdGlvblNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5UcmFuc2l0aW9uU2VydmljZSA9IFRyYW5zaXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvblNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vdXJsTWF0Y2hlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxNYXRjaGVyRmFjdG9yeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxSb3V0ZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdXJsUnVsZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxTZXJ2aWNlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB1cmxcbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gcXVvdGVSZWdFeHAoc3RyLCBwYXJhbSkge1xuICAgIHZhciBzdXJyb3VuZFBhdHRlcm4gPSBbJycsICcnXSwgcmVzdWx0ID0gc3RyLnJlcGxhY2UoL1tcXFxcXFxbXFxdXFxeJCorPy4oKXx7fV0vZywgJ1xcXFwkJicpO1xuICAgIGlmICghcGFyYW0pXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgc3dpdGNoIChwYXJhbS5zcXVhc2gpIHtcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICAgIHN1cnJvdW5kUGF0dGVybiA9IFsnKCcsICcpJyArIChwYXJhbS5pc09wdGlvbmFsID8gJz8nIDogJycpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgICAgICAgIHN1cnJvdW5kUGF0dGVybiA9IFsnKD86LygnLCAnKXwvKT8nXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gW1wiKFwiICsgcGFyYW0uc3F1YXNoICsgXCJ8XCIsICcpPyddO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyBzdXJyb3VuZFBhdHRlcm5bMF0gKyBwYXJhbS50eXBlLnBhdHRlcm4uc291cmNlICsgc3Vycm91bmRQYXR0ZXJuWzFdO1xufVxuLyoqIEBoaWRkZW4gKi9cbnZhciBtZW1vaXplVG8gPSBmdW5jdGlvbiAob2JqLCBfcHJvcCwgZm4pIHsgcmV0dXJuIChvYmpbX3Byb3BdID0gb2JqW19wcm9wXSB8fCBmbigpKTsgfTtcbi8qKiBAaGlkZGVuICovXG52YXIgc3BsaXRPblNsYXNoID0gc3RyaW5nc18xLnNwbGl0T25EZWxpbSgnLycpO1xuLyoqXG4gKiBNYXRjaGVzIFVSTHMgYWdhaW5zdCBwYXR0ZXJucy5cbiAqXG4gKiBNYXRjaGVzIFVSTHMgYWdhaW5zdCBwYXR0ZXJucyBhbmQgZXh0cmFjdHMgbmFtZWQgcGFyYW1ldGVycyBmcm9tIHRoZSBwYXRoIG9yIHRoZSBzZWFyY2hcbiAqIHBhcnQgb2YgdGhlIFVSTC5cbiAqXG4gKiBBIFVSTCBwYXR0ZXJuIGNvbnNpc3RzIG9mIGEgcGF0aCBwYXR0ZXJuLCBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5ICc/JyBhbmQgYSBsaXN0IG9mIHNlYXJjaCAocXVlcnkpXG4gKiBwYXJhbWV0ZXJzLiBNdWx0aXBsZSBzZWFyY2ggcGFyYW1ldGVyIG5hbWVzIGFyZSBzZXBhcmF0ZWQgYnkgJyYnLiBTZWFyY2ggcGFyYW1ldGVyc1xuICogZG8gbm90IGluZmx1ZW5jZSB3aGV0aGVyIG9yIG5vdCBhIFVSTCBpcyBtYXRjaGVkLCBidXQgdGhlaXIgdmFsdWVzIGFyZSBwYXNzZWQgdGhyb3VnaCBpbnRvXG4gKiB0aGUgbWF0Y2hlZCBwYXJhbWV0ZXJzIHJldHVybmVkIGJ5IFtbVXJsTWF0Y2hlci5leGVjXV0uXG4gKlxuICogLSAqUGF0aCBwYXJhbWV0ZXJzKiBhcmUgZGVmaW5lZCB1c2luZyBjdXJseSBicmFjZSBwbGFjZWhvbGRlcnMgKGAvc29tZXBhdGgve3BhcmFtfWApXG4gKiBvciBjb2xvbiBwbGFjZWhvbGRlcnMgKGAvc29tZVBhdGgvOnBhcmFtYCkuXG4gKlxuICogLSAqQSBwYXJhbWV0ZXIgUmVnRXhwKiBtYXkgYmUgZGVmaW5lZCBmb3IgYSBwYXJhbSBhZnRlciBhIGNvbG9uXG4gKiAoYC9zb21lUGF0aC97cGFyYW06W2EtekEtWjAtOV0rfWApIGluIGEgY3VybHkgYnJhY2UgcGxhY2Vob2xkZXIuXG4gKiBUaGUgcmVnZXhwIG11c3QgbWF0Y2ggZm9yIHRoZSB1cmwgdG8gYmUgbWF0Y2hlZC5cbiAqIFNob3VsZCB0aGUgcmVnZXhwIGl0c2VsZiBjb250YWluIGN1cmx5IGJyYWNlcywgdGhleSBtdXN0IGJlIGluIG1hdGNoZWQgcGFpcnMgb3IgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoLlxuICpcbiAqIE5vdGU6IGEgUmVnRXhwIHBhcmFtZXRlciB3aWxsIGVuY29kZSBpdHMgdmFsdWUgdXNpbmcgZWl0aGVyIFtbUGFyYW1UeXBlcy5wYXRoXV0gb3IgW1tQYXJhbVR5cGVzLnF1ZXJ5XV0uXG4gKlxuICogLSAqQ3VzdG9tIHBhcmFtZXRlciB0eXBlcyogbWF5IGFsc28gYmUgc3BlY2lmaWVkIGFmdGVyIGEgY29sb24gKGAvc29tZVBhdGgve3BhcmFtOmludH1gKSBpbiBjdXJseSBicmFjZSBwYXJhbWV0ZXJzLlxuICogICBTZWUgW1tVcmxNYXRjaGVyRmFjdG9yeS50eXBlXV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogLSAqQ2F0Y2gtYWxsIHBhcmFtZXRlcnMqIGFyZSBkZWZpbmVkIHVzaW5nIGFuIGFzdGVyaXNrIHBsYWNlaG9sZGVyIChgL3NvbWVwYXRoLypjYXRjaGFsbHBhcmFtYCkuXG4gKiAgIEEgY2F0Y2gtYWxsICogcGFyYW1ldGVyIHZhbHVlIHdpbGwgY29udGFpbiB0aGUgcmVtYWluZGVyIG9mIHRoZSBVUkwuXG4gKlxuICogLS0tXG4gKlxuICogUGFyYW1ldGVyIG5hbWVzIG1heSBjb250YWluIG9ubHkgd29yZCBjaGFyYWN0ZXJzIChsYXRpbiBsZXR0ZXJzLCBkaWdpdHMsIGFuZCB1bmRlcnNjb3JlKSBhbmRcbiAqIG11c3QgYmUgdW5pcXVlIHdpdGhpbiB0aGUgcGF0dGVybiAoYWNyb3NzIGJvdGggcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMpLlxuICogQSBwYXRoIHBhcmFtZXRlciBtYXRjaGVzIGFueSBudW1iZXIgb2YgY2hhcmFjdGVycyBvdGhlciB0aGFuICcvJy4gRm9yIGNhdGNoLWFsbFxuICogcGxhY2Vob2xkZXJzIHRoZSBwYXRoIHBhcmFtZXRlciBtYXRjaGVzIGFueSBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAqIGAnL2hlbGxvLydgIC0gTWF0Y2hlcyBvbmx5IGlmIHRoZSBwYXRoIGlzIGV4YWN0bHkgJy9oZWxsby8nLiBUaGVyZSBpcyBubyBzcGVjaWFsIHRyZWF0bWVudCBmb3JcbiAqICAgdHJhaWxpbmcgc2xhc2hlcywgYW5kIHBhdHRlcm5zIGhhdmUgdG8gbWF0Y2ggdGhlIGVudGlyZSBwYXRoLCBub3QganVzdCBhIHByZWZpeC5cbiAqICogYCcvdXNlci86aWQnYCAtIE1hdGNoZXMgJy91c2VyL2JvYicgb3IgJy91c2VyLzEyMzQhISEnIG9yIGV2ZW4gJy91c2VyLycgYnV0IG5vdCAnL3VzZXInIG9yXG4gKiAgICcvdXNlci9ib2IvZGV0YWlscycuIFRoZSBzZWNvbmQgcGF0aCBzZWdtZW50IHdpbGwgYmUgY2FwdHVyZWQgYXMgdGhlIHBhcmFtZXRlciAnaWQnLlxuICogKiBgJy91c2VyL3tpZH0nYCAtIFNhbWUgYXMgdGhlIHByZXZpb3VzIGV4YW1wbGUsIGJ1dCB1c2luZyBjdXJseSBicmFjZSBzeW50YXguXG4gKiAqIGAnL3VzZXIve2lkOlteL10qfSdgIC0gU2FtZSBhcyB0aGUgcHJldmlvdXMgZXhhbXBsZS5cbiAqICogYCcvdXNlci97aWQ6WzAtOWEtZkEtRl17MSw4fX0nYCAtIFNpbWlsYXIgdG8gdGhlIHByZXZpb3VzIGV4YW1wbGUsIGJ1dCBvbmx5IG1hdGNoZXMgaWYgdGhlIGlkXG4gKiAgIHBhcmFtZXRlciBjb25zaXN0cyBvZiAxIHRvIDggaGV4IGRpZ2l0cy5cbiAqICogYCcvZmlsZXMve3BhdGg6Lip9J2AgLSBNYXRjaGVzIGFueSBVUkwgc3RhcnRpbmcgd2l0aCAnL2ZpbGVzLycgYW5kIGNhcHR1cmVzIHRoZSByZXN0IG9mIHRoZVxuICogICBwYXRoIGludG8gdGhlIHBhcmFtZXRlciAncGF0aCcuXG4gKiAqIGAnL2ZpbGVzLypwYXRoJ2AgLSBkaXR0by5cbiAqICogYCcvY2FsZW5kYXIve3N0YXJ0OmRhdGV9J2AgLSBNYXRjaGVzIFwiL2NhbGVuZGFyLzIwMTQtMTEtMTJcIiAoYmVjYXVzZSB0aGUgcGF0dGVybiBkZWZpbmVkXG4gKiAgIGluIHRoZSBidWlsdC1pbiAgYGRhdGVgIFBhcmFtVHlwZSBtYXRjaGVzIGAyMDE0LTExLTEyYCkgYW5kIHByb3ZpZGVzIGEgRGF0ZSBvYmplY3QgaW4gJHN0YXRlUGFyYW1zLnN0YXJ0XG4gKlxuICovXG52YXIgVXJsTWF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcGF0dGVybiBUaGUgcGF0dGVybiB0byBjb21waWxlIGludG8gYSBtYXRjaGVyLlxuICAgICAqIEBwYXJhbSBwYXJhbVR5cGVzIFRoZSBbW1BhcmFtVHlwZXNdXSByZWdpc3RyeVxuICAgICAqIEBwYXJhbSBjb25maWcgIEEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKiAtIGBjYXNlSW5zZW5zaXRpdmVgIC0gYHRydWVgIGlmIFVSTCBtYXRjaGluZyBzaG91bGQgYmUgY2FzZSBpbnNlbnNpdGl2ZSwgb3RoZXJ3aXNlIGBmYWxzZWAsIHRoZSBkZWZhdWx0IHZhbHVlIChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSkgaXMgYGZhbHNlYC5cbiAgICAgKiAtIGBzdHJpY3RgIC0gYGZhbHNlYCBpZiBtYXRjaGluZyBhZ2FpbnN0IGEgVVJMIHdpdGggYSB0cmFpbGluZyBzbGFzaCBzaG91bGQgYmUgdHJlYXRlZCBhcyBlcXVpdmFsZW50IHRvIGEgVVJMIHdpdGhvdXQgYSB0cmFpbGluZyBzbGFzaCwgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVybE1hdGNoZXIocGF0dGVybiwgcGFyYW1UeXBlcywgcGFyYW1GYWN0b3J5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2NhY2hlID0geyBwYXRoOiBbdGhpc10gfTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fcGFyYW1zID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX3NlZ21lbnRzID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2NvbXBpbGVkID0gW107XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29tbW9uXzEuZGVmYXVsdHModGhpcy5jb25maWcsIHtcbiAgICAgICAgICAgIHBhcmFtczoge30sXG4gICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgcGFyYW1NYXA6IGNvbW1vbl8xLmlkZW50aXR5LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmluZCBhbGwgcGxhY2Vob2xkZXJzIGFuZCBjcmVhdGUgYSBjb21waWxlZCBwYXR0ZXJuLCB1c2luZyBlaXRoZXIgY2xhc3NpYyBvciBjdXJseSBzeW50YXg6XG4gICAgICAgIC8vICAgJyonIG5hbWVcbiAgICAgICAgLy8gICAnOicgbmFtZVxuICAgICAgICAvLyAgICd7JyBuYW1lICd9J1xuICAgICAgICAvLyAgICd7JyBuYW1lICc6JyByZWdleHAgJ30nXG4gICAgICAgIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gaXMgc29tZXdoYXQgY29tcGxpY2F0ZWQgZHVlIHRvIHRoZSBuZWVkIHRvIGFsbG93IGN1cmx5IGJyYWNlc1xuICAgICAgICAvLyBpbnNpZGUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVGhlIHBsYWNlaG9sZGVyIHJlZ2V4cCBicmVha3MgZG93biBhcyBmb2xsb3dzOlxuICAgICAgICAvLyAgICAoWzoqXSkoW1xcd1xcW1xcXV0rKSAgICAgICAgICAgICAgLSBjbGFzc2ljIHBsYWNlaG9sZGVyICgkMSAvICQyKSAoc2VhcmNoIHZlcnNpb24gaGFzIC0gZm9yIHNuYWtlLWNhc2UpXG4gICAgICAgIC8vICAgIFxceyhbXFx3XFxbXFxdXSspKD86XFw6XFxzKiggLi4uICkpP1xcfSAgLSBjdXJseSBicmFjZSBwbGFjZWhvbGRlciAoJDMpIHdpdGggb3B0aW9uYWwgcmVnZXhwL3R5cGUgLi4uICgkNCkgKHNlYXJjaCB2ZXJzaW9uIGhhcyAtIGZvciBzbmFrZS1jYXNlXG4gICAgICAgIC8vICAgICg/OiAuLi4gfCAuLi4gfCAuLi4gKSsgICAgICAgICAtIHRoZSByZWdleHAgY29uc2lzdHMgb2YgYW55IG51bWJlciBvZiBhdG9tcywgYW4gYXRvbSBiZWluZyBlaXRoZXJcbiAgICAgICAgLy8gICAgW157fVxcXFxdKyAgICAgICAgICAgICAgICAgICAgICAgLSBhbnl0aGluZyBvdGhlciB0aGFuIGN1cmx5IGJyYWNlcyBvciBiYWNrc2xhc2hcbiAgICAgICAgLy8gICAgXFxcXC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBhIGJhY2tzbGFzaCBlc2NhcGVcbiAgICAgICAgLy8gICAgXFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9ICAgICAgICAgIC0gYSBtYXRjaGVkIHNldCBvZiBjdXJseSBicmFjZXMgY29udGFpbmluZyBvdGhlciBhdG9tc1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSAvKFs6Kl0pKFtcXHdcXFtcXF1dKyl8XFx7KFtcXHdcXFtcXF1dKykoPzpcXDpcXHMqKCg/Oltee31cXFxcXSt8XFxcXC58XFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9KSspKT9cXH0vZztcbiAgICAgICAgdmFyIHNlYXJjaFBsYWNlaG9sZGVyID0gLyhbOl0/KShbXFx3XFxbXFxdLi1dKyl8XFx7KFtcXHdcXFtcXF0uLV0rKSg/OlxcOlxccyooKD86W157fVxcXFxdK3xcXFxcLnxcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0pKykpP1xcfS9nO1xuICAgICAgICB2YXIgcGF0dGVybnMgPSBbXTtcbiAgICAgICAgdmFyIGxhc3QgPSAwLCBtYXRjaEFycmF5O1xuICAgICAgICB2YXIgY2hlY2tQYXJhbUVycm9ycyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgaWYgKCFVcmxNYXRjaGVyLm5hbWVWYWxpZGF0b3IudGVzdChpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgbmFtZSAnXCIgKyBpZCArIFwiJyBpbiBwYXR0ZXJuICdcIiArIHBhdHRlcm4gKyBcIidcIik7XG4gICAgICAgICAgICBpZiAoY29tbW9uXzEuZmluZChfdGhpcy5fcGFyYW1zLCBob2ZfMS5wcm9wRXEoJ2lkJywgaWQpKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWUgJ1wiICsgaWQgKyBcIicgaW4gcGF0dGVybiAnXCIgKyBwYXR0ZXJuICsgXCInXCIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTcGxpdCBpbnRvIHN0YXRpYyBzZWdtZW50cyBzZXBhcmF0ZWQgYnkgcGF0aCBwYXJhbWV0ZXIgcGxhY2Vob2xkZXJzLlxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGlzIGFsd2F5cyAxIG1vcmUgdGhhbiB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMuXG4gICAgICAgIHZhciBtYXRjaERldGFpbHMgPSBmdW5jdGlvbiAobSwgaXNTZWFyY2gpIHtcbiAgICAgICAgICAgIC8vIElFWzc4XSByZXR1cm5zICcnIGZvciB1bm1hdGNoZWQgZ3JvdXBzIGluc3RlYWQgb2YgbnVsbFxuICAgICAgICAgICAgdmFyIGlkID0gbVsyXSB8fCBtWzNdO1xuICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IGlzU2VhcmNoID8gbVs0XSA6IG1bNF0gfHwgKG1bMV0gPT09ICcqJyA/ICdbXFxcXHNcXFxcU10qJyA6IG51bGwpO1xuICAgICAgICAgICAgdmFyIG1ha2VSZWdleHBUeXBlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5pbmhlcml0KHBhcmFtVHlwZXMudHlwZShpc1NlYXJjaCA/ICdxdWVyeScgOiAncGF0aCcpLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IG5ldyBSZWdFeHAoc3RyLCBfdGhpcy5jb25maWcuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICByZWdleHA6IHJlZ2V4cCxcbiAgICAgICAgICAgICAgICBjZmc6IF90aGlzLmNvbmZpZy5wYXJhbXNbaWRdLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHBhdHRlcm4uc3Vic3RyaW5nKGxhc3QsIG0uaW5kZXgpLFxuICAgICAgICAgICAgICAgIHR5cGU6ICFyZWdleHAgPyBudWxsIDogcGFyYW1UeXBlcy50eXBlKHJlZ2V4cCkgfHwgbWFrZVJlZ2V4cFR5cGUocmVnZXhwKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwLCBzZWdtZW50O1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuICAgICAgICB3aGlsZSAoKG1hdGNoQXJyYXkgPSBwbGFjZWhvbGRlci5leGVjKHBhdHRlcm4pKSkge1xuICAgICAgICAgICAgcCA9IG1hdGNoRGV0YWlscyhtYXRjaEFycmF5LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAocC5zZWdtZW50LmluZGV4T2YoJz8nKSA+PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB3ZSdyZSBpbnRvIHRoZSBzZWFyY2ggcGFydFxuICAgICAgICAgICAgY2hlY2tQYXJhbUVycm9ycyhwLmlkKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5wdXNoKHBhcmFtRmFjdG9yeS5mcm9tUGF0aChwLmlkLCBwLnR5cGUsIHRoaXMuY29uZmlnLnBhcmFtTWFwKHAuY2ZnLCBmYWxzZSkpKTtcbiAgICAgICAgICAgIHRoaXMuX3NlZ21lbnRzLnB1c2gocC5zZWdtZW50KTtcbiAgICAgICAgICAgIHBhdHRlcm5zLnB1c2goW3Auc2VnbWVudCwgY29tbW9uXzEudGFpbCh0aGlzLl9wYXJhbXMpXSk7XG4gICAgICAgICAgICBsYXN0ID0gcGxhY2Vob2xkZXIubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHNlZ21lbnQgPSBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0KTtcbiAgICAgICAgLy8gRmluZCBhbnkgc2VhcmNoIHBhcmFtZXRlciBuYW1lcyBhbmQgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbGFzdCBzZWdtZW50XG4gICAgICAgIHZhciBpID0gc2VnbWVudC5pbmRleE9mKCc/Jyk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIHZhciBzZWFyY2ggPSBzZWdtZW50LnN1YnN0cmluZyhpKTtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LnN1YnN0cmluZygwLCBpKTtcbiAgICAgICAgICAgIGlmIChzZWFyY2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSAwO1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25kaXRpb25hbC1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaEFycmF5ID0gc2VhcmNoUGxhY2Vob2xkZXIuZXhlYyhzZWFyY2gpKSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gbWF0Y2hEZXRhaWxzKG1hdGNoQXJyYXksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjaGVja1BhcmFtRXJyb3JzKHAuaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMucHVzaChwYXJhbUZhY3RvcnkuZnJvbVNlYXJjaChwLmlkLCBwLnR5cGUsIHRoaXMuY29uZmlnLnBhcmFtTWFwKHAuY2ZnLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gcGxhY2Vob2xkZXIubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiA/JlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICB0aGlzLl9jb21waWxlZCA9IHBhdHRlcm5zLm1hcChmdW5jdGlvbiAoX3BhdHRlcm4pIHsgcmV0dXJuIHF1b3RlUmVnRXhwLmFwcGx5KG51bGwsIF9wYXR0ZXJuKTsgfSkuY29uY2F0KHF1b3RlUmVnRXhwKHNlZ21lbnQpKTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVcmxNYXRjaGVyLmVuY29kZURhc2hlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBkYXNoZXMgd2l0aCBlbmNvZGVkIFwiXFwtXCJcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoLy0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIiU1QyVcIiArIGNcbiAgICAgICAgICAgICAgICAuY2hhckNvZGVBdCgwKVxuICAgICAgICAgICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgICAgICAgICAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiBHaXZlbiBhIG1hdGNoZXIsIHJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBtYXRjaGVyJ3MgcGF0aCBzZWdtZW50cyBhbmQgcGF0aCBwYXJhbXMsIGluIG9yZGVyICovXG4gICAgVXJsTWF0Y2hlci5wYXRoU2VnbWVudHNBbmRQYXJhbXMgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuICAgICAgICB2YXIgc3RhdGljU2VnbWVudHMgPSBtYXRjaGVyLl9zZWdtZW50cztcbiAgICAgICAgdmFyIHBhdGhQYXJhbXMgPSBtYXRjaGVyLl9wYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmxvY2F0aW9uID09PSBwYXJhbV8xLkRlZlR5cGUuUEFUSDsgfSk7XG4gICAgICAgIHJldHVybiBjb21tb25fMS5hcnJheVR1cGxlcyhzdGF0aWNTZWdtZW50cywgcGF0aFBhcmFtcy5jb25jYXQodW5kZWZpbmVkKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICE9PSAnJyAmJiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHgpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuIEdpdmVuIGEgbWF0Y2hlciwgcmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIG1hdGNoZXIncyBxdWVyeSBwYXJhbXMgKi9cbiAgICBVcmxNYXRjaGVyLnF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIuX3BhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubG9jYXRpb24gPT09IHBhcmFtXzEuRGVmVHlwZS5TRUFSQ0g7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0d28gVXJsTWF0Y2hlcnNcbiAgICAgKlxuICAgICAqIFRoaXMgY29tcGFyaXNvbiBmdW5jdGlvbiBjb252ZXJ0cyBhIFVybE1hdGNoZXIgaW50byBzdGF0aWMgYW5kIGR5bmFtaWMgcGF0aCBzZWdtZW50cy5cbiAgICAgKiBFYWNoIHN0YXRpYyBwYXRoIHNlZ21lbnQgaXMgYSBzdGF0aWMgc3RyaW5nIGJldHdlZW4gYSBwYXRoIHNlcGFyYXRvciAoc2xhc2ggY2hhcmFjdGVyKS5cbiAgICAgKiBFYWNoIGR5bmFtaWMgc2VnbWVudCBpcyBhIHBhdGggcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gc29ydHMgc3RhdGljIHNlZ21lbnRzIGJlZm9yZSBkeW5hbWljIG9uZXMuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR1cm4gYSBVcmxNYXRjaGVyIGFuZCBhbGwgaXRzIHBhcmVudCBtYXRjaGVycyBpbnRvIGFuIGFycmF5XG4gICAgICAgICAqIG9mIHNsYXNoIGxpdGVyYWxzICcvJywgc3RyaW5nIGxpdGVyYWxzLCBhbmQgUGFyYW0gb2JqZWN0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGV4YW1wbGUgbWF0Y2hlciBtYXRjaGVzIHN0cmluZ3MgbGlrZSBcIi9mb28vOnBhcmFtL3RhaWxcIjpcbiAgICAgICAgICogdmFyIG1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvZm9vXCIpLmFwcGVuZCgkdW1mLmNvbXBpbGUoXCIvOnBhcmFtXCIpKS5hcHBlbmQoJHVtZi5jb21waWxlKFwiL1wiKSkuYXBwZW5kKCR1bWYuY29tcGlsZShcInRhaWxcIikpO1xuICAgICAgICAgKiB2YXIgcmVzdWx0ID0gc2VnbWVudHMobWF0Y2hlcik7IC8vIFsgJy8nLCAnZm9vJywgJy8nLCBQYXJhbSwgJy8nLCAndGFpbCcgXVxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWNoZXMgdGhlIHJlc3VsdCBhcyBgbWF0Y2hlci5fY2FjaGUuc2VnbWVudHNgXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc2VnbWVudHMgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuICAgICAgICAgICAgcmV0dXJuIChtYXRjaGVyLl9jYWNoZS5zZWdtZW50cyA9XG4gICAgICAgICAgICAgICAgbWF0Y2hlci5fY2FjaGUuc2VnbWVudHMgfHxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlci5fY2FjaGUucGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChVcmxNYXRjaGVyLnBhdGhTZWdtZW50c0FuZFBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKHN0cmluZ3NfMS5qb2luTmVpZ2hib3JzUiwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHgpID8gc3BsaXRPblNsYXNoKHgpIDogeCk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBzb3J0IHdlaWdodCBmb3IgZWFjaCBzZWdtZW50IG9mIGEgVXJsTWF0Y2hlclxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWNoZXMgdGhlIHJlc3VsdCBhcyBgbWF0Y2hlci5fY2FjaGUud2VpZ2h0c2BcbiAgICAgICAgICovXG4gICAgICAgIHZhciB3ZWlnaHRzID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAobWF0Y2hlci5fY2FjaGUud2VpZ2h0cyA9XG4gICAgICAgICAgICAgICAgbWF0Y2hlci5fY2FjaGUud2VpZ2h0cyB8fFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cyhtYXRjaGVyKS5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvcnQgc2xhc2hlcyBmaXJzdCwgdGhlbiBzdGF0aWMgc3RyaW5ncywgdGhlIFBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQgPT09ICcvJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc2VnbWVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudCBpbnN0YW5jZW9mIHBhcmFtXzEuUGFyYW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhZHMgc2hvcnRlciBhcnJheSBpbi1wbGFjZSAobXV0YXRlcylcbiAgICAgICAgICovXG4gICAgICAgIHZhciBwYWRBcnJheXMgPSBmdW5jdGlvbiAobCwgciwgcGFkVmFsKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gTWF0aC5tYXgobC5sZW5ndGgsIHIubGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlIChsLmxlbmd0aCA8IGxlbilcbiAgICAgICAgICAgICAgICBsLnB1c2gocGFkVmFsKTtcbiAgICAgICAgICAgIHdoaWxlIChyLmxlbmd0aCA8IGxlbilcbiAgICAgICAgICAgICAgICByLnB1c2gocGFkVmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdlaWdodHNBID0gd2VpZ2h0cyhhKSwgd2VpZ2h0c0IgPSB3ZWlnaHRzKGIpO1xuICAgICAgICBwYWRBcnJheXMod2VpZ2h0c0EsIHdlaWdodHNCLCAwKTtcbiAgICAgICAgdmFyIF9wYWlycyA9IGNvbW1vbl8xLmFycmF5VHVwbGVzKHdlaWdodHNBLCB3ZWlnaHRzQik7XG4gICAgICAgIHZhciBjbXAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNtcCA9IF9wYWlyc1tpXVswXSAtIF9wYWlyc1tpXVsxXTtcbiAgICAgICAgICAgIGlmIChjbXAgIT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29uY2F0ZW5hdGVkIFVybE1hdGNoZXJcbiAgICAgKlxuICAgICAqIEJ1aWxkcyBhIG5ldyBVcmxNYXRjaGVyIGJ5IGFwcGVuZGluZyBhbm90aGVyIFVybE1hdGNoZXIgdG8gdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIEEgYFVybE1hdGNoZXJgIGluc3RhbmNlIHRvIGFwcGVuZCBhcyBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IGBVcmxNYXRjaGVyYC5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2godXJsKTtcbiAgICAgICAgdXJsLl9jYWNoZSA9IHtcbiAgICAgICAgICAgIHBhdGg6IHRoaXMuX2NhY2hlLnBhdGguY29uY2F0KHVybCksXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5pc1Jvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5wYXRoWzBdID09PSB0aGlzO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIGlucHV0IHBhdHRlcm4gc3RyaW5nICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0cyB0aGUgc3BlY2lmaWVkIHVybC9wYXRoIGFnYWluc3QgdGhpcyBtYXRjaGVyLlxuICAgICAqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIHVybCBtYXRjaGVzIHRoaXMgbWF0Y2hlcidzIHBhdHRlcm4sIGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjYXB0dXJlZFxuICAgICAqIHBhcmFtZXRlciB2YWx1ZXMuICBSZXR1cm5zIG51bGwgaWYgdGhlIHBhdGggZG9lcyBub3QgbWF0Y2guXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIHRoZSB2YWx1ZXNcbiAgICAgKiBvZiBhbnkgc2VhcmNoIHBhcmFtZXRlcnMgdGhhdCBhcmUgbWVudGlvbmVkIGluIHRoZSBwYXR0ZXJuLCBidXQgdGhlaXIgdmFsdWUgbWF5IGJlIG51bGwgaWZcbiAgICAgKiB0aGV5IGFyZSBub3QgcHJlc2VudCBpbiBgc2VhcmNoYC4gVGhpcyBtZWFucyB0aGF0IHNlYXJjaCBwYXJhbWV0ZXJzIGFyZSBhbHdheXMgdHJlYXRlZFxuICAgICAqIGFzIG9wdGlvbmFsLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cSZyJykuZXhlYygnL3VzZXIvYm9iJywge1xuICAgICAqICAgeDogJzEnLCBxOiAnaGVsbG8nXG4gICAgICogfSk7XG4gICAgICogLy8gcmV0dXJucyB7IGlkOiAnYm9iJywgcTogJ2hlbGxvJywgcjogbnVsbCB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAgICBUaGUgVVJMIHBhdGggdG8gbWF0Y2gsIGUuZy4gYCRsb2NhdGlvbi5wYXRoKClgLlxuICAgICAqIEBwYXJhbSBzZWFyY2ggIFVSTCBzZWFyY2ggcGFyYW1ldGVycywgZS5nLiBgJGxvY2F0aW9uLnNlYXJjaCgpYC5cbiAgICAgKiBAcGFyYW0gaGFzaCAgICBVUkwgaGFzaCBlLmcuIGAkbG9jYXRpb24uaGFzaCgpYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNhcHR1cmVkIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChwYXRoLCBzZWFyY2gsIGhhc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHNlYXJjaCA9PT0gdm9pZCAwKSB7IHNlYXJjaCA9IHt9OyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBtYXRjaCA9IG1lbW9pemVUbyh0aGlzLl9jYWNoZSwgJ3BhdHRlcm4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChbXG4gICAgICAgICAgICAgICAgJ14nLFxuICAgICAgICAgICAgICAgIGNvbW1vbl8xLnVubmVzdChfdGhpcy5fY2FjaGUucGF0aC5tYXAoaG9mXzEucHJvcCgnX2NvbXBpbGVkJykpKS5qb2luKCcnKSxcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25maWcuc3RyaWN0ID09PSBmYWxzZSA/ICcvPycgOiAnJyxcbiAgICAgICAgICAgICAgICAnJCcsXG4gICAgICAgICAgICBdLmpvaW4oJycpLCBfdGhpcy5jb25maWcuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSkuZXhlYyhwYXRoKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywgeyBpc29sYXRlOiBmYWxzZSB9KTtcbiAgICAgICAgdmFyIGFsbFBhcmFtcyA9IHRoaXMucGFyYW1ldGVycygpLCBwYXRoUGFyYW1zID0gYWxsUGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5pc1NlYXJjaCgpOyB9KSwgc2VhcmNoUGFyYW1zID0gYWxsUGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLmlzU2VhcmNoKCk7IH0pLCBuUGF0aFNlZ21lbnRzID0gdGhpcy5fY2FjaGUucGF0aC5tYXAoZnVuY3Rpb24gKHVybG0pIHsgcmV0dXJuIHVybG0uX3NlZ21lbnRzLmxlbmd0aCAtIDE7IH0pLnJlZHVjZShmdW5jdGlvbiAoYSwgeCkgeyByZXR1cm4gYSArIHg7IH0pLCB2YWx1ZXMgPSB7fTtcbiAgICAgICAgaWYgKG5QYXRoU2VnbWVudHMgIT09IG1hdGNoLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmJhbGFuY2VkIGNhcHR1cmUgZ3JvdXAgaW4gcm91dGUgJ1wiICsgdGhpcy5wYXR0ZXJuICsgXCInXCIpO1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVQYXRoQXJyYXkocGFyYW1WYWwpIHtcbiAgICAgICAgICAgIHZhciByZXZlcnNlU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdW5xdW90ZURhc2hlcyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxcLS9nLCAnLScpOyB9O1xuICAgICAgICAgICAgdmFyIHNwbGl0ID0gcmV2ZXJzZVN0cmluZyhwYXJhbVZhbCkuc3BsaXQoLy0oPyFcXFxcKS8pO1xuICAgICAgICAgICAgdmFyIGFsbFJldmVyc2VkID0gY29tbW9uXzEubWFwKHNwbGl0LCByZXZlcnNlU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5tYXAoYWxsUmV2ZXJzZWQsIHVucXVvdGVEYXNoZXMpLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYXRoU2VnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gcGF0aFBhcmFtc1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGNoW2kgKyAxXTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJhbSB2YWx1ZSBtYXRjaGVzIGEgcHJlLXJlcGxhY2UgcGFpciwgcmVwbGFjZSB0aGUgdmFsdWUgYmVmb3JlIGRlY29kaW5nLlxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJhbS5yZXBsYWNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJlcGxhY2Vbal0uZnJvbSA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW0ucmVwbGFjZVtqXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBwYXJhbS5hcnJheSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVBhdGhBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbS50eXBlLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VhcmNoW3BhcmFtLmlkXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyYW0ucmVwbGFjZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yZXBsYWNlW2pdLmZyb20gPT09IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtLnJlcGxhY2Vbal0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbS50eXBlLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc2gpXG4gICAgICAgICAgICB2YWx1ZXNbJyMnXSA9IGhhc2g7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUmV0dXJucyBhbGwgdGhlIFtbUGFyYW1dXSBvYmplY3RzIG9mIGFsbCBwYXRoIGFuZCBzZWFyY2ggcGFyYW1ldGVycyBvZiB0aGlzIHBhdHRlcm4gaW4gb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48UGFyYW0+fSAgQW4gYXJyYXkgb2YgW1tQYXJhbV1dIG9iamVjdHMuIE11c3QgYmUgdHJlYXRlZCBhcyByZWFkLW9ubHkuIElmIHRoZVxuICAgICAqICAgIHBhdHRlcm4gaGFzIG5vIHBhcmFtZXRlcnMsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgICAgICBpZiAob3B0cy5pbmhlcml0ID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXM7XG4gICAgICAgIHJldHVybiBjb21tb25fMS51bm5lc3QodGhpcy5fY2FjaGUucGF0aC5tYXAoZnVuY3Rpb24gKG1hdGNoZXIpIHsgcmV0dXJuIG1hdGNoZXIuX3BhcmFtczsgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJldHVybnMgYSBzaW5nbGUgcGFyYW1ldGVyIGZyb20gdGhpcyBVcmxNYXRjaGVyIGJ5IGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWRcbiAgICAgKiBAcGFyYW0gb3B0c1xuICAgICAqIEByZXR1cm5zIHtUfFBhcmFtfGFueXxib29sZWFufFVybE1hdGNoZXJ8bnVsbH1cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5wYXJhbWV0ZXIgPSBmdW5jdGlvbiAoaWQsIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgdmFyIGZpbmRQYXJhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5fcGFyYW1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0uaWQgPT09IGlkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9jYWNoZS5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBmaW5kUGFyYW0oKSB8fCAob3B0cy5pbmhlcml0ICE9PSBmYWxzZSAmJiBwYXJlbnQgJiYgcGFyZW50LnBhcmFtZXRlcihpZCwgb3B0cykpIHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGlucHV0IHBhcmFtZXRlciB2YWx1ZXMgYWdhaW5zdCB0aGlzIFVybE1hdGNoZXJcbiAgICAgKlxuICAgICAqIENoZWNrcyBhbiBvYmplY3QgaGFzaCBvZiBwYXJhbWV0ZXJzIHRvIHZhbGlkYXRlIHRoZWlyIGNvcnJlY3RuZXNzIGFjY29yZGluZyB0byB0aGUgcGFyYW1ldGVyXG4gICAgICogdHlwZXMgb2YgdGhpcyBgVXJsTWF0Y2hlcmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBvYmplY3QgaGFzaCBvZiBwYXJhbWV0ZXJzIHRvIHZhbGlkYXRlLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYHRydWVgIGlmIGBwYXJhbXNgIHZhbGlkYXRlcywgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUudmFsaWRhdGVzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgdmFsaWRQYXJhbVZhbCA9IGZ1bmN0aW9uIChwYXJhbSwgdmFsKSB7IHJldHVybiAhcGFyYW0gfHwgcGFyYW0udmFsaWRhdGVzKHZhbCk7IH07XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgLy8gSSdtIG5vdCBzdXJlIHdoeSB0aGlzIGNoZWNrcyBvbmx5IHRoZSBwYXJhbSBrZXlzIHBhc3NlZCBpbiwgYW5kIG5vdCBhbGwgdGhlIHBhcmFtcyBrbm93biB0byB0aGUgbWF0Y2hlclxuICAgICAgICB2YXIgcGFyYW1TY2hlbWEgPSB0aGlzLnBhcmFtZXRlcnMoKS5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtRGVmKSB7IHJldHVybiBwYXJhbXMuaGFzT3duUHJvcGVydHkocGFyYW1EZWYuaWQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtU2NoZW1hLm1hcChmdW5jdGlvbiAocGFyYW1EZWYpIHsgcmV0dXJuIHZhbGlkUGFyYW1WYWwocGFyYW1EZWYsIHBhcmFtc1twYXJhbURlZi5pZF0pOyB9KS5yZWR1Y2UoY29tbW9uXzEuYWxsVHJ1ZVIsIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlcywgY3JlYXRlcyBhIFVSTCBmcm9tIHRoaXMgVXJsTWF0Y2hlci5cbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBVUkwgdGhhdCBtYXRjaGVzIHRoaXMgcGF0dGVybiBieSBzdWJzdGl0dXRpbmcgdGhlIHNwZWNpZmllZCB2YWx1ZXNcbiAgICAgKiBmb3IgdGhlIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cScpLmZvcm1hdCh7IGlkOidib2InLCBxOid5ZXMnIH0pO1xuICAgICAqIC8vIHJldHVybnMgJy91c2VyL2JvYj9xPXllcydcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgIHRoZSB2YWx1ZXMgdG8gc3Vic3RpdHV0ZSBmb3IgdGhlIHBhcmFtZXRlcnMgaW4gdGhpcyBwYXR0ZXJuLlxuICAgICAqIEByZXR1cm5zIHRoZSBmb3JtYXR0ZWQgVVJMIChwYXRoIGFuZCBvcHRpb25hbGx5IHNlYXJjaCBwYXJ0KS5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSB7fTsgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgZnVsbCBwYXRoIG9mIFVybE1hdGNoZXJzIChpbmNsdWRpbmcgYWxsIHBhcmVudCBVcmxNYXRjaGVycylcbiAgICAgICAgdmFyIHVybE1hdGNoZXJzID0gdGhpcy5fY2FjaGUucGF0aDtcbiAgICAgICAgLy8gRXh0cmFjdCBhbGwgdGhlIHN0YXRpYyBzZWdtZW50cyBhbmQgUGFyYW1zIChwcm9jZXNzZWQgYXMgUGFyYW1EZXRhaWxzKVxuICAgICAgICAvLyBpbnRvIGFuIG9yZGVyZWQgYXJyYXlcbiAgICAgICAgdmFyIHBhdGhTZWdtZW50c0FuZFBhcmFtcyA9IHVybE1hdGNoZXJzXG4gICAgICAgICAgICAubWFwKFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zKVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkgPyB4IDogZ2V0RGV0YWlscyh4KSk7IH0pO1xuICAgICAgICAvLyBFeHRyYWN0IHRoZSBxdWVyeSBwYXJhbXMgaW50byBhIHNlcGFyYXRlIGFycmF5XG4gICAgICAgIHZhciBxdWVyeVBhcmFtcyA9IHVybE1hdGNoZXJzXG4gICAgICAgICAgICAubWFwKFVybE1hdGNoZXIucXVlcnlQYXJhbXMpXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLm1hcChnZXREZXRhaWxzKTtcbiAgICAgICAgdmFyIGlzSW52YWxpZCA9IGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0uaXNWYWxpZCA9PT0gZmFsc2U7IH07XG4gICAgICAgIGlmIChwYXRoU2VnbWVudHNBbmRQYXJhbXMuY29uY2F0KHF1ZXJ5UGFyYW1zKS5maWx0ZXIoaXNJbnZhbGlkKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIFBhcmFtLCBhcHBsaWVzIHRoZSBwYXJhbWV0ZXIgdmFsdWUsIHRoZW4gcmV0dXJucyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBpdFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGV0YWlscyhwYXJhbSkge1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIHR5cGVkIHZhbHVlXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbS52YWx1ZSh2YWx1ZXNbcGFyYW0uaWRdKTtcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gcGFyYW0udmFsaWRhdGVzKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciBpc0RlZmF1bHRWYWx1ZSA9IHBhcmFtLmlzRGVmYXVsdFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIHNxdWFzaCBtb2RlIGZvciB0aGUgcGFyYW1ldGVyXG4gICAgICAgICAgICB2YXIgc3F1YXNoID0gaXNEZWZhdWx0VmFsdWUgPyBwYXJhbS5zcXVhc2ggOiBmYWxzZTtcbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBQYXJhbWV0ZXIncyBUeXBlIHRvIGVuY29kZSB0aGUgdmFsdWVcbiAgICAgICAgICAgIHZhciBlbmNvZGVkID0gcGFyYW0udHlwZS5lbmNvZGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFyYW06IHBhcmFtLCB2YWx1ZTogdmFsdWUsIGlzVmFsaWQ6IGlzVmFsaWQsIGlzRGVmYXVsdFZhbHVlOiBpc0RlZmF1bHRWYWx1ZSwgc3F1YXNoOiBzcXVhc2gsIGVuY29kZWQ6IGVuY29kZWQgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB1cCB0aGUgcGF0aC1wb3J0aW9uIGZyb20gdGhlIGxpc3Qgb2Ygc3RhdGljIHNlZ21lbnRzIGFuZCBwYXJhbWV0ZXJzXG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gcGF0aFNlZ21lbnRzQW5kUGFyYW1zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB4KSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBhIHN0YXRpYyBzZWdtZW50IChhIHJhdyBzdHJpbmcpOyBqdXN0IGFwcGVuZCBpdFxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyh4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgeDtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaXQncyBhIFBhcmFtRGV0YWlscy5cbiAgICAgICAgICAgIHZhciBzcXVhc2ggPSB4LnNxdWFzaCwgZW5jb2RlZCA9IHguZW5jb2RlZCwgcGFyYW0gPSB4LnBhcmFtO1xuICAgICAgICAgICAgLy8gSWYgc3F1YXNoIGlzID09PSB0cnVlLCB0cnkgdG8gcmVtb3ZlIGEgc2xhc2ggZnJvbSB0aGUgcGF0aFxuICAgICAgICAgICAgaWYgKHNxdWFzaCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjLm1hdGNoKC9cXC8kLykgPyBhY2Muc2xpY2UoMCwgLTEpIDogYWNjO1xuICAgICAgICAgICAgLy8gSWYgc3F1YXNoIGlzIGEgc3RyaW5nLCB1c2UgdGhlIHN0cmluZyBmb3IgdGhlIHBhcmFtIHZhbHVlXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHNxdWFzaCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIHNxdWFzaDtcbiAgICAgICAgICAgIGlmIChzcXVhc2ggIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7IC8vID9cbiAgICAgICAgICAgIGlmIChlbmNvZGVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIC8vIElmIHRoaXMgcGFyYW1ldGVyIHZhbHVlIGlzIGFuIGFycmF5LCBlbmNvZGUgdGhlIHZhbHVlIHVzaW5nIGVuY29kZURhc2hlc1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0FycmF5KGVuY29kZWQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyBjb21tb25fMS5tYXAoZW5jb2RlZCwgVXJsTWF0Y2hlci5lbmNvZGVEYXNoZXMpLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdHlwZSBpcyBcInJhd1wiLCB0aGVuIGRvIG5vdCBlbmNvZGVVUklDb21wb25lbnRcbiAgICAgICAgICAgIGlmIChwYXJhbS5yYXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIGVuY29kZWQ7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gYWNjICsgZW5jb2RlVVJJQ29tcG9uZW50KGVuY29kZWQpO1xuICAgICAgICB9LCAnJyk7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBxdWVyeSBzdHJpbmcgYnkgYXBwbHlpbmcgcGFyYW1ldGVyIHZhbHVlcyAoYXJyYXkgb3IgcmVndWxhcilcbiAgICAgICAgLy8gdGhlbiBtYXBwaW5nIHRvIGtleT12YWx1ZSwgdGhlbiBmbGF0dGVuaW5nIGFuZCBqb2luaW5nIHVzaW5nIFwiJlwiXG4gICAgICAgIHZhciBxdWVyeVN0cmluZyA9IHF1ZXJ5UGFyYW1zXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJhbURldGFpbHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtRGV0YWlscy5wYXJhbSwgc3F1YXNoID0gcGFyYW1EZXRhaWxzLnNxdWFzaCwgZW5jb2RlZCA9IHBhcmFtRGV0YWlscy5lbmNvZGVkLCBpc0RlZmF1bHRWYWx1ZSA9IHBhcmFtRGV0YWlscy5pc0RlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVkID09IG51bGwgfHwgKGlzRGVmYXVsdFZhbHVlICYmIHNxdWFzaCAhPT0gZmFsc2UpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzQXJyYXkoZW5jb2RlZCkpXG4gICAgICAgICAgICAgICAgZW5jb2RlZCA9IFtlbmNvZGVkXTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXBhcmFtLnJhdylcbiAgICAgICAgICAgICAgICBlbmNvZGVkID0gY29tbW9uXzEubWFwKGVuY29kZWQsIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlZC5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gcGFyYW0uaWQgKyBcIj1cIiArIHZhbDsgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5qb2luKCcmJyk7XG4gICAgICAgIC8vIENvbmNhdCB0aGUgcGF0aHN0cmluZyB3aXRoIHRoZSBxdWVyeVN0cmluZyAoaWYgZXhpc3RzKSBhbmQgdGhlIGhhc2hTdHJpbmcgKGlmIGV4aXN0cylcbiAgICAgICAgcmV0dXJuIHBhdGhTdHJpbmcgKyAocXVlcnlTdHJpbmcgPyBcIj9cIiArIHF1ZXJ5U3RyaW5nIDogJycpICsgKHZhbHVlc1snIyddID8gJyMnICsgdmFsdWVzWycjJ10gOiAnJyk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybE1hdGNoZXIubmFtZVZhbGlkYXRvciA9IC9eXFx3KyhbLS5dK1xcdyspKig/OlxcW1xcXSk/JC87XG4gICAgcmV0dXJuIFVybE1hdGNoZXI7XG59KCkpO1xuZXhwb3J0cy5VcmxNYXRjaGVyID0gVXJsTWF0Y2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybE1hdGNoZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB1cmxcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciB1cmxNYXRjaGVyXzEgPSByZXF1aXJlKFwiLi91cmxNYXRjaGVyXCIpO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtXCIpO1xudmFyIHBhcmFtVHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9wYXJhbXMvcGFyYW1UeXBlc1wiKTtcbi8qKlxuICogRmFjdG9yeSBmb3IgW1tVcmxNYXRjaGVyXV0gaW5zdGFuY2VzLlxuICpcbiAqIFRoZSBmYWN0b3J5IGlzIGF2YWlsYWJsZSB0byBuZzEgc2VydmljZXMgYXNcbiAqIGAkdXJsTWF0Y2hlckZhY3RvcnlgIG9yIG5nMSBwcm92aWRlcnMgYXMgYCR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyYC5cbiAqL1xudmFyIFVybE1hdGNoZXJGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVybE1hdGNoZXJGYWN0b3J5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLnBhcmFtVHlwZXMgPSBuZXcgcGFyYW1UeXBlc18xLlBhcmFtVHlwZXMoKTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5faXNDYXNlSW5zZW5zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5faXNTdHJpY3RNb2RlID0gdHJ1ZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fZGVmYXVsdFNxdWFzaFBvbGljeSA9IGZhbHNlO1xuICAgICAgICAvKiogQGludGVybmFsYXBpIENyZWF0ZXMgYSBuZXcgW1tQYXJhbV1dIGZvciBhIGdpdmVuIGxvY2F0aW9uIChEZWZUeXBlKSAqL1xuICAgICAgICB0aGlzLnBhcmFtRmFjdG9yeSA9IHtcbiAgICAgICAgICAgIC8qKiBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmcm9tIGEgQ09ORklHIGJsb2NrICovXG4gICAgICAgICAgICBmcm9tQ29uZmlnOiBmdW5jdGlvbiAoaWQsIHR5cGUsIGNvbmZpZykgeyByZXR1cm4gbmV3IHBhcmFtXzEuUGFyYW0oaWQsIHR5cGUsIGNvbmZpZywgcGFyYW1fMS5EZWZUeXBlLkNPTkZJRywgX3RoaXMpOyB9LFxuICAgICAgICAgICAgLyoqIENyZWF0ZXMgYSBuZXcgW1tQYXJhbV1dIGZyb20gYSB1cmwgUEFUSCAqL1xuICAgICAgICAgICAgZnJvbVBhdGg6IGZ1bmN0aW9uIChpZCwgdHlwZSwgY29uZmlnKSB7IHJldHVybiBuZXcgcGFyYW1fMS5QYXJhbShpZCwgdHlwZSwgY29uZmlnLCBwYXJhbV8xLkRlZlR5cGUuUEFUSCwgX3RoaXMpOyB9LFxuICAgICAgICAgICAgLyoqIENyZWF0ZXMgYSBuZXcgW1tQYXJhbV1dIGZyb20gYSB1cmwgU0VBUkNIICovXG4gICAgICAgICAgICBmcm9tU2VhcmNoOiBmdW5jdGlvbiAoaWQsIHR5cGUsIGNvbmZpZykgeyByZXR1cm4gbmV3IHBhcmFtXzEuUGFyYW0oaWQsIHR5cGUsIGNvbmZpZywgcGFyYW1fMS5EZWZUeXBlLlNFQVJDSCwgX3RoaXMpOyB9LFxuICAgICAgICB9O1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9nZXRDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHsgc3RyaWN0OiBfdGhpcy5faXNTdHJpY3RNb2RlLCBjYXNlSW5zZW5zaXRpdmU6IF90aGlzLl9pc0Nhc2VJbnNlbnNpdGl2ZSB9LCBjb25maWcpO1xuICAgICAgICB9O1xuICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywgeyBVcmxNYXRjaGVyOiB1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlciwgUGFyYW06IHBhcmFtXzEuUGFyYW0gfSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5jYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9pc0Nhc2VJbnNlbnNpdGl2ZSA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiB0aGlzLl9pc0Nhc2VJbnNlbnNpdGl2ZSk7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuc3RyaWN0TW9kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2lzU3RyaWN0TW9kZSA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiB0aGlzLl9pc1N0cmljdE1vZGUpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmRlZmF1bHRTcXVhc2hQb2xpY3kgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSBmYWxzZSAmJiAhcHJlZGljYXRlc18xLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3F1YXNoIHBvbGljeTogXCIgKyB2YWx1ZSArIFwiLiBWYWxpZCBwb2xpY2llczogZmFsc2UsIHRydWUsIGFyYml0cmFyeS1zdHJpbmdcIik7XG4gICAgICAgIHJldHVybiAodGhpcy5fZGVmYXVsdFNxdWFzaFBvbGljeSA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiB0aGlzLl9kZWZhdWx0U3F1YXNoUG9saWN5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBbW1VybE1hdGNoZXJdXSBmb3IgdGhlIHNwZWNpZmllZCBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdHRlcm4gIFRoZSBVUkwgcGF0dGVybi5cbiAgICAgKiBAcGFyYW0gY29uZmlnICBUaGUgY29uZmlnIG9iamVjdCBoYXNoLlxuICAgICAqIEByZXR1cm5zIFRoZSBVcmxNYXRjaGVyLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKHBhdHRlcm4sIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyKHBhdHRlcm4sIHRoaXMucGFyYW1UeXBlcywgdGhpcy5wYXJhbUZhY3RvcnksIHRoaXMuX2dldENvbmZpZyhjb25maWcpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIFtbVXJsTWF0Y2hlcl1dLCBvciBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqZWN0ICBUaGUgb2JqZWN0IHRvIHBlcmZvcm0gdGhlIHR5cGUgY2hlY2sgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBtYXRjaGVzIHRoZSBgVXJsTWF0Y2hlcmAgaW50ZXJmYWNlLCBieVxuICAgICAqICAgICAgICAgIGltcGxlbWVudGluZyBhbGwgdGhlIHNhbWUgbWV0aG9kcy5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuaXNNYXRjaGVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAvLyBUT0RPOiB0eXBlb2Y/XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzT2JqZWN0KG9iamVjdCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICBjb21tb25fMS5mb3JFYWNoKHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyLnByb3RvdHlwZSwgZnVuY3Rpb24gKHZhbCwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHZhbCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKG9iamVjdFtuYW1lXSkgJiYgcHJlZGljYXRlc18xLmlzRnVuY3Rpb24ob2JqZWN0W25hbWVdKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmVnaXN0ZXJzIGEgY3VzdG9tIFtbUGFyYW1UeXBlXV0gb2JqZWN0XG4gICAgICpcbiAgICAgKiBBIFtbUGFyYW1UeXBlXV0gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgVVJMcyB3aXRoIHR5cGVkIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAgVGhlIHR5cGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gZGVmaW5pdGlvbiBUaGUgdHlwZSBkZWZpbml0aW9uLiBTZWUgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gZm9yIGluZm9ybWF0aW9uIG9uIHRoZSB2YWx1ZXMgYWNjZXB0ZWQuXG4gICAgICogQHBhcmFtIGRlZmluaXRpb25GbiBBIGZ1bmN0aW9uIHRoYXQgaXMgaW5qZWN0ZWQgYmVmb3JlIHRoZSBhcHAgcnVudGltZSBzdGFydHMuXG4gICAgICogICAgICAgIFRoZSByZXN1bHQgb2YgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgYSBbW1BhcmFtVHlwZURlZmluaXRpb25dXS5cbiAgICAgKiAgICAgICAgVGhlIHJlc3VsdCBpcyBtZXJnZWQgaW50byB0aGUgZXhpc3RpbmcgYGRlZmluaXRpb25gLlxuICAgICAqICAgICAgICBTZWUgW1tQYXJhbVR5cGVdXSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIHZhbHVlcyBhY2NlcHRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gaWYgYSB0eXBlIHdhcyByZWdpc3RlcmVkOiB0aGUgW1tVcmxNYXRjaGVyRmFjdG9yeV1dXG4gICAgICogICAtIGlmIG9ubHkgdGhlIGBuYW1lYCBwYXJhbWV0ZXIgd2FzIHNwZWNpZmllZDogdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIFtbUGFyYW1UeXBlXV0gb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIE5vdGU6IFJlZ2lzdGVyIGN1c3RvbSB0eXBlcyAqYmVmb3JlIHVzaW5nIHRoZW0qIGluIGEgc3RhdGUgZGVmaW5pdGlvbi5cbiAgICAgKlxuICAgICAqIFNlZSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBmb3IgZXhhbXBsZXNcbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uRm4pIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnBhcmFtVHlwZXMudHlwZShuYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uRm4pO1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoZGVmaW5pdGlvbikgPyB0eXBlIDogdGhpcztcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLiRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyYW1UeXBlcy5lbnF1ZXVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyYW1UeXBlcy5fZmx1c2hUeXBlUXVldWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyYW1UeXBlcy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVXJsTWF0Y2hlckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5VcmxNYXRjaGVyRmFjdG9yeSA9IFVybE1hdGNoZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsTWF0Y2hlckZhY3RvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB1cmxcbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgdXJsTWF0Y2hlcl8xID0gcmVxdWlyZShcIi4vdXJsTWF0Y2hlclwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHVybFJ1bGVfMSA9IHJlcXVpcmUoXCIuL3VybFJ1bGVcIik7XG52YXIgdGFyZ2V0U3RhdGVfMSA9IHJlcXVpcmUoXCIuLi9zdGF0ZS90YXJnZXRTdGF0ZVwiKTtcbnZhciBjb21tb25fMiA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gYXBwZW5kQmFzZVBhdGgodXJsLCBpc0h0bWw1LCBhYnNvbHV0ZSwgYmFzZUhyZWYpIHtcbiAgICBpZiAoYmFzZUhyZWYgPT09ICcvJylcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICBpZiAoaXNIdG1sNSlcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8yLnN0cmlwTGFzdFBhdGhFbGVtZW50KGJhc2VIcmVmKSArIHVybDtcbiAgICBpZiAoYWJzb2x1dGUpXG4gICAgICAgIHJldHVybiBiYXNlSHJlZi5zbGljZSgxKSArIHVybDtcbiAgICByZXR1cm4gdXJsO1xufVxuLyoqIEBoaWRkZW4gKi9cbnZhciBwcmlvcml0eVNvcnQgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGIucHJpb3JpdHkgfHwgMCkgLSAoYS5wcmlvcml0eSB8fCAwKTsgfTtcbi8qKiBAaGlkZGVuICovXG52YXIgdHlwZVNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciB3ZWlnaHRzID0geyBTVEFURTogNCwgVVJMTUFUQ0hFUjogNCwgUkVHRVhQOiAzLCBSQVc6IDIsIE9USEVSOiAxIH07XG4gICAgcmV0dXJuICh3ZWlnaHRzW2EudHlwZV0gfHwgMCkgLSAod2VpZ2h0c1tiLnR5cGVdIHx8IDApO1xufTtcbi8qKiBAaGlkZGVuICovXG52YXIgdXJsTWF0Y2hlclNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAhYS51cmxNYXRjaGVyIHx8ICFiLnVybE1hdGNoZXIgPyAwIDogdXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIuY29tcGFyZShhLnVybE1hdGNoZXIsIGIudXJsTWF0Y2hlcik7XG59O1xuLyoqIEBoaWRkZW4gKi9cbnZhciBpZFNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIElkZW50aWNhbGx5IHNvcnRlZCBTVEFURSBhbmQgVVJMTUFUQ0hFUiBiZXN0IHJ1bGUgd2lsbCBiZSBjaG9zZW4gYnkgYG1hdGNoUHJpb3JpdHlgIGFmdGVyIGVhY2ggcnVsZSBtYXRjaGVzIHRoZSBVUkxcbiAgICB2YXIgdXNlTWF0Y2hQcmlvcml0eSA9IHsgU1RBVEU6IHRydWUsIFVSTE1BVENIRVI6IHRydWUgfTtcbiAgICB2YXIgZXF1YWwgPSB1c2VNYXRjaFByaW9yaXR5W2EudHlwZV0gJiYgdXNlTWF0Y2hQcmlvcml0eVtiLnR5cGVdO1xuICAgIHJldHVybiBlcXVhbCA/IDAgOiAoYS4kaWQgfHwgMCkgLSAoYi4kaWQgfHwgMCk7XG59O1xuLyoqXG4gKiBEZWZhdWx0IHJ1bGUgcHJpb3JpdHkgc29ydGluZyBmdW5jdGlvbi5cbiAqXG4gKiBTb3J0cyBydWxlcyBieTpcbiAqXG4gKiAtIEV4cGxpY2l0IHByaW9yaXR5IChzZXQgcnVsZSBwcmlvcml0eSB1c2luZyBbW1VybFJ1bGVzQXBpLndoZW5dXSlcbiAqIC0gUnVsZSB0eXBlIChTVEFURTogNCwgVVJMTUFUQ0hFUjogNCwgUkVHRVhQOiAzLCBSQVc6IDIsIE9USEVSOiAxKVxuICogLSBgVXJsTWF0Y2hlcmAgc3BlY2lmaWNpdHkgKFtbVXJsTWF0Y2hlci5jb21wYXJlXV0pOiB3b3JrcyBmb3IgU1RBVEUgYW5kIFVSTE1BVENIRVIgdHlwZXMgdG8gcGljayB0aGUgbW9zdCBzcGVjaWZpYyBydWxlLlxuICogLSBSdWxlIHJlZ2lzdHJhdGlvbiBvcmRlciAoZm9yIHJ1bGUgdHlwZXMgb3RoZXIgdGhhbiBTVEFURSBhbmQgVVJMTUFUQ0hFUilcbiAqICAgLSBFcXVhbGx5IHNvcnRlZCBTdGF0ZSBhbmQgVXJsTWF0Y2hlciBydWxlcyB3aWxsIGVhY2ggbWF0Y2ggdGhlIFVSTC5cbiAqICAgICBUaGVuLCB0aGUgKmJlc3QqIG1hdGNoIGlzIGNob3NlbiBiYXNlZCBvbiBob3cgbWFueSBwYXJhbWV0ZXIgdmFsdWVzIHdlcmUgbWF0Y2hlZC5cbiAqXG4gKiBAY29yZWFwaVxuICovXG52YXIgZGVmYXVsdFJ1bGVTb3J0Rm47XG5kZWZhdWx0UnVsZVNvcnRGbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGNtcCA9IHByaW9yaXR5U29ydChhLCBiKTtcbiAgICBpZiAoY21wICE9PSAwKVxuICAgICAgICByZXR1cm4gY21wO1xuICAgIGNtcCA9IHR5cGVTb3J0KGEsIGIpO1xuICAgIGlmIChjbXAgIT09IDApXG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgY21wID0gdXJsTWF0Y2hlclNvcnQoYSwgYik7XG4gICAgaWYgKGNtcCAhPT0gMClcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICByZXR1cm4gaWRTb3J0KGEsIGIpO1xufTtcbi8qKlxuICogVXBkYXRlcyBVUkwgYW5kIHJlc3BvbmRzIHRvIFVSTCBjaGFuZ2VzXG4gKlxuICogIyMjIERlcHJlY2F0aW9uIHdhcm5pbmc6XG4gKiBUaGlzIGNsYXNzIGlzIG5vdyBjb25zaWRlcmVkIHRvIGJlIGFuIGludGVybmFsIEFQSVxuICogVXNlIHRoZSBbW1VybFNlcnZpY2VdXSBpbnN0ZWFkLlxuICogRm9yIGNvbmZpZ3VyaW5nIFVSTCBydWxlcywgdXNlIHRoZSBbW1VybFJ1bGVzQXBpXV0gd2hpY2ggY2FuIGJlIGZvdW5kIGFzIFtbVXJsU2VydmljZS5ydWxlc11dLlxuICpcbiAqIFRoaXMgY2xhc3MgdXBkYXRlcyB0aGUgVVJMIHdoZW4gdGhlIHN0YXRlIGNoYW5nZXMuXG4gKiBJdCBhbHNvIHJlc3BvbmRzIHRvIGNoYW5nZXMgaW4gdGhlIFVSTC5cbiAqL1xudmFyIFVybFJvdXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIFVybFJvdXRlcihyb3V0ZXIpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fc29ydEZuID0gZGVmYXVsdFJ1bGVTb3J0Rm47XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX3J1bGVzID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuaW50ZXJjZXB0RGVmZXJyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5faWQgPSAwO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLnVybFJ1bGVGYWN0b3J5ID0gbmV3IHVybFJ1bGVfMS5VcmxSdWxlRmFjdG9yeShyb3V0ZXIpO1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhob2ZfMS52YWwoVXJsUm91dGVyLnByb3RvdHlwZSksIHRoaXMsIGhvZl8xLnZhbCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fcnVsZXMgPSBbXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX290aGVyd2lzZUZuO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGNvbXBhcmVGbikge1xuICAgICAgICB0aGlzLl9ydWxlcyA9IHRoaXMuc3RhYmxlU29ydCh0aGlzLl9ydWxlcywgKHRoaXMuX3NvcnRGbiA9IGNvbXBhcmVGbiB8fCB0aGlzLl9zb3J0Rm4pKTtcbiAgICAgICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUuZW5zdXJlU29ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zb3J0ZWQgfHwgdGhpcy5zb3J0KCk7XG4gICAgfTtcbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnN0YWJsZVNvcnQgPSBmdW5jdGlvbiAoYXJyLCBjb21wYXJlRm4pIHtcbiAgICAgICAgdmFyIGFyck9mV3JhcHBlciA9IGFyci5tYXAoZnVuY3Rpb24gKGVsZW0sIGlkeCkgeyByZXR1cm4gKHsgZWxlbTogZWxlbSwgaWR4OiBpZHggfSk7IH0pO1xuICAgICAgICBhcnJPZldyYXBwZXIuc29ydChmdW5jdGlvbiAod3JhcHBlckEsIHdyYXBwZXJCKSB7XG4gICAgICAgICAgICB2YXIgY21wRGlmZiA9IGNvbXBhcmVGbih3cmFwcGVyQS5lbGVtLCB3cmFwcGVyQi5lbGVtKTtcbiAgICAgICAgICAgIHJldHVybiBjbXBEaWZmID09PSAwID8gd3JhcHBlckEuaWR4IC0gd3JhcHBlckIuaWR4IDogY21wRGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcnJPZldyYXBwZXIubWFwKGZ1bmN0aW9uICh3cmFwcGVyKSB7IHJldHVybiB3cmFwcGVyLmVsZW07IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBVUkwsIGNoZWNrIGFsbCBydWxlcyBhbmQgcmV0dXJuIHRoZSBiZXN0IFtbTWF0Y2hSZXN1bHRdXVxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKiBAcmV0dXJucyB7TWF0Y2hSZXN1bHR9XG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbnN1cmVTb3J0ZWQoKTtcbiAgICAgICAgdXJsID0gY29tbW9uXzEuZXh0ZW5kKHsgcGF0aDogJycsIHNlYXJjaDoge30sIGhhc2g6ICcnIH0sIHVybCk7XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX290aGVyd2lzZUZuKVxuICAgICAgICAgICAgcnVsZXMucHVzaCh0aGlzLl9vdGhlcndpc2VGbik7XG4gICAgICAgIC8vIENoZWNrcyBhIHNpbmdsZSBydWxlLiBSZXR1cm5zIHsgcnVsZTogcnVsZSwgbWF0Y2g6IG1hdGNoLCB3ZWlnaHQ6IHdlaWdodCB9IGlmIGl0IG1hdGNoZWQsIG9yIHVuZGVmaW5lZFxuICAgICAgICB2YXIgY2hlY2tSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2godXJsLCBfdGhpcy5fcm91dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiB7IG1hdGNoOiBtYXRjaCwgcnVsZTogcnVsZSwgd2VpZ2h0OiBydWxlLm1hdGNoUHJpb3JpdHkobWF0Y2gpIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoZSBydWxlcyBhcmUgcHJlLXNvcnRlZC5cbiAgICAgICAgLy8gLSBGaW5kIHRoZSBmaXJzdCBtYXRjaGluZyBydWxlLlxuICAgICAgICAvLyAtIEZpbmQgYW55IG90aGVyIG1hdGNoaW5nIHJ1bGUgdGhhdCBzb3J0ZWQgKmV4YWN0bHkgdGhlIHNhbWUqLCBhY2NvcmRpbmcgdG8gYC5zb3J0KClgLlxuICAgICAgICAvLyAtIENob29zZSB0aGUgcnVsZSB3aXRoIHRoZSBoaWdoZXN0IG1hdGNoIHdlaWdodC5cbiAgICAgICAgdmFyIGJlc3Q7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFN0b3Agd2hlbiB0aGVyZSBpcyBhICdiZXN0JyBydWxlIGFuZCB0aGUgbmV4dCBydWxlIHNvcnRzIGRpZmZlcmVudGx5IHRoYW4gaXQuXG4gICAgICAgICAgICBpZiAoYmVzdCAmJiB0aGlzLl9zb3J0Rm4ocnVsZXNbaV0sIGJlc3QucnVsZSkgIT09IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGNoZWNrUnVsZShydWxlc1tpXSk7XG4gICAgICAgICAgICAvLyBQaWNrIHRoZSBiZXN0IE1hdGNoUmVzdWx0XG4gICAgICAgICAgICBiZXN0ID0gIWJlc3QgfHwgKGN1cnJlbnQgJiYgY3VycmVudC53ZWlnaHQgPiBiZXN0LndlaWdodCkgPyBjdXJyZW50IDogYmVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdDtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKGV2dCAmJiBldnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMuX3JvdXRlciwgJHVybCA9IHJvdXRlci51cmxTZXJ2aWNlLCAkc3RhdGUgPSByb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgICAgICB2YXIgdXJsID0ge1xuICAgICAgICAgICAgcGF0aDogJHVybC5wYXRoKCksXG4gICAgICAgICAgICBzZWFyY2g6ICR1cmwuc2VhcmNoKCksXG4gICAgICAgICAgICBoYXNoOiAkdXJsLmhhc2goKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJlc3QgPSB0aGlzLm1hdGNoKHVybCk7XG4gICAgICAgIHZhciBhcHBseVJlc3VsdCA9IGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc1N0cmluZywgZnVuY3Rpb24gKG5ld3VybCkgeyByZXR1cm4gJHVybC51cmwobmV3dXJsLCB0cnVlKTsgfV0sXG4gICAgICAgICAgICBbdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZS5pc0RlZiwgZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gJHN0YXRlLmdvKGRlZi5zdGF0ZSwgZGVmLnBhcmFtcywgZGVmLm9wdGlvbnMpOyB9XSxcbiAgICAgICAgICAgIFtob2ZfMS5pcyh0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKSwgZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gJHN0YXRlLmdvKHRhcmdldC5zdGF0ZSgpLCB0YXJnZXQucGFyYW1zKCksIHRhcmdldC5vcHRpb25zKCkpOyB9XSxcbiAgICAgICAgXSk7XG4gICAgICAgIGFwcGx5UmVzdWx0KGJlc3QgJiYgYmVzdC5ydWxlLmhhbmRsZXIoYmVzdC5tYXRjaCwgdXJsLCByb3V0ZXIpKTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wRm4gJiYgdGhpcy5fc3RvcEZuKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3RvcEZuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9zdG9wRm4gPSB0aGlzLl9zdG9wRm4gfHwgdGhpcy5fcm91dGVyLnVybFNlcnZpY2Uub25DaGFuZ2UoZnVuY3Rpb24gKGV2dCkgeyByZXR1cm4gX3RoaXMuc3luYyhldnQpOyB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIEFQSS5cbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgICAgIHZhciAkdXJsID0gdGhpcy5fcm91dGVyLmxvY2F0aW9uU2VydmljZTtcbiAgICAgICAgaWYgKHJlYWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSAkdXJsLnVybCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkdXJsLnVybCgpID09PSB0aGlzLmxvY2F0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAkdXJsLnVybCh0aGlzLmxvY2F0aW9uLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIEFQSS5cbiAgICAgKlxuICAgICAqIFB1c2hlcyBhIG5ldyBsb2NhdGlvbiB0byB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICogQHBhcmFtIHVybE1hdGNoZXJcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodXJsTWF0Y2hlciwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXBsYWNlID0gb3B0aW9ucyAmJiAhIW9wdGlvbnMucmVwbGFjZTtcbiAgICAgICAgdGhpcy5fcm91dGVyLnVybFNlcnZpY2UudXJsKHVybE1hdGNoZXIuZm9ybWF0KHBhcmFtcyB8fCB7fSksIHJlcGxhY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGFuZCByZXR1cm5zIGEgVVJMIHdpdGggaW50ZXJwb2xhdGVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIG1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvYWJvdXQvOnBlcnNvblwiKTtcbiAgICAgKiBwYXJhbXMgPSB7IHBlcnNvbjogXCJib2JcIiB9O1xuICAgICAqICRib2IgPSAkdXJsUm91dGVyLmhyZWYobWF0Y2hlciwgcGFyYW1zKTtcbiAgICAgKiAvLyAkYm9iID09IFwiL2Fib3V0L2JvYlwiO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHVybE1hdGNoZXIgVGhlIFtbVXJsTWF0Y2hlcl1dIG9iamVjdCB3aGljaCBpcyB1c2VkIGFzIHRoZSB0ZW1wbGF0ZSBvZiB0aGUgVVJMIHRvIGdlbmVyYXRlLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IG9mIHBhcmFtZXRlciB2YWx1ZXMgdG8gZmlsbCB0aGUgbWF0Y2hlcidzIHJlcXVpcmVkIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gKipgYWJzb2x1dGVgKiogLSB7Ym9vbGVhbj1mYWxzZX0sICBJZiB0cnVlIHdpbGwgZ2VuZXJhdGUgYW4gYWJzb2x1dGUgdXJsLCBlLmcuIFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9mdWxsdXJsXCIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBmdWxseSBjb21waWxlZCBVUkwsIG9yIGBudWxsYCBpZiBgcGFyYW1zYCBmYWlsIHZhbGlkYXRpb24gYWdhaW5zdCBgdXJsTWF0Y2hlcmBcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmhyZWYgPSBmdW5jdGlvbiAodXJsTWF0Y2hlciwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cmwgPSB1cmxNYXRjaGVyLmZvcm1hdChwYXJhbXMpO1xuICAgICAgICBpZiAodXJsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBhYnNvbHV0ZTogZmFsc2UgfTtcbiAgICAgICAgdmFyIGNmZyA9IHRoaXMuX3JvdXRlci51cmxTZXJ2aWNlLmNvbmZpZztcbiAgICAgICAgdmFyIGlzSHRtbDUgPSBjZmcuaHRtbDVNb2RlKCk7XG4gICAgICAgIGlmICghaXNIdG1sNSAmJiB1cmwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9ICcjJyArIGNmZy5oYXNoUHJlZml4KCkgKyB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gYXBwZW5kQmFzZVBhdGgodXJsLCBpc0h0bWw1LCBvcHRpb25zLmFic29sdXRlLCBjZmcuYmFzZUhyZWYoKSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZSB8fCAhdXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzbGFzaCA9ICFpc0h0bWw1ICYmIHVybCA/ICcvJyA6ICcnO1xuICAgICAgICB2YXIgY2ZnUG9ydCA9IGNmZy5wb3J0KCk7XG4gICAgICAgIHZhciBwb3J0ID0gKGNmZ1BvcnQgPT09IDgwIHx8IGNmZ1BvcnQgPT09IDQ0MyA/ICcnIDogJzonICsgY2ZnUG9ydCk7XG4gICAgICAgIHJldHVybiBbY2ZnLnByb3RvY29sKCksICc6Ly8nLCBjZmcuaG9zdCgpLCBwb3J0LCBzbGFzaCwgdXJsXS5qb2luKCcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IGFkZHMgYSBVUkwgUnVsZS5cbiAgICAgKlxuICAgICAqIFVzdWFsbHksIGEgdXJsIHJ1bGUgaXMgYWRkZWQgdXNpbmcgW1tTdGF0ZURlY2xhcmF0aW9uLnVybF1dIG9yIFtbd2hlbl1dLlxuICAgICAqIFRoaXMgYXBpIGNhbiBiZSB1c2VkIGRpcmVjdGx5IGZvciBtb3JlIGNvbnRyb2wgKHRvIHJlZ2lzdGVyIGEgW1tCYXNlVXJsUnVsZV1dLCBmb3IgZXhhbXBsZSkuXG4gICAgICogUnVsZXMgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgW1tVcmxSb3V0ZXIudXJsUnVsZUZhY3RvcnldXSwgb3IgY3JlYXRlIG1hbnVhbGx5IGFzIHNpbXBsZSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQSBydWxlIHNob3VsZCBoYXZlIGEgYG1hdGNoYCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRydXRoeSBpZiB0aGUgcnVsZSBtYXRjaGVkLlxuICAgICAqIEl0IHNob3VsZCBhbHNvIGhhdmUgYSBgaGFuZGxlcmAgZnVuY3Rpb24gd2hpY2ggaXMgaW52b2tlZCBpZiB0aGUgcnVsZSBpcyB0aGUgYmVzdCBtYXRjaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGRlcmVnaXN0ZXJzIHRoZSBydWxlXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5ydWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF1cmxSdWxlXzEuVXJsUnVsZUZhY3RvcnkuaXNVcmxSdWxlKHJ1bGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJ1bGUnKTtcbiAgICAgICAgcnVsZS4kaWQgPSB0aGlzLl9pZCsrO1xuICAgICAgICBydWxlLnByaW9yaXR5ID0gcnVsZS5wcmlvcml0eSB8fCAwO1xuICAgICAgICB0aGlzLl9ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbW92ZVJ1bGUocnVsZSk7IH07XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnJlbW92ZVJ1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKHRoaXMuX3J1bGVzLCBydWxlKTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUucnVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlU29ydGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydWxlcy5zbGljZSgpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5vdGhlcndpc2UgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlckZuID0gZ2V0SGFuZGxlckZuKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9vdGhlcndpc2VGbiA9IHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKGhvZl8xLnZhbCh0cnVlKSwgaGFuZGxlckZuKTtcbiAgICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmluaXRpYWwgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlckZuID0gZ2V0SGFuZGxlckZuKGhhbmRsZXIpO1xuICAgICAgICB2YXIgbWF0Y2hGbiA9IGZ1bmN0aW9uICh1cmxQYXJ0cywgcm91dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbkhpc3Rvcnkuc2l6ZSgpID09PSAwICYmICEhL15cXC8/JC8uZXhlYyh1cmxQYXJ0cy5wYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydWxlKHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKG1hdGNoRm4sIGhhbmRsZXJGbikpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24gKG1hdGNoZXIsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnVybFJ1bGVGYWN0b3J5LmNyZWF0ZShtYXRjaGVyLCBoYW5kbGVyKTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQob3B0aW9ucyAmJiBvcHRpb25zLnByaW9yaXR5KSlcbiAgICAgICAgICAgIHJ1bGUucHJpb3JpdHkgPSBvcHRpb25zLnByaW9yaXR5O1xuICAgICAgICB0aGlzLnJ1bGUocnVsZSk7XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5kZWZlckludGVyY2VwdCA9IGZ1bmN0aW9uIChkZWZlcikge1xuICAgICAgICBpZiAoZGVmZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGRlZmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHREZWZlcnJlZCA9IGRlZmVyO1xuICAgIH07XG4gICAgcmV0dXJuIFVybFJvdXRlcjtcbn0oKSk7XG5leHBvcnRzLlVybFJvdXRlciA9IFVybFJvdXRlcjtcbmZ1bmN0aW9uIGdldEhhbmRsZXJGbihoYW5kbGVyKSB7XG4gICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihoYW5kbGVyKSAmJiAhcHJlZGljYXRlc18xLmlzU3RyaW5nKGhhbmRsZXIpICYmICFob2ZfMS5pcyh0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKShoYW5kbGVyKSAmJiAhdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZS5pc0RlZihoYW5kbGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInaGFuZGxlcicgbXVzdCBiZSBhIHN0cmluZywgZnVuY3Rpb24sIFRhcmdldFN0YXRlLCBvciBoYXZlIGEgc3RhdGU6ICduZXd0YXJnZXQnIHByb3BlcnR5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oaGFuZGxlcikgPyBoYW5kbGVyIDogaG9mXzEudmFsKGhhbmRsZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsUm91dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB1cmxcbiAqLyAvKiogKi9cbnZhciB1cmxNYXRjaGVyXzEgPSByZXF1aXJlKFwiLi91cmxNYXRjaGVyXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBbW1VybFJ1bGVdXVxuICpcbiAqIENyZWF0ZXMgYSBbW1VybFJ1bGVdXSBmcm9tIGE6XG4gKlxuICogLSBgc3RyaW5nYFxuICogLSBbW1VybE1hdGNoZXJdXVxuICogLSBgUmVnRXhwYFxuICogLSBbW1N0YXRlT2JqZWN0XV1cbiAqIEBpbnRlcm5hbGFwaVxuICovXG52YXIgVXJsUnVsZUZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXJsUnVsZUZhY3Rvcnkocm91dGVyKSB7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgIH1cbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUoc3RyKTtcbiAgICB9O1xuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAod2hhdCwgaGFuZGxlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWFrZVJ1bGUgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNTdHJpbmcsIGZ1bmN0aW9uIChfd2hhdCkgeyByZXR1cm4gbWFrZVJ1bGUoX3RoaXMuY29tcGlsZShfd2hhdCkpOyB9XSxcbiAgICAgICAgICAgIFtob2ZfMS5pcyh1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlciksIGZ1bmN0aW9uIChfd2hhdCkgeyByZXR1cm4gX3RoaXMuZnJvbVVybE1hdGNoZXIoX3doYXQsIGhhbmRsZXIpOyB9XSxcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNTdGF0ZSwgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBfdGhpcy5mcm9tU3RhdGUoX3doYXQsIF90aGlzLnJvdXRlcik7IH1dLFxuICAgICAgICAgICAgW2hvZl8xLmlzKFJlZ0V4cCksIGZ1bmN0aW9uIChfd2hhdCkgeyByZXR1cm4gX3RoaXMuZnJvbVJlZ0V4cChfd2hhdCwgaGFuZGxlcik7IH1dLFxuICAgICAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uLCBmdW5jdGlvbiAoX3doYXQpIHsgcmV0dXJuIG5ldyBCYXNlVXJsUnVsZShfd2hhdCwgaGFuZGxlcik7IH1dLFxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHJ1bGUgPSBtYWtlUnVsZSh3aGF0KTtcbiAgICAgICAgaWYgKCFydWxlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCAnd2hhdCcgaW4gd2hlbigpXCIpO1xuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgVXJsUnVsZSB3aGljaCBtYXRjaGVzIGJhc2VkIG9uIGEgVXJsTWF0Y2hlclxuICAgICAqXG4gICAgICogVGhlIGBoYW5kbGVyYCBtYXkgYmUgZWl0aGVyIGEgYHN0cmluZ2AsIGEgW1tVcmxSdWxlSGFuZGxlckZuXV0gb3IgYW5vdGhlciBbW1VybE1hdGNoZXJdXVxuICAgICAqXG4gICAgICogIyMgSGFuZGxlciBhcyBhIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aDpcbiAgICAgKlxuICAgICAqIC0gbWF0Y2hlZCBwYXJhbWV0ZXIgdmFsdWVzIChbW1Jhd1BhcmFtc11dIGZyb20gW1tVcmxNYXRjaGVyLmV4ZWNdXSlcbiAgICAgKiAtIHVybDogdGhlIGN1cnJlbnQgVXJsIChbW1VybFBhcnRzXV0pXG4gICAgICogLSByb3V0ZXI6IHRoZSByb3V0ZXIgb2JqZWN0IChbW1VJUm91dGVyXV0pXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgdXJsTWF0Y2hlciA9ICR1bWYuY29tcGlsZShcIi9mb28vOmZvb0lkLzpiYXJJZFwiKTtcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVVybE1hdGNoZXIodXJsTWF0Y2hlciwgbWF0Y2ggPT4gXCIvaG9tZS9cIiArIG1hdGNoLmZvb0lkICsgXCIvXCIgKyBtYXRjaC5iYXJJZCk7XG4gICAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby8xMjMvNDU2Jyk7IC8vIHJlc3VsdHMgaW4geyBmb29JZDogJzEyMycsIGJhcklkOiAnNDU2JyB9XG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS8xMjMvNDU2J1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMgSGFuZGxlciBhcyBVcmxNYXRjaGVyXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBVcmxNYXRjaGVyLCB0aGUgaGFuZGxlciBtYXRjaGVyIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBuZXcgdXJsLlxuICAgICAqIFRoZSBgaGFuZGxlcmAgVXJsTWF0Y2hlciBpcyBmb3JtYXR0ZWQgdXNpbmcgdGhlIG1hdGNoZWQgcGFyYW0gZnJvbSB0aGUgZmlyc3QgbWF0Y2hlci5cbiAgICAgKiBUaGUgdXJsIGlzIHJlcGxhY2VkIHdpdGggdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciB1cmxNYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Zvby86Zm9vSWQvOmJhcklkXCIpO1xuICAgICAqIHZhciBoYW5kbGVyID0gJHVtZi5jb21waWxlKFwiL2hvbWUvOmZvb0lkLzpiYXJJZFwiKTtcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVVybE1hdGNoZXIodXJsTWF0Y2hlciwgaGFuZGxlcik7XG4gICAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby8xMjMvNDU2Jyk7IC8vIHJlc3VsdHMgaW4geyBmb29JZDogJzEyMycsIGJhcklkOiAnNDU2JyB9XG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS8xMjMvNDU2J1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tVXJsTWF0Y2hlciA9IGZ1bmN0aW9uICh1cmxNYXRjaGVyLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBfaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoaGFuZGxlcikpXG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5yb3V0ZXIudXJsTWF0Y2hlckZhY3RvcnkuY29tcGlsZShoYW5kbGVyKTtcbiAgICAgICAgaWYgKGhvZl8xLmlzKHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyKShoYW5kbGVyKSlcbiAgICAgICAgICAgIF9oYW5kbGVyID0gZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBoYW5kbGVyLmZvcm1hdChtYXRjaCk7IH07XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoVXJsUGFyYW10ZXJzKHVybCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHVybE1hdGNoZXIuZXhlYyh1cmwucGF0aCwgdXJsLnNlYXJjaCwgdXJsLmhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHVybE1hdGNoZXIudmFsaWRhdGVzKHBhcmFtcykgJiYgcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByaW9yaXRpemUgVVJMcywgbG93ZXN0IHRvIGhpZ2hlc3Q6XG4gICAgICAgIC8vIC0gU29tZSBvcHRpb25hbCBVUkwgcGFyYW1ldGVycywgYnV0IG5vbmUgbWF0Y2hlZFxuICAgICAgICAvLyAtIE5vIG9wdGlvbmFsIHBhcmFtZXRlcnMgaW4gVVJMXG4gICAgICAgIC8vIC0gU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzLCBzb21lIG1hdGNoZWRcbiAgICAgICAgLy8gLSBTb21lIG9wdGlvbmFsIHBhcmFtZXRlcnMsIGFsbCBtYXRjaGVkXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoUHJpb3JpdHkocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWwgPSB1cmxNYXRjaGVyLnBhcmFtZXRlcnMoKS5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5pc09wdGlvbmFsOyB9KTtcbiAgICAgICAgICAgIGlmICghb3B0aW9uYWwubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiAwLjAwMDAwMTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gb3B0aW9uYWwuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW1zW3BhcmFtLmlkXTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZC5sZW5ndGggLyBvcHRpb25hbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRldGFpbHMgPSB7IHVybE1hdGNoZXI6IHVybE1hdGNoZXIsIG1hdGNoUHJpb3JpdHk6IG1hdGNoUHJpb3JpdHksIHR5cGU6ICdVUkxNQVRDSEVSJyB9O1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKG5ldyBCYXNlVXJsUnVsZShtYXRjaFVybFBhcmFtdGVycywgX2hhbmRsZXIpLCBkZXRhaWxzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgVXJsUnVsZSB3aGljaCBtYXRjaGVzIGEgc3RhdGUgYnkgaXRzIHVybFxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21TdGF0ZSgkc3RhdGUuZ2V0KCdmb28nKSwgcm91dGVyKTtcbiAgICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vLzEyMy80NTYnKTsgLy8gcmVzdWx0cyBpbiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTtcbiAgICAgKiAvLyBTdGFydHMgYSB0cmFuc2l0aW9uIHRvICdmb28nIHdpdGggcGFyYW1zOiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCByb3V0ZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgbWF0Y2ggYnkgdHJhbnNpdGlvbmluZyB0byBtYXRjaGVkIHN0YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpcnN0IGNoZWNrcyBpZiB0aGUgcm91dGVyIHNob3VsZCBzdGFydCBhIG5ldyB0cmFuc2l0aW9uLlxuICAgICAgICAgKiBBIG5ldyB0cmFuc2l0aW9uIGlzIG5vdCByZXF1aXJlZCBpZiB0aGUgY3VycmVudCBzdGF0ZSdzIFVSTFxuICAgICAgICAgKiBhbmQgdGhlIG5ldyBVUkwgYXJlIGFscmVhZHkgaWRlbnRpY2FsXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyICRzdGF0ZSA9IHJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgICAgICAgICB2YXIgZ2xvYmFscyA9IHJvdXRlci5nbG9iYWxzO1xuICAgICAgICAgICAgaWYgKCRzdGF0ZS5ocmVmKHN0YXRlLCBtYXRjaCkgIT09ICRzdGF0ZS5ocmVmKGdsb2JhbHMuY3VycmVudCwgZ2xvYmFscy5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbyhzdGF0ZSwgbWF0Y2gsIHsgaW5oZXJpdDogdHJ1ZSwgc291cmNlOiAndXJsJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRldGFpbHMgPSB7IHN0YXRlOiBzdGF0ZSwgdHlwZTogJ1NUQVRFJyB9O1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHRoaXMuZnJvbVVybE1hdGNoZXIoc3RhdGUudXJsLCBoYW5kbGVyKSwgZGV0YWlscyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIFVybFJ1bGUgd2hpY2ggbWF0Y2hlcyBiYXNlZCBvbiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAqXG4gICAgICogVGhlIGBoYW5kbGVyYCBtYXkgYmUgZWl0aGVyIGEgW1tVcmxSdWxlSGFuZGxlckZuXV0gb3IgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiAjIyBIYW5kbGVyIGFzIGEgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIElmIGBoYW5kbGVyYCBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoOlxuICAgICAqXG4gICAgICogLSByZWdleHAgbWF0Y2ggYXJyYXkgKGZyb20gYHJlZ2V4cGApXG4gICAgICogLSB1cmw6IHRoZSBjdXJyZW50IFVybCAoW1tVcmxQYXJ0c11dKVxuICAgICAqIC0gcm91dGVyOiB0aGUgcm91dGVyIG9iamVjdCAoW1tVSVJvdXRlcl1dKVxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21SZWdFeHAoL15cXC9mb29cXC8oYmFyfGJheikkLywgbWF0Y2ggPT4gXCIvaG9tZS9cIiArIG1hdGNoWzFdKVxuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vYmFyJyk7IC8vIHJlc3VsdHMgaW4gWyAnL2Zvby9iYXInLCAnYmFyJyBdXG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS9iYXInXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyBIYW5kbGVyIGFzIHN0cmluZ1xuICAgICAqXG4gICAgICogSWYgYGhhbmRsZXJgIGlzIGEgc3RyaW5nLCB0aGUgdXJsIGlzICpyZXBsYWNlZCBieSB0aGUgc3RyaW5nKiB3aGVuIHRoZSBSdWxlIGlzIGludm9rZWQuXG4gICAgICogVGhlIHN0cmluZyBpcyBmaXJzdCBpbnRlcnBvbGF0ZWQgdXNpbmcgYHN0cmluZy5yZXBsYWNlKClgIHN0eWxlIHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVJlZ0V4cCgvXlxcL2Zvb1xcLyhiYXJ8YmF6KSQvLCBcIi9ob21lLyQxXCIpXG4gICAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby9iYXInKTsgLy8gcmVzdWx0cyBpbiBbICcvZm9vL2JhcicsICdiYXInIF1cbiAgICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTsgLy8gJy9ob21lL2JhcidcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVJlZ0V4cCA9IGZ1bmN0aW9uIChyZWdleHAsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHJlZ2V4cC5nbG9iYWwgfHwgcmVnZXhwLnN0aWNreSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUnVsZSBSZWdFeHAgbXVzdCBub3QgYmUgZ2xvYmFsIG9yIHN0aWNreScpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaGFuZGxlciBpcyBhIHN0cmluZywgdGhlIHVybCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBzdHJpbmcuXG4gICAgICAgICAqIElmIHRoZSBzdHJpbmcgaGFzIGFueSBTdHJpbmcucmVwbGFjZSgpIHN0eWxlIHZhcmlhYmxlcyBpbiBpdCAobGlrZSBgJDJgKSxcbiAgICAgICAgICogdGhleSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjYXB0dXJlcyBmcm9tIFtbbWF0Y2hdXVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlZGlyZWN0VXJsVG8gPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEludGVycG9sYXRlcyBtYXRjaGVkIHZhbHVlcyBpbnRvICQxICQyLCBldGMgdXNpbmcgYSBTdHJpbmcucmVwbGFjZSgpLXN0eWxlIHBhdHRlcm5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLnJlcGxhY2UoL1xcJChcXCR8XFxkezEsMn0pLywgZnVuY3Rpb24gKG0sIHdoYXQpIHsgcmV0dXJuIG1hdGNoW3doYXQgPT09ICckJyA/IDAgOiBOdW1iZXIod2hhdCldOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9oYW5kbGVyID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKGhhbmRsZXIpID8gcmVkaXJlY3RVcmxUbyA6IGhhbmRsZXI7XG4gICAgICAgIHZhciBtYXRjaFBhcmFtc0Zyb21SZWdleHAgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiByZWdleHAuZXhlYyh1cmwucGF0aCk7IH07XG4gICAgICAgIHZhciBkZXRhaWxzID0geyByZWdleHA6IHJlZ2V4cCwgdHlwZTogJ1JFR0VYUCcgfTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChuZXcgQmFzZVVybFJ1bGUobWF0Y2hQYXJhbXNGcm9tUmVnZXhwLCBfaGFuZGxlciksIGRldGFpbHMpO1xuICAgIH07XG4gICAgVXJsUnVsZUZhY3RvcnkuaXNVcmxSdWxlID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFsndHlwZScsICdtYXRjaCcsICdoYW5kbGVyJ10uZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChvYmpba2V5XSk7IH0pOyB9O1xuICAgIHJldHVybiBVcmxSdWxlRmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLlVybFJ1bGVGYWN0b3J5ID0gVXJsUnVsZUZhY3Rvcnk7XG4vKipcbiAqIEEgYmFzZSBydWxlIHdoaWNoIGNhbGxzIGBtYXRjaGBcbiAqXG4gKiBUaGUgdmFsdWUgZnJvbSB0aGUgYG1hdGNoYCBmdW5jdGlvbiBpcyBwYXNzZWQgdGhyb3VnaCB0byB0aGUgYGhhbmRsZXJgLlxuICogQGludGVybmFsYXBpXG4gKi9cbnZhciBCYXNlVXJsUnVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlVXJsUnVsZShtYXRjaCwgaGFuZGxlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMudHlwZSA9ICdSQVcnO1xuICAgICAgICB0aGlzLm1hdGNoUHJpb3JpdHkgPSBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIDAgLSBfdGhpcy4kaWQ7IH07XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXIgfHwgY29tbW9uXzEuaWRlbnRpdHk7XG4gICAgfVxuICAgIHJldHVybiBCYXNlVXJsUnVsZTtcbn0oKSk7XG5leHBvcnRzLkJhc2VVcmxSdWxlID0gQmFzZVVybFJ1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmxSdWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB1cmxcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG4vKiogQGhpZGRlbiAqL1xudmFyIG1ha2VTdHViID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7IHJldHVybiAoKGFjY1trZXldID0gY29yZXNlcnZpY2VzXzEubm90SW1wbGVtZW50ZWQoa2V5KSksIGFjYyk7IH0sIHsgZGlzcG9zZTogY29tbW9uXzEubm9vcCB9KTtcbn07XG4vKiogQGhpZGRlbiAqL1xudmFyIGxvY2F0aW9uU2VydmljZXNGbnMgPSBbJ3VybCcsICdwYXRoJywgJ3NlYXJjaCcsICdoYXNoJywgJ29uQ2hhbmdlJ107XG4vKiogQGhpZGRlbiAqL1xudmFyIGxvY2F0aW9uQ29uZmlnRm5zID0gWydwb3J0JywgJ3Byb3RvY29sJywgJ2hvc3QnLCAnYmFzZUhyZWYnLCAnaHRtbDVNb2RlJywgJ2hhc2hQcmVmaXgnXTtcbi8qKiBAaGlkZGVuICovXG52YXIgdW1mRm5zID0gWyd0eXBlJywgJ2Nhc2VJbnNlbnNpdGl2ZScsICdzdHJpY3RNb2RlJywgJ2RlZmF1bHRTcXVhc2hQb2xpY3knXTtcbi8qKiBAaGlkZGVuICovXG52YXIgcnVsZXNGbnMgPSBbJ3NvcnQnLCAnd2hlbicsICdpbml0aWFsJywgJ290aGVyd2lzZScsICdydWxlcycsICdydWxlJywgJ3JlbW92ZVJ1bGUnXTtcbi8qKiBAaGlkZGVuICovXG52YXIgc3luY0ZucyA9IFsnZGVmZXJJbnRlcmNlcHQnLCAnbGlzdGVuJywgJ3N5bmMnLCAnbWF0Y2gnXTtcbi8qKlxuICogQVBJIGZvciBVUkwgbWFuYWdlbWVudFxuICovXG52YXIgVXJsU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIFVybFNlcnZpY2Uocm91dGVyLCBsYXRlQmluZCkge1xuICAgICAgICBpZiAobGF0ZUJpbmQgPT09IHZvaWQgMCkgeyBsYXRlQmluZCA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMucnVsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7fTtcbiAgICAgICAgLy8gcHJveHkgZnVuY3Rpb24gY2FsbHMgZnJvbSBVcmxTZXJ2aWNlIHRvIHRoZSBMb2NhdGlvblNlcnZpY2UvTG9jYXRpb25Db25maWdcbiAgICAgICAgdmFyIGxvY2F0aW9uU2VydmljZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIubG9jYXRpb25TZXJ2aWNlOyB9O1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhsb2NhdGlvblNlcnZpY2VzLCB0aGlzLCBsb2NhdGlvblNlcnZpY2VzLCBsb2NhdGlvblNlcnZpY2VzRm5zLCBsYXRlQmluZCk7XG4gICAgICAgIHZhciBsb2NhdGlvbkNvbmZpZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5sb2NhdGlvbkNvbmZpZzsgfTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMobG9jYXRpb25Db25maWcsIHRoaXMuY29uZmlnLCBsb2NhdGlvbkNvbmZpZywgbG9jYXRpb25Db25maWdGbnMsIGxhdGVCaW5kKTtcbiAgICAgICAgdmFyIHVtZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci51cmxNYXRjaGVyRmFjdG9yeTsgfTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModW1mLCB0aGlzLmNvbmZpZywgdW1mLCB1bWZGbnMpO1xuICAgICAgICB2YXIgdXJsUm91dGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnVybFJvdXRlcjsgfTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModXJsUm91dGVyLCB0aGlzLnJ1bGVzLCB1cmxSb3V0ZXIsIHJ1bGVzRm5zKTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModXJsUm91dGVyLCB0aGlzLCB1cmxSb3V0ZXIsIHN5bmNGbnMpO1xuICAgIH1cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAobmV3dXJsLCByZXBsYWNlLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgVVJMIHBhcnRzXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXJyZW50IFVSTCBjb21wb25lbnRzIGFzIGEgW1tVcmxQYXJ0c11dIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVybCBwYXJ0c1xuICAgICAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLnBhcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBwYXRoOiB0aGlzLnBhdGgoKSwgc2VhcmNoOiB0aGlzLnNlYXJjaCgpLCBoYXNoOiB0aGlzLmhhc2goKSB9O1xuICAgIH07XG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5kZWZlckludGVyY2VwdCA9IGZ1bmN0aW9uIChkZWZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh1cmxQYXJ0cykge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybFNlcnZpY2UubG9jYXRpb25TZXJ2aWNlU3R1YiA9IG1ha2VTdHViKGxvY2F0aW9uU2VydmljZXNGbnMpO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVXJsU2VydmljZS5sb2NhdGlvbkNvbmZpZ1N0dWIgPSBtYWtlU3R1Yihsb2NhdGlvbkNvbmZpZ0Zucyk7XG4gICAgcmV0dXJuIFVybFNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5VcmxTZXJ2aWNlID0gVXJsU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybFNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZhbmlsbGEvaW5kZXhcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFuaWxsYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqIEEgYmFzZSBgTG9jYXRpb25TZXJ2aWNlc2AgKi9cbnZhciBCYXNlTG9jYXRpb25TZXJ2aWNlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlTG9jYXRpb25TZXJ2aWNlcyhyb3V0ZXIsIGZpcmVBZnRlclVwZGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZpcmVBZnRlclVwZGF0ZSA9IGZpcmVBZnRlclVwZGF0ZTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gZnVuY3Rpb24gKGV2dCkgeyByZXR1cm4gX3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IoZXZ0KTsgfSk7IH07XG4gICAgICAgIHRoaXMuaGFzaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEucGFyc2VVcmwoX3RoaXMuX2dldCgpKS5oYXNoOyB9O1xuICAgICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnBhcnNlVXJsKF90aGlzLl9nZXQoKSkucGF0aDsgfTtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmdldFBhcmFtcyh1dGlsc18xLnBhcnNlVXJsKF90aGlzLl9nZXQoKSkuc2VhcmNoKTsgfTtcbiAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBjb21tb25fMS5yb290LmxvY2F0aW9uO1xuICAgICAgICB0aGlzLl9oaXN0b3J5ID0gY29tbW9uXzEucm9vdC5oaXN0b3J5O1xuICAgIH1cbiAgICBCYXNlTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24gKHVybCwgcmVwbGFjZSkge1xuICAgICAgICBpZiAocmVwbGFjZSA9PT0gdm9pZCAwKSB7IHJlcGxhY2UgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjb21tb25fMS5pc0RlZmluZWQodXJsKSAmJiB1cmwgIT09IHRoaXMuX2dldCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXQobnVsbCwgbnVsbCwgdXJsLCByZXBsYWNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpcmVBZnRlclVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IoeyB1cmw6IHVybCB9KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuYnVpbGRVcmwodGhpcyk7XG4gICAgfTtcbiAgICBCYXNlTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goY2IpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tbW9uXzEucmVtb3ZlRnJvbShfdGhpcy5fbGlzdGVuZXJzLCBjYik7IH07XG4gICAgfTtcbiAgICBCYXNlTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgY29tbW9uXzEuZGVyZWdBbGwodGhpcy5fbGlzdGVuZXJzKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlTG9jYXRpb25TZXJ2aWNlcztcbn0oKSk7XG5leHBvcnRzLkJhc2VMb2NhdGlvblNlcnZpY2VzID0gQmFzZUxvY2F0aW9uU2VydmljZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlTG9jYXRpb25TZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG4vKiogQSBgTG9jYXRpb25Db25maWdgIHRoYXQgZGVsZWdhdGVzIHRvIHRoZSBicm93c2VyJ3MgYGxvY2F0aW9uYCBvYmplY3QgKi9cbnZhciBCcm93c2VyTG9jYXRpb25Db25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckxvY2F0aW9uQ29uZmlnKHJvdXRlciwgX2lzSHRtbDUpIHtcbiAgICAgICAgaWYgKF9pc0h0bWw1ID09PSB2b2lkIDApIHsgX2lzSHRtbDUgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLl9pc0h0bWw1ID0gX2lzSHRtbDU7XG4gICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9oYXNoUHJlZml4ID0gJyc7XG4gICAgfVxuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUucG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uLnBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobG9jYXRpb24ucG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9jb2woKSA9PT0gJ2h0dHBzJyA/IDQ0MyA6IDgwO1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5wcm90b2NvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLnByb3RvY29sLnJlcGxhY2UoLzovZywgJycpO1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5ob3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uaG9zdG5hbWU7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLmh0bWw1TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSHRtbDU7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLmhhc2hQcmVmaXggPSBmdW5jdGlvbiAobmV3cHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKG5ld3ByZWZpeCkgPyAodGhpcy5faGFzaFByZWZpeCA9IG5ld3ByZWZpeCkgOiB0aGlzLl9oYXNoUHJlZml4O1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5iYXNlSHJlZiA9IGZ1bmN0aW9uIChocmVmKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGhyZWYpXG4gICAgICAgICAgICA/ICh0aGlzLl9iYXNlSHJlZiA9IGhyZWYpXG4gICAgICAgICAgICA6IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodGhpcy5fYmFzZUhyZWYpID8gdGhpcy5fYmFzZUhyZWYgOiB0aGlzLmFwcGx5RG9jdW1lbnRCYXNlSHJlZigpO1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5hcHBseURvY3VtZW50QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYXNlVGFnID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKVswXTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9iYXNlSHJlZiA9IGJhc2VUYWcgPyBiYXNlVGFnLmhyZWYuc3Vic3RyKGxvY2F0aW9uLm9yaWdpbi5sZW5ndGgpIDogbG9jYXRpb24ucGF0aG5hbWUgfHwgJy8nKTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gQnJvd3NlckxvY2F0aW9uQ29uZmlnO1xufSgpKTtcbmV4cG9ydHMuQnJvd3NlckxvY2F0aW9uQ29uZmlnID0gQnJvd3NlckxvY2F0aW9uQ29uZmlnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3NlckxvY2F0aW9uQ29uZmlnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbnZhciBiYXNlTG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9iYXNlTG9jYXRpb25TZXJ2aWNlXCIpO1xuLyoqIEEgYExvY2F0aW9uU2VydmljZXNgIHRoYXQgdXNlcyB0aGUgYnJvd3NlciBoYXNoIFwiI1wiIHRvIGdldC9zZXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gKi9cbnZhciBIYXNoTG9jYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIYXNoTG9jYXRpb25TZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhhc2hMb2NhdGlvblNlcnZpY2Uocm91dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvdXRlciwgZmFsc2UpIHx8IHRoaXM7XG4gICAgICAgIGNvbW1vbl8xLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIF90aGlzLl9saXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEhhc2hMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS50cmltSGFzaFZhbCh0aGlzLl9sb2NhdGlvbi5oYXNoKTtcbiAgICB9O1xuICAgIEhhc2hMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHJlcGxhY2UpIHtcbiAgICAgICAgdGhpcy5fbG9jYXRpb24uaGFzaCA9IHVybDtcbiAgICB9O1xuICAgIEhhc2hMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMsIHJvdXRlcik7XG4gICAgICAgIGNvbW1vbl8xLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBIYXNoTG9jYXRpb25TZXJ2aWNlO1xufShiYXNlTG9jYXRpb25TZXJ2aWNlXzEuQmFzZUxvY2F0aW9uU2VydmljZXMpKTtcbmV4cG9ydHMuSGFzaExvY2F0aW9uU2VydmljZSA9IEhhc2hMb2NhdGlvblNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoTG9jYXRpb25TZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3FcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaW5qZWN0b3JcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vYmFzZUxvY2F0aW9uU2VydmljZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9oYXNoTG9jYXRpb25TZXJ2aWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL21lbW9yeUxvY2F0aW9uU2VydmljZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wdXNoU3RhdGVMb2NhdGlvblNlcnZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vbWVtb3J5TG9jYXRpb25Db25maWdcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vYnJvd3NlckxvY2F0aW9uQ29uZmlnXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BsdWdpbnNcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2luZGV4XCIpO1xuLy8gZ2xvYmFsbHkgYXZhaWxhYmxlIGluamVjdGFibGVzXG52YXIgZ2xvYmFscyA9IHt9O1xudmFyIFNUUklQX0NPTU1FTlRTID0gLygoXFwvXFwvLiokKXwoXFwvXFwqW1xcc1xcU10qP1xcKlxcLykpL2dtO1xudmFyIEFSR1VNRU5UX05BTUVTID0gLyhbXlxccyxdKykvZztcbi8qKlxuICogQSBiYXNpYyBhbmd1bGFyMS1saWtlIGluamVjdG9yIGFwaVxuICpcbiAqIFRoaXMgb2JqZWN0IGltcGxlbWVudHMgZm91ciBtZXRob2RzIHNpbWlsYXIgdG8gdGhlXG4gKiBbYW5ndWxhciAxIGRlcGVuZGVuY3kgaW5qZWN0b3JdKGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9hdXRvL3NlcnZpY2UvJGluamVjdG9yKVxuICpcbiAqIFVJLVJvdXRlciBldm9sdmVkIGZyb20gYW4gYW5ndWxhciAxIGxpYnJhcnkgdG8gYSBmcmFtZXdvcmsgYWdub3N0aWMgbGlicmFyeS5cbiAqIEhvd2V2ZXIsIHNvbWUgb2YgdGhlIGBAdWlyb3V0ZXIvY29yZWAgY29kZSB1c2VzIHRoZXNlIG5nMSBzdHlsZSBBUElzIHRvIHN1cHBvcnQgbmcxIHN0eWxlIGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICpcbiAqIFRoaXMgb2JqZWN0IHByb3ZpZGVzIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gb2YgYSBnbG9iYWxseSBzY29wZWQgZGVwZW5kZW5jeSBpbmplY3Rpb24gc3lzdGVtLlxuICogSXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBESSBhcHByb2FjaGVzOlxuICpcbiAqICMjIyBGdW5jdGlvbiBwYXJhbWV0ZXIgbmFtZXNcbiAqXG4gKiBBIGZ1bmN0aW9uJ3MgYC50b1N0cmluZygpYCBpcyBjYWxsZWQsIGFuZCB0aGUgcGFyYW1ldGVyIG5hbWVzIGFyZSBwYXJzZWQuXG4gKiBUaGlzIG9ubHkgd29ya3Mgd2hlbiB0aGUgcGFyYW1ldGVyIG5hbWVzIGFyZW4ndCBcIm1hbmdsZWRcIiBieSBhIG1pbmlmaWVyIHN1Y2ggYXMgVWdsaWZ5SlMuXG4gKlxuICogYGBganNcbiAqIGZ1bmN0aW9uIGluamVjdGVkRnVuY3Rpb24oRm9vU2VydmljZSwgQmFyU2VydmljZSkge1xuICogICAvLyBGb29TZXJ2aWNlIGFuZCBCYXJTZXJ2aWNlIGFyZSBpbmplY3RlZFxuICogfVxuICogYGBgXG4gKlxuICogIyMjIEZ1bmN0aW9uIGFubm90YXRpb25cbiAqXG4gKiBBIGZ1bmN0aW9uIG1heSBiZSBhbm5vdGF0ZWQgd2l0aCBhbiBhcnJheSBvZiBkZXBlbmRlbmN5IG5hbWVzIGFzIHRoZSBgJGluamVjdGAgcHJvcGVydHkuXG4gKlxuICogYGBganNcbiAqIGluamVjdGVkRnVuY3Rpb24uJGluamVjdCA9IFsgJ0Zvb1NlcnZpY2UnLCAnQmFyU2VydmljZScgXTtcbiAqIGZ1bmN0aW9uIGluamVjdGVkRnVuY3Rpb24oZnMsIGJzKSB7XG4gKiAgIC8vIEZvb1NlcnZpY2UgYW5kIEJhclNlcnZpY2UgYXJlIGluamVjdGVkIGFzIGZzIGFuZCBicyBwYXJhbWV0ZXJzXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgQXJyYXkgbm90YXRpb25cbiAqXG4gKiBBbiBhcnJheSBwcm92aWRlcyB0aGUgbmFtZXMgb2YgdGhlIGRlcGVuZGVuY2llcyB0byBpbmplY3QgKGFzIHN0cmluZ3MpLlxuICogVGhlIGZ1bmN0aW9uIGlzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuICpcbiAqIGBgYGpzXG4gKiBbICdGb29TZXJ2aWNlJywgJ0JhclNlcnZpY2UnLCBmdW5jdGlvbiAoZnMsIGJzKSB7XG4gKiAgIC8vIEZvb1NlcnZpY2UgYW5kIEJhclNlcnZpY2UgYXJlIGluamVjdGVkIGFzIGZzIGFuZCBicyBwYXJhbWV0ZXJzXG4gKiB9XVxuICogYGBgXG4gKlxuICogQHR5cGUgeyRJbmplY3Rvckxpa2V9XG4gKi9cbmV4cG9ydHMuJGluamVjdG9yID0ge1xuICAgIC8qKiBHZXRzIGFuIG9iamVjdCBmcm9tIERJIGJhc2VkIG9uIGEgc3RyaW5nIHRva2VuICovXG4gICAgZ2V0OiBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2xvYmFsc1tuYW1lXTsgfSxcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGFuIG9iamVjdCBuYW1lZCBgbmFtZWAgZXhpc3RzIGluIGdsb2JhbCBESSAqL1xuICAgIGhhczogZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGV4cG9ydHMuJGluamVjdG9yLmdldChuYW1lKSAhPSBudWxsOyB9LFxuICAgIC8qKlxuICAgICAqIEluamVjdHMgYSBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIHRoZSBmdW5jdGlvbiB0byBpbmplY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCB0aGUgZnVuY3Rpb24ncyBgdGhpc2AgYmluZGluZ1xuICAgICAqIEBwYXJhbSBsb2NhbHMgQW4gb2JqZWN0IHdpdGggYWRkaXRpb25hbCBESSB0b2tlbnMgYW5kIHZhbHVlcywgc3VjaCBhcyBgeyBzb21lVG9rZW46IHsgZm9vOiAxIH0gfWBcbiAgICAgKi9cbiAgICBpbnZva2U6IGZ1bmN0aW9uIChmbiwgY29udGV4dCwgbG9jYWxzKSB7XG4gICAgICAgIHZhciBhbGwgPSBpbmRleF8xLmV4dGVuZCh7fSwgZ2xvYmFscywgbG9jYWxzIHx8IHt9KTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGV4cG9ydHMuJGluamVjdG9yLmFubm90YXRlKGZuKTtcbiAgICAgICAgdmFyIGVuc3VyZUV4aXN0ID0gaW5kZXhfMS5hc3NlcnRQcmVkaWNhdGUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYWxsLmhhc093blByb3BlcnR5KGtleSk7IH0sIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFwiREkgY2FuJ3QgZmluZCBpbmplY3RhYmxlOiAnXCIgKyBrZXkgKyBcIidcIjsgfSk7XG4gICAgICAgIHZhciBhcmdzID0gcGFyYW1zLmZpbHRlcihlbnN1cmVFeGlzdCkubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBhbGxbeF07IH0pO1xuICAgICAgICBpZiAoaW5kZXhfMS5pc0Z1bmN0aW9uKGZuKSlcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZuLnNsaWNlKC0xKVswXS5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbidzIGRlcGVuZGVuY2llc1xuICAgICAqXG4gICAgICogQW5hbHl6ZXMgYSBmdW5jdGlvbiAob3IgYXJyYXkpIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIERJIHRva2VucyB0aGF0IHRoZSBmdW5jdGlvbiByZXF1aXJlcy5cbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGBzdHJpbmdgc1xuICAgICAqL1xuICAgIGFubm90YXRlOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKCFpbmRleF8xLmlzSW5qZWN0YWJsZShmbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbjogXCIgKyBmbik7XG4gICAgICAgIGlmIChmbiAmJiBmbi4kaW5qZWN0KVxuICAgICAgICAgICAgcmV0dXJuIGZuLiRpbmplY3Q7XG4gICAgICAgIGlmIChpbmRleF8xLmlzQXJyYXkoZm4pKVxuICAgICAgICAgICAgcmV0dXJuIGZuLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgdmFyIGZuU3RyID0gZm4udG9TdHJpbmcoKS5yZXBsYWNlKFNUUklQX0NPTU1FTlRTLCAnJyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBmblN0ci5zbGljZShmblN0ci5pbmRleE9mKCcoJykgKyAxLCBmblN0ci5pbmRleE9mKCcpJykpLm1hdGNoKEFSR1VNRU5UX05BTUVTKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBbXTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xuLyoqIEEgYExvY2F0aW9uQ29uZmlnYCBtb2NrIHRoYXQgZ2V0cy9zZXRzIGFsbCBjb25maWcgZnJvbSBhbiBpbi1tZW1vcnkgb2JqZWN0ICovXG52YXIgTWVtb3J5TG9jYXRpb25Db25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVtb3J5TG9jYXRpb25Db25maWcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlzcG9zZSA9IGNvbW1vbl8xLm5vb3A7XG4gICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gJyc7XG4gICAgICAgIHRoaXMuX3BvcnQgPSA4MDtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wgPSAnaHR0cCc7XG4gICAgICAgIHRoaXMuX2hvc3QgPSAnbG9jYWxob3N0JztcbiAgICAgICAgdGhpcy5faGFzaFByZWZpeCA9ICcnO1xuICAgICAgICB0aGlzLnBvcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcG9ydDsgfTtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wcm90b2NvbDsgfTtcbiAgICAgICAgdGhpcy5ob3N0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2hvc3Q7IH07XG4gICAgICAgIHRoaXMuYmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYmFzZUhyZWY7IH07XG4gICAgICAgIHRoaXMuaHRtbDVNb2RlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICAgIHRoaXMuaGFzaFByZWZpeCA9IGZ1bmN0aW9uIChuZXd2YWwpIHsgcmV0dXJuIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKG5ld3ZhbCkgPyAoX3RoaXMuX2hhc2hQcmVmaXggPSBuZXd2YWwpIDogX3RoaXMuX2hhc2hQcmVmaXgpOyB9O1xuICAgIH1cbiAgICByZXR1cm4gTWVtb3J5TG9jYXRpb25Db25maWc7XG59KCkpO1xuZXhwb3J0cy5NZW1vcnlMb2NhdGlvbkNvbmZpZyA9IE1lbW9yeUxvY2F0aW9uQ29uZmlnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVtb3J5TG9jYXRpb25Db25maWcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgYmFzZUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vYmFzZUxvY2F0aW9uU2VydmljZVwiKTtcbi8qKiBBIGBMb2NhdGlvblNlcnZpY2VzYCB0aGF0IGdldHMvc2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiBmcm9tIGFuIGluLW1lbW9yeSBvYmplY3QgKi9cbnZhciBNZW1vcnlMb2NhdGlvblNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lbW9yeUxvY2F0aW9uU2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZW1vcnlMb2NhdGlvblNlcnZpY2Uocm91dGVyKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCByb3V0ZXIsIHRydWUpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1lbW9yeUxvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9O1xuICAgIE1lbW9yeUxvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcmVwbGFjZSkge1xuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgfTtcbiAgICByZXR1cm4gTWVtb3J5TG9jYXRpb25TZXJ2aWNlO1xufShiYXNlTG9jYXRpb25TZXJ2aWNlXzEuQmFzZUxvY2F0aW9uU2VydmljZXMpKTtcbmV4cG9ydHMuTWVtb3J5TG9jYXRpb25TZXJ2aWNlID0gTWVtb3J5TG9jYXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVtb3J5TG9jYXRpb25TZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBicm93c2VyTG9jYXRpb25Db25maWdfMSA9IHJlcXVpcmUoXCIuL2Jyb3dzZXJMb2NhdGlvbkNvbmZpZ1wiKTtcbnZhciBoYXNoTG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9oYXNoTG9jYXRpb25TZXJ2aWNlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBwdXNoU3RhdGVMb2NhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3B1c2hTdGF0ZUxvY2F0aW9uU2VydmljZVwiKTtcbnZhciBtZW1vcnlMb2NhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL21lbW9yeUxvY2F0aW9uU2VydmljZVwiKTtcbnZhciBtZW1vcnlMb2NhdGlvbkNvbmZpZ18xID0gcmVxdWlyZShcIi4vbWVtb3J5TG9jYXRpb25Db25maWdcIik7XG52YXIgaW5qZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2luamVjdG9yXCIpO1xudmFyIHFfMSA9IHJlcXVpcmUoXCIuL3FcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbmZ1bmN0aW9uIHNlcnZpY2VzUGx1Z2luKHJvdXRlcikge1xuICAgIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3RvciA9IGluamVjdG9yXzEuJGluamVjdG9yO1xuICAgIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxID0gcV8xLiRxO1xuICAgIHJldHVybiB7IG5hbWU6ICd2YW5pbGxhLnNlcnZpY2VzJywgJHE6IHFfMS4kcSwgJGluamVjdG9yOiBpbmplY3Rvcl8xLiRpbmplY3RvciwgZGlzcG9zZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSB9O1xufVxuZXhwb3J0cy5zZXJ2aWNlc1BsdWdpbiA9IHNlcnZpY2VzUGx1Z2luO1xuLyoqIEEgYFVJUm91dGVyUGx1Z2luYCB1c2VzIHRoZSBicm93c2VyIGhhc2ggdG8gZ2V0L3NldCB0aGUgY3VycmVudCBsb2NhdGlvbiAqL1xuZXhwb3J0cy5oYXNoTG9jYXRpb25QbHVnaW4gPSB1dGlsc18xLmxvY2F0aW9uUGx1Z2luRmFjdG9yeSgndmFuaWxsYS5oYXNoQmFuZ0xvY2F0aW9uJywgZmFsc2UsIGhhc2hMb2NhdGlvblNlcnZpY2VfMS5IYXNoTG9jYXRpb25TZXJ2aWNlLCBicm93c2VyTG9jYXRpb25Db25maWdfMS5Ccm93c2VyTG9jYXRpb25Db25maWcpO1xuLyoqIEEgYFVJUm91dGVyUGx1Z2luYCB0aGF0IGdldHMvc2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiB1c2luZyB0aGUgYnJvd3NlcidzIGBsb2NhdGlvbmAgYW5kIGBoaXN0b3J5YCBhcGlzICovXG5leHBvcnRzLnB1c2hTdGF0ZUxvY2F0aW9uUGx1Z2luID0gdXRpbHNfMS5sb2NhdGlvblBsdWdpbkZhY3RvcnkoJ3ZhbmlsbGEucHVzaFN0YXRlTG9jYXRpb24nLCB0cnVlLCBwdXNoU3RhdGVMb2NhdGlvblNlcnZpY2VfMS5QdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UsIGJyb3dzZXJMb2NhdGlvbkNvbmZpZ18xLkJyb3dzZXJMb2NhdGlvbkNvbmZpZyk7XG4vKiogQSBgVUlSb3V0ZXJQbHVnaW5gIHRoYXQgZ2V0cy9zZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGZyb20gYW4gaW4tbWVtb3J5IG9iamVjdCAqL1xuZXhwb3J0cy5tZW1vcnlMb2NhdGlvblBsdWdpbiA9IHV0aWxzXzEubG9jYXRpb25QbHVnaW5GYWN0b3J5KCd2YW5pbGxhLm1lbW9yeUxvY2F0aW9uJywgZmFsc2UsIG1lbW9yeUxvY2F0aW9uU2VydmljZV8xLk1lbW9yeUxvY2F0aW9uU2VydmljZSwgbWVtb3J5TG9jYXRpb25Db25maWdfMS5NZW1vcnlMb2NhdGlvbkNvbmZpZyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW5zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmFzZUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vYmFzZUxvY2F0aW9uU2VydmljZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vKipcbiAqIEEgYExvY2F0aW9uU2VydmljZXNgIHRoYXQgZ2V0cy9zZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIHVzaW5nIHRoZSBicm93c2VyJ3MgYGxvY2F0aW9uYCBhbmQgYGhpc3RvcnlgIGFwaXNcbiAqXG4gKiBVc2VzIGBoaXN0b3J5LnB1c2hTdGF0ZWAgYW5kIGBoaXN0b3J5LnJlcGxhY2VTdGF0ZWBcbiAqL1xudmFyIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZShyb3V0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcm91dGVyLCB0cnVlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29uZmlnID0gcm91dGVyLnVybFNlcnZpY2UuY29uZmlnO1xuICAgICAgICBjb21tb25fMS5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgX3RoaXMuX2xpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYmFzZSBwcmVmaXggd2l0aG91dDpcbiAgICAgKiAtIHRyYWlsaW5nIHNsYXNoXG4gICAgICogLSB0cmFpbGluZyBmaWxlbmFtZVxuICAgICAqIC0gcHJvdG9jb2wgYW5kIGhvc3RuYW1lXG4gICAgICpcbiAgICAgKiBJZiA8YmFzZSBocmVmPScvYmFzZS8nPiwgdGhpcyByZXR1cm5zICcvYmFzZScuXG4gICAgICogSWYgPGJhc2UgaHJlZj0nL2Zvby9iYXNlLyc+LCB0aGlzIHJldHVybnMgJy9mb28vYmFzZScuXG4gICAgICogSWYgPGJhc2UgaHJlZj0nL2Jhc2UvaW5kZXguaHRtbCc+LCB0aGlzIHJldHVybnMgJy9iYXNlJy5cbiAgICAgKiBJZiA8YmFzZSBocmVmPSdodHRwOi8vbG9jYWxob3N0OjgwODAvYmFzZS9pbmRleC5odG1sJz4sIHRoaXMgcmV0dXJucyAnL2Jhc2UnLlxuICAgICAqIElmIDxiYXNlIGhyZWY9Jy9iYXNlJz4sIHRoaXMgcmV0dXJucyAnJy5cbiAgICAgKiBJZiA8YmFzZSBocmVmPSdodHRwOi8vbG9jYWxob3N0OjgwODAnPiwgdGhpcyByZXR1cm5zICcnLlxuICAgICAqIElmIDxiYXNlIGhyZWY9J2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC8nPiwgdGhpcyByZXR1cm5zICcnLlxuICAgICAqXG4gICAgICogU2VlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL2Rldi9zZW1hbnRpY3MuaHRtbCN0aGUtYmFzZS1lbGVtZW50XG4gICAgICovXG4gICAgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0QmFzZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnN0cmlwTGFzdFBhdGhFbGVtZW50KHRoaXMuX2NvbmZpZy5iYXNlSHJlZigpKTtcbiAgICB9O1xuICAgIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fbG9jYXRpb24sIHBhdGhuYW1lID0gX2EucGF0aG5hbWUsIGhhc2ggPSBfYS5oYXNoLCBzZWFyY2ggPSBfYS5zZWFyY2g7XG4gICAgICAgIHNlYXJjaCA9IGNvbW1vbl8xLnNwbGl0UXVlcnkoc2VhcmNoKVsxXTsgLy8gc3RyaXAgPyBpZiBmb3VuZFxuICAgICAgICBoYXNoID0gY29tbW9uXzEuc3BsaXRIYXNoKGhhc2gpWzFdOyAvLyBzdHJpcCAjIGlmIGZvdW5kXG4gICAgICAgIHZhciBiYXNlUHJlZml4ID0gdGhpcy5fZ2V0QmFzZVByZWZpeCgpO1xuICAgICAgICB2YXIgZXhhY3RCYXNlSHJlZk1hdGNoID0gcGF0aG5hbWUgPT09IHRoaXMuX2NvbmZpZy5iYXNlSHJlZigpO1xuICAgICAgICB2YXIgc3RhcnRzV2l0aEJhc2UgPSBwYXRobmFtZS5zdWJzdHIoMCwgYmFzZVByZWZpeC5sZW5ndGgpID09PSBiYXNlUHJlZml4O1xuICAgICAgICBwYXRobmFtZSA9IGV4YWN0QmFzZUhyZWZNYXRjaCA/ICcvJyA6IHN0YXJ0c1dpdGhCYXNlID8gcGF0aG5hbWUuc3Vic3RyaW5nKGJhc2VQcmVmaXgubGVuZ3RoKSA6IHBhdGhuYW1lO1xuICAgICAgICByZXR1cm4gcGF0aG5hbWUgKyAoc2VhcmNoID8gJz8nICsgc2VhcmNoIDogJycpICsgKGhhc2ggPyAnIycgKyBoYXNoIDogJycpO1xuICAgIH07XG4gICAgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCByZXBsYWNlKSB7XG4gICAgICAgIHZhciBiYXNlUHJlZml4ID0gdGhpcy5fZ2V0QmFzZVByZWZpeCgpO1xuICAgICAgICB2YXIgc2xhc2ggPSB1cmwgJiYgdXJsWzBdICE9PSAnLycgPyAnLycgOiAnJztcbiAgICAgICAgdmFyIGZ1bGxVcmwgPSB1cmwgPT09ICcnIHx8IHVybCA9PT0gJy8nID8gdGhpcy5fY29uZmlnLmJhc2VIcmVmKCkgOiBiYXNlUHJlZml4ICsgc2xhc2ggKyB1cmw7XG4gICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgICB0aGlzLl9oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIGZ1bGxVcmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCBmdWxsVXJsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzLCByb3V0ZXIpO1xuICAgICAgICBjb21tb25fMS5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5fbGlzdGVuZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZTtcbn0oYmFzZUxvY2F0aW9uU2VydmljZV8xLkJhc2VMb2NhdGlvblNlcnZpY2VzKSk7XG5leHBvcnRzLlB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZSA9IFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaW5kZXhcIik7XG4vKipcbiAqIEFuIGFuZ3VsYXIxLWxpa2UgcHJvbWlzZSBhcGlcbiAqXG4gKiBUaGlzIG9iamVjdCBpbXBsZW1lbnRzIGZvdXIgbWV0aG9kcyBzaW1pbGFyIHRvIHRoZVxuICogW2FuZ3VsYXIgMSBwcm9taXNlIGFwaV0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nL3NlcnZpY2UvJHEpXG4gKlxuICogVUktUm91dGVyIGV2b2x2ZWQgZnJvbSBhbiBhbmd1bGFyIDEgbGlicmFyeSB0byBhIGZyYW1ld29yayBhZ25vc3RpYyBsaWJyYXJ5LlxuICogSG93ZXZlciwgc29tZSBvZiB0aGUgYEB1aXJvdXRlci9jb3JlYCBjb2RlIHVzZXMgdGhlc2UgbmcxIHN0eWxlIEFQSXMgdG8gc3VwcG9ydCBuZzEgc3R5bGUgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gKlxuICogVGhpcyBBUEkgcHJvdmlkZXMgbmF0aXZlIEVTNiBwcm9taXNlIHN1cHBvcnQgd3JhcHBlZCBhcyBhICRxLWxpa2UgQVBJLlxuICogSW50ZXJuYWxseSwgVUktUm91dGVyIHVzZXMgdGhpcyAkcSBvYmplY3QgdG8gcGVyZm9ybSBwcm9taXNlIG9wZXJhdGlvbnMuXG4gKiBUaGUgYGFuZ3VsYXItdWktcm91dGVyYCAodWktcm91dGVyIGZvciBhbmd1bGFyIDEpIHVzZXMgdGhlICRxIEFQSSBwcm92aWRlZCBieSBhbmd1bGFyLlxuICpcbiAqICRxLWxpa2UgcHJvbWlzZSBhcGlcbiAqL1xuZXhwb3J0cy4kcSA9IHtcbiAgICAvKiogTm9ybWFsaXplcyBhIHZhbHVlIGFzIGEgcHJvbWlzZSAqL1xuICAgIHdoZW46IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgcmV0dXJuIHJlc29sdmUodmFsKTsgfSk7IH0sXG4gICAgLyoqIE5vcm1hbGl6ZXMgYSB2YWx1ZSBhcyBhIHByb21pc2UgcmVqZWN0aW9uICovXG4gICAgcmVqZWN0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICByZWplY3QodmFsKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybnMgYSBkZWZlcnJlZCBvYmplY3QsIHdoaWNoIGhhcyBgcmVzb2x2ZWAgYW5kIGByZWplY3RgIGZ1bmN0aW9ucyAqL1xuICAgIGRlZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHt9O1xuICAgICAgICBkZWZlcnJlZC5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgfSxcbiAgICAvKiogTGlrZSBQcm9taXNlLmFsbCgpLCBidXQgYWxzbyBzdXBwb3J0cyBvYmplY3Qga2V5L3Byb21pc2Ugbm90YXRpb24gbGlrZSAkcSAqL1xuICAgIGFsbDogZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIGlmIChpbmRleF8xLmlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleF8xLmlzT2JqZWN0KHByb21pc2VzKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBwcm9taXNlcyBtYXAgdG8gcHJvbWlzZXMgYXJyYXkuXG4gICAgICAgICAgICAvLyBXaGVuIGVhY2ggcHJvbWlzZSByZXNvbHZlcywgbWFwIGl0IHRvIGEgdHVwbGUgeyBrZXk6IGtleSwgdmFsOiB2YWwgfVxuICAgICAgICAgICAgdmFyIGNoYWluID0gT2JqZWN0LmtleXMocHJvbWlzZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBwcm9taXNlc1trZXldLnRoZW4oZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDogdmFsIH0pOyB9KTsgfSk7XG4gICAgICAgICAgICAvLyBUaGVuIHdhaXQgZm9yIGFsbCBwcm9taXNlcyB0byByZXNvbHZlLCBhbmQgY29udmVydCB0aGVtIGJhY2sgdG8gYW4gb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kcS5hbGwoY2hhaW4pLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHR1cGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1t0dXBsZS5rZXldID0gdHVwbGUudmFsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5leHBvcnRzLmtleVZhbHNUb09iamVjdFIgPSBmdW5jdGlvbiAoYWNjdW0sIF9hKSB7XG4gICAgdmFyIGtleSA9IF9hWzBdLCB2YWwgPSBfYVsxXTtcbiAgICBpZiAoIWFjY3VtLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgYWNjdW1ba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29tbW9uXzEuaXNBcnJheShhY2N1bVtrZXldKSkge1xuICAgICAgICBhY2N1bVtrZXldLnB1c2godmFsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY3VtW2tleV0gPSBbYWNjdW1ba2V5XSwgdmFsXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtO1xufTtcbmV4cG9ydHMuZ2V0UGFyYW1zID0gZnVuY3Rpb24gKHF1ZXJ5U3RyaW5nKSB7XG4gICAgcmV0dXJuIHF1ZXJ5U3RyaW5nXG4gICAgICAgIC5zcGxpdCgnJicpXG4gICAgICAgIC5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpXG4gICAgICAgIC5tYXAoY29tbW9uXzEuc3BsaXRFcXVhbClcbiAgICAgICAgLnJlZHVjZShleHBvcnRzLmtleVZhbHNUb09iamVjdFIsIHt9KTtcbn07XG5mdW5jdGlvbiBwYXJzZVVybCh1cmwpIHtcbiAgICB2YXIgb3JFbXB0eVN0cmluZyA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IHx8ICcnOyB9O1xuICAgIHZhciBfYSA9IGNvbW1vbl8xLnNwbGl0SGFzaCh1cmwpLm1hcChvckVtcHR5U3RyaW5nKSwgYmVmb3JlaGFzaCA9IF9hWzBdLCBoYXNoID0gX2FbMV07XG4gICAgdmFyIF9iID0gY29tbW9uXzEuc3BsaXRRdWVyeShiZWZvcmVoYXNoKS5tYXAob3JFbXB0eVN0cmluZyksIHBhdGggPSBfYlswXSwgc2VhcmNoID0gX2JbMV07XG4gICAgcmV0dXJuIHsgcGF0aDogcGF0aCwgc2VhcmNoOiBzZWFyY2gsIGhhc2g6IGhhc2gsIHVybDogdXJsIH07XG59XG5leHBvcnRzLnBhcnNlVXJsID0gcGFyc2VVcmw7XG5leHBvcnRzLmJ1aWxkVXJsID0gZnVuY3Rpb24gKGxvYykge1xuICAgIHZhciBwYXRoID0gbG9jLnBhdGgoKTtcbiAgICB2YXIgc2VhcmNoT2JqZWN0ID0gbG9jLnNlYXJjaCgpO1xuICAgIHZhciBoYXNoID0gbG9jLmhhc2goKTtcbiAgICB2YXIgc2VhcmNoID0gT2JqZWN0LmtleXMoc2VhcmNoT2JqZWN0KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gc2VhcmNoT2JqZWN0W2tleV07XG4gICAgICAgIHZhciB2YWxzID0gY29tbW9uXzEuaXNBcnJheShwYXJhbSkgPyBwYXJhbSA6IFtwYXJhbV07XG4gICAgICAgIHJldHVybiB2YWxzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBrZXkgKyAnPScgKyB2YWw7IH0pO1xuICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgIC5qb2luKCcmJyk7XG4gICAgcmV0dXJuIHBhdGggKyAoc2VhcmNoID8gJz8nICsgc2VhcmNoIDogJycpICsgKGhhc2ggPyAnIycgKyBoYXNoIDogJycpO1xufTtcbmZ1bmN0aW9uIGxvY2F0aW9uUGx1Z2luRmFjdG9yeShuYW1lLCBpc0h0bWw1LCBzZXJ2aWNlQ2xhc3MsIGNvbmZpZ3VyYXRpb25DbGFzcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodWlSb3V0ZXIpIHtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSAodWlSb3V0ZXIubG9jYXRpb25TZXJ2aWNlID0gbmV3IHNlcnZpY2VDbGFzcyh1aVJvdXRlcikpO1xuICAgICAgICB2YXIgY29uZmlndXJhdGlvbiA9ICh1aVJvdXRlci5sb2NhdGlvbkNvbmZpZyA9IG5ldyBjb25maWd1cmF0aW9uQ2xhc3ModWlSb3V0ZXIsIGlzSHRtbDUpKTtcbiAgICAgICAgZnVuY3Rpb24gZGlzcG9zZShyb3V0ZXIpIHtcbiAgICAgICAgICAgIHJvdXRlci5kaXNwb3NlKHNlcnZpY2UpO1xuICAgICAgICAgICAgcm91dGVyLmRpc3Bvc2UoY29uZmlndXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgc2VydmljZTogc2VydmljZSwgY29uZmlndXJhdGlvbjogY29uZmlndXJhdGlvbiwgZGlzcG9zZTogZGlzcG9zZSB9O1xuICAgIH07XG59XG5leHBvcnRzLmxvY2F0aW9uUGx1Z2luRmFjdG9yeSA9IGxvY2F0aW9uUGx1Z2luRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZpZXdcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHZpZXdcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xuLyoqXG4gKiBUaGUgVmlldyBzZXJ2aWNlXG4gKlxuICogVGhpcyBzZXJ2aWNlIHBhaXJzIGV4aXN0aW5nIGB1aS12aWV3YCBjb21wb25lbnRzICh3aGljaCBsaXZlIGluIHRoZSBET00pXG4gKiB3aXRoIHZpZXcgY29uZmlncyAoZnJvbSB0aGUgc3RhdGUgZGVjbGFyYXRpb24gb2JqZWN0czogW1tTdGF0ZURlY2xhcmF0aW9uLnZpZXdzXV0pLlxuICpcbiAqIC0gQWZ0ZXIgYSBzdWNjZXNzZnVsIFRyYW5zaXRpb24sIHRoZSB2aWV3cyBmcm9tIHRoZSBuZXdseSBlbnRlcmVkIHN0YXRlcyBhcmUgYWN0aXZhdGVkIHZpYSBbW2FjdGl2YXRlVmlld0NvbmZpZ11dLlxuICogICBUaGUgdmlld3MgZnJvbSBleGl0ZWQgc3RhdGVzIGFyZSBkZWFjdGl2YXRlZCB2aWEgW1tkZWFjdGl2YXRlVmlld0NvbmZpZ11dLlxuICogICAoU2VlOiB0aGUgW1tyZWdpc3RlckFjdGl2YXRlVmlld3NdXSBUcmFuc2l0aW9uIEhvb2spXG4gKlxuICogLSBBcyBgdWktdmlld2AgY29tcG9uZW50cyBwb3AgaW4gYW5kIG91dCBvZiBleGlzdGVuY2UsIHRoZXkgcmVnaXN0ZXIgdGhlbXNlbHZlcyB1c2luZyBbW3JlZ2lzdGVyVUlWaWV3XV0uXG4gKlxuICogLSBXaGVuIHRoZSBbW3N5bmNdXSBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSByZWdpc3RlcmVkIGB1aS12aWV3YChzKSAoW1tBY3RpdmVVSVZpZXddXSlcbiAqIGFyZSBjb25maWd1cmVkIHdpdGggdGhlIG1hdGNoaW5nIFtbVmlld0NvbmZpZ11dKHMpXG4gKlxuICovXG52YXIgVmlld1NlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld1NlcnZpY2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3VpVmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdmlld0NvbmZpZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdmlld0NvbmZpZ0ZhY3RvcmllcyA9IHt9O1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcGx1Z2luYXBpID0ge1xuICAgICAgICAgICAgX3Jvb3RWaWV3Q29udGV4dDogdGhpcy5fcm9vdFZpZXdDb250ZXh0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfdmlld0NvbmZpZ0ZhY3Rvcnk6IHRoaXMuX3ZpZXdDb25maWdGYWN0b3J5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfcmVnaXN0ZXJlZFVJVmlld3M6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl91aVZpZXdzOyB9LFxuICAgICAgICAgICAgX2FjdGl2ZVZpZXdDb25maWdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdmlld0NvbmZpZ3M7IH0sXG4gICAgICAgICAgICBfb25TeW5jOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tb25fMS5yZW1vdmVGcm9tKF90aGlzLl9saXN0ZW5lcnMsIGxpc3RlbmVyKTsgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSB2aWV3J3MgbmFtZSBmcm9tIGEgc3RhdGUudmlld3MgY29uZmlndXJhdGlvbiBibG9jay5cbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgYnkgYSBmcmFtZXdvcmsgaW1wbGVtZW50YXRpb24gdG8gY2FsY3VsYXRlIHRoZSB2YWx1ZXMgZm9yXG4gICAgICogW1tfVmlld0RlY2xhcmF0aW9uLiR1aVZpZXdOYW1lXV0gYW5kIFtbX1ZpZXdEZWNsYXJhdGlvbi4kdWlWaWV3Q29udGV4dEFuY2hvcl1dLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRleHQgdGhlIGNvbnRleHQgb2JqZWN0IChzdGF0ZSBkZWNsYXJhdGlvbikgdGhhdCB0aGUgdmlldyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHJhd1ZpZXdOYW1lIHRoZSBuYW1lIG9mIHRoZSB2aWV3LCBhcyBkZWNsYXJlZCBpbiB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uLnZpZXdzXV1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBub3JtYWxpemVkIHVpVmlld05hbWUgYW5kIHVpVmlld0NvbnRleHRBbmNob3IgdGhhdCB0aGUgdmlldyB0YXJnZXRzXG4gICAgICovXG4gICAgVmlld1NlcnZpY2Uubm9ybWFsaXplVUlWaWV3VGFyZ2V0ID0gZnVuY3Rpb24gKGNvbnRleHQsIHJhd1ZpZXdOYW1lKSB7XG4gICAgICAgIGlmIChyYXdWaWV3TmFtZSA9PT0gdm9pZCAwKSB7IHJhd1ZpZXdOYW1lID0gJyc7IH1cbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgaW5jb21pbmcgdmlldyBuYW1lIHdpdGggYSByZWdleHAgdG8gYWxsb3c6XG4gICAgICAgIC8vIGV4OiBcInZpZXcubmFtZUBmb28uYmFyXCIgLCBcIl4uXi52aWV3Lm5hbWVcIiAsIFwidmlldy5uYW1lQF4uXlwiICwgXCJcIiAsXG4gICAgICAgIC8vIFwiQFwiICwgXCIkZGVmYXVsdEBeXCIgLCBcIiEkZGVmYXVsdC4kZGVmYXVsdFwiICwgXCIhZm9vLmJhclwiXG4gICAgICAgIHZhciB2aWV3QXRDb250ZXh0ID0gcmF3Vmlld05hbWUuc3BsaXQoJ0AnKTtcbiAgICAgICAgdmFyIHVpVmlld05hbWUgPSB2aWV3QXRDb250ZXh0WzBdIHx8ICckZGVmYXVsdCc7IC8vIGRlZmF1bHQgdG8gdW5uYW1lZCB2aWV3XG4gICAgICAgIHZhciB1aVZpZXdDb250ZXh0QW5jaG9yID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKHZpZXdBdENvbnRleHRbMV0pID8gdmlld0F0Q29udGV4dFsxXSA6ICdeJzsgLy8gZGVmYXVsdCB0byBwYXJlbnQgY29udGV4dFxuICAgICAgICAvLyBIYW5kbGUgcmVsYXRpdmUgdmlldy1uYW1lIHN1Z2FyIHN5bnRheC5cbiAgICAgICAgLy8gTWF0Y2hlcyByYXdWaWV3TmFtZSBcIl4uXi5eLmZvby5iYXJcIiBpbnRvIGFycmF5OiBbXCJeLl4uXi5mb28uYmFyXCIsIFwiXi5eLl5cIiwgXCJmb28uYmFyXCJdLFxuICAgICAgICB2YXIgcmVsYXRpdmVWaWV3TmFtZVN1Z2FyID0gL14oXFxeKD86XFwuXFxeKSopXFwuKC4qJCkvLmV4ZWModWlWaWV3TmFtZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZVZpZXdOYW1lU3VnYXIpIHtcbiAgICAgICAgICAgIC8vIENsb2JiZXJzIGV4aXN0aW5nIGNvbnRleHRBbmNob3IgKHJhd1ZpZXdOYW1lIHZhbGlkYXRpb24gd2lsbCBmaXggdGhpcylcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSByZWxhdGl2ZVZpZXdOYW1lU3VnYXJbMV07IC8vIHNldCBhbmNob3IgdG8gXCJeLl4uXlwiXG4gICAgICAgICAgICB1aVZpZXdOYW1lID0gcmVsYXRpdmVWaWV3TmFtZVN1Z2FyWzJdOyAvLyBzZXQgdmlldy1uYW1lIHRvIFwiZm9vLmJhclwiXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpVmlld05hbWUuY2hhckF0KDApID09PSAnIScpIHtcbiAgICAgICAgICAgIHVpVmlld05hbWUgPSB1aVZpZXdOYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSAnJzsgLy8gdGFyZ2V0IGFic29sdXRlbHkgZnJvbSByb290XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIHBhcmVudCByZWxhdGl2ZSB0YXJnZXRpbmcgXCJeLl4uXlwiXG4gICAgICAgIHZhciByZWxhdGl2ZU1hdGNoID0gL14oXFxeKD86XFwuXFxeKSopJC87XG4gICAgICAgIGlmIChyZWxhdGl2ZU1hdGNoLmV4ZWModWlWaWV3Q29udGV4dEFuY2hvcikpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3JTdGF0ZSA9IHVpVmlld0NvbnRleHRBbmNob3Iuc3BsaXQoJy4nKS5yZWR1Y2UoZnVuY3Rpb24gKGFuY2hvciwgeCkgeyByZXR1cm4gYW5jaG9yLnBhcmVudDsgfSwgY29udGV4dCk7XG4gICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gYW5jaG9yU3RhdGUubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1aVZpZXdDb250ZXh0QW5jaG9yID09PSAnLicpIHtcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSBjb250ZXh0Lm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdWlWaWV3TmFtZTogdWlWaWV3TmFtZSwgdWlWaWV3Q29udGV4dEFuY2hvcjogdWlWaWV3Q29udGV4dEFuY2hvciB9O1xuICAgIH07XG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLl9yb290Vmlld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3Jvb3RDb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLl9yb290Q29udGV4dCk7XG4gICAgfTtcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuX3ZpZXdDb25maWdGYWN0b3J5ID0gZnVuY3Rpb24gKHZpZXdUeXBlLCBmYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDb25maWdGYWN0b3JpZXNbdmlld1R5cGVdID0gZmFjdG9yeTtcbiAgICB9O1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGVWaWV3Q29uZmlnID0gZnVuY3Rpb24gKHBhdGgsIGRlY2wpIHtcbiAgICAgICAgdmFyIGNmZ0ZhY3RvcnkgPSB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzW2RlY2wuJHR5cGVdO1xuICAgICAgICBpZiAoIWNmZ0ZhY3RvcnkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZXdTZXJ2aWNlOiBObyB2aWV3IGNvbmZpZyBmYWN0b3J5IHJlZ2lzdGVyZWQgZm9yIHR5cGUgJyArIGRlY2wuJHR5cGUpO1xuICAgICAgICB2YXIgY2ZncyA9IGNmZ0ZhY3RvcnkocGF0aCwgZGVjbCk7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNBcnJheShjZmdzKSA/IGNmZ3MgOiBbY2Znc107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyBhIFZpZXdDb25maWcuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRlYWN0aXZhdGVzIGEgYFZpZXdDb25maWdgLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgW1tzeW5jXV0sIGl0IHdpbGwgdW4tcGFpciBmcm9tIGFueSBgdWktdmlld2Agd2l0aCB3aGljaCBpdCBpcyBjdXJyZW50bHkgcGFpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpZXdDb25maWcgVGhlIFZpZXdDb25maWcgdmlldyB0byBkZXJlZ2lzdGVyLlxuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5kZWFjdGl2YXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KCc8LSBSZW1vdmluZycsIHZpZXdDb25maWcpO1xuICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKHRoaXMuX3ZpZXdDb25maWdzLCB2aWV3Q29uZmlnKTtcbiAgICB9O1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5hY3RpdmF0ZVZpZXdDb25maWcgPSBmdW5jdGlvbiAodmlld0NvbmZpZykge1xuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VFdmVudCgnLT4gUmVnaXN0ZXJpbmcnLCB2aWV3Q29uZmlnKTtcbiAgICAgICAgdGhpcy5fdmlld0NvbmZpZ3MucHVzaCh2aWV3Q29uZmlnKTtcbiAgICB9O1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdWlWaWV3c0J5RnFuID0gdGhpcy5fdWlWaWV3cy5tYXAoZnVuY3Rpb24gKHVpdikgeyByZXR1cm4gW3Vpdi5mcW4sIHVpdl07IH0pLnJlZHVjZShjb21tb25fMS5hcHBseVBhaXJzLCB7fSk7XG4gICAgICAgIC8vIFJldHVybiBhIHdlaWdodGVkIGRlcHRoIHZhbHVlIGZvciBhIHVpVmlldy5cbiAgICAgICAgLy8gVGhlIGRlcHRoIGlzIHRoZSBuZXN0aW5nIGRlcHRoIG9mIHVpLXZpZXdzIChiYXNlZCBvbiBGUU47IHRpbWVzIDEwLDAwMClcbiAgICAgICAgLy8gcGx1cyB0aGUgZGVwdGggb2YgdGhlIHN0YXRlIHRoYXQgaXMgcG9wdWxhdGluZyB0aGUgdWlWaWV3XG4gICAgICAgIGZ1bmN0aW9uIHVpVmlld0RlcHRoKHVpVmlldykge1xuICAgICAgICAgICAgdmFyIHN0YXRlRGVwdGggPSBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gKGNvbnRleHQgJiYgY29udGV4dC5wYXJlbnQgPyBzdGF0ZURlcHRoKGNvbnRleHQucGFyZW50KSArIDEgOiAxKTsgfTtcbiAgICAgICAgICAgIHJldHVybiB1aVZpZXcuZnFuLnNwbGl0KCcuJykubGVuZ3RoICogMTAwMDAgKyBzdGF0ZURlcHRoKHVpVmlldy5jcmVhdGlvbkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgVmlld0NvbmZpZydzIGNvbnRleHQncyBkZXB0aCBpbiB0aGUgY29udGV4dCB0cmVlLlxuICAgICAgICBmdW5jdGlvbiB2aWV3Q29uZmlnRGVwdGgoY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbmZpZy52aWV3RGVjbC4kY29udGV4dCwgY291bnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCsrY291bnQgJiYgY29udGV4dC5wYXJlbnQpXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIEdpdmVuIGEgZGVwdGggZnVuY3Rpb24sIHJldHVybnMgYSBjb21wYXJlIGZ1bmN0aW9uIHdoaWNoIGNhbiByZXR1cm4gZWl0aGVyIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyXG4gICAgICAgIHZhciBkZXB0aENvbXBhcmUgPSBob2ZfMS5jdXJyeShmdW5jdGlvbiAoZGVwdGhGbiwgcG9zTmVnLCBsZWZ0LCByaWdodCkgeyByZXR1cm4gcG9zTmVnICogKGRlcHRoRm4obGVmdCkgLSBkZXB0aEZuKHJpZ2h0KSk7IH0pO1xuICAgICAgICB2YXIgbWF0Y2hpbmdDb25maWdQYWlyID0gZnVuY3Rpb24gKHVpVmlldykge1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nQ29uZmlncyA9IF90aGlzLl92aWV3Q29uZmlncy5maWx0ZXIoVmlld1NlcnZpY2UubWF0Y2hlcyh1aVZpZXdzQnlGcW4sIHVpVmlldykpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nQ29uZmlncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBPSy4gIENoaWxkIHN0YXRlcyBjYW4gdGFyZ2V0IGEgdWktdmlldyB0aGF0IHRoZSBwYXJlbnQgc3RhdGUgYWxzbyB0YXJnZXRzICh0aGUgY2hpbGQgd2lucylcbiAgICAgICAgICAgICAgICAvLyBTb3J0IGJ5IGRlcHRoIGFuZCByZXR1cm4gdGhlIG1hdGNoIGZyb20gdGhlIGRlZXBlc3QgY2hpbGRcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgTXVsdGlwbGUgbWF0Y2hpbmcgdmlldyBjb25maWdzIGZvciAke3VpVmlldy5mcW59YCwgbWF0Y2hpbmdDb25maWdzKTtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ0NvbmZpZ3Muc29ydChkZXB0aENvbXBhcmUodmlld0NvbmZpZ0RlcHRoLCAtMSkpOyAvLyBkZXNjZW5kaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB1aVZpZXc6IHVpVmlldywgdmlld0NvbmZpZzogbWF0Y2hpbmdDb25maWdzWzBdIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb25maWd1cmVVSVZpZXcgPSBmdW5jdGlvbiAodHVwbGUpIHtcbiAgICAgICAgICAgIC8vIElmIGEgcGFyZW50IHVpLXZpZXcgaXMgcmVjb25maWd1cmVkLCBpdCBjb3VsZCBkZXN0cm95IGNoaWxkIHVpLXZpZXdzLlxuICAgICAgICAgICAgLy8gQmVmb3JlIGNvbmZpZ3VyaW5nIGEgY2hpbGQgdWktdmlldywgbWFrZSBzdXJlIGl0J3Mgc3RpbGwgaW4gdGhlIGFjdGl2ZSB1aVZpZXdzIGFycmF5LlxuICAgICAgICAgICAgaWYgKF90aGlzLl91aVZpZXdzLmluZGV4T2YodHVwbGUudWlWaWV3KSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgdHVwbGUudWlWaWV3LmNvbmZpZ1VwZGF0ZWQodHVwbGUudmlld0NvbmZpZyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNvcnQgdmlld3MgYnkgRlFOIGFuZCBzdGF0ZSBkZXB0aC4gUHJvY2VzcyB1aXZpZXdzIG5lYXJlc3QgdGhlIHJvb3QgZmlyc3QuXG4gICAgICAgIHZhciB1aVZpZXdUdXBsZXMgPSB0aGlzLl91aVZpZXdzLnNvcnQoZGVwdGhDb21wYXJlKHVpVmlld0RlcHRoLCAxKSkubWFwKG1hdGNoaW5nQ29uZmlnUGFpcik7XG4gICAgICAgIHZhciBtYXRjaGVkVmlld0NvbmZpZ3MgPSB1aVZpZXdUdXBsZXMubWFwKGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gdHVwbGUudmlld0NvbmZpZzsgfSk7XG4gICAgICAgIHZhciB1bm1hdGNoZWRDb25maWdUdXBsZXMgPSB0aGlzLl92aWV3Q29uZmlnc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoY29uZmlnKSB7IHJldHVybiAhY29tbW9uXzEuaW5BcnJheShtYXRjaGVkVmlld0NvbmZpZ3MsIGNvbmZpZyk7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7IHJldHVybiAoeyB1aVZpZXc6IHVuZGVmaW5lZCwgdmlld0NvbmZpZzogdmlld0NvbmZpZyB9KTsgfSk7XG4gICAgICAgIHVpVmlld1R1cGxlcy5mb3JFYWNoKGNvbmZpZ3VyZVVJVmlldyk7XG4gICAgICAgIHZhciBhbGxUdXBsZXMgPSB1aVZpZXdUdXBsZXMuY29uY2F0KHVubWF0Y2hlZENvbmZpZ1R1cGxlcyk7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IoYWxsVHVwbGVzKTsgfSk7XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U3luYyhhbGxUdXBsZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgYHVpLXZpZXdgIGNvbXBvbmVudFxuICAgICAqXG4gICAgICogV2hlbiBhIGB1aS12aWV3YCBjb21wb25lbnQgaXMgY3JlYXRlZCwgaXQgdXNlcyB0aGlzIG1ldGhvZCB0byByZWdpc3RlciBpdHNlbGYuXG4gICAgICogQWZ0ZXIgcmVnaXN0cmF0aW9uIHRoZSBbW3N5bmNdXSBtZXRob2QgaXMgdXNlZCB0byBlbnN1cmUgYWxsIGB1aS12aWV3YCBhcmUgY29uZmlndXJlZCB3aXRoIHRoZSBwcm9wZXIgW1tWaWV3Q29uZmlnXV0uXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGUgYHVpLXZpZXdgIGNvbXBvbmVudCB1c2VzIHRoZSBgVmlld0NvbmZpZ2AgdG8gZGV0ZXJtaW5lIHdoYXQgdmlldyBzaG91bGQgYmUgbG9hZGVkIGluc2lkZSB0aGUgYHVpLXZpZXdgLFxuICAgICAqIGFuZCB3aGF0IHRoZSB2aWV3J3Mgc3RhdGUgY29udGV4dCBpcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgYGRlcmVnaXN0ZXJVSVZpZXdgLlxuICAgICAqICAgICAgIEEgYHVpLXZpZXdgIHNob3VsZCBoYW5nIG9uIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgYHJlZ2lzdGVyVUlWaWV3YCBhbmQgaW52b2tlIGl0IHRvIGRlcmVnaXN0ZXIgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVpVmlldyBUaGUgbWV0YWRhdGEgZm9yIGEgVUlWaWV3XG4gICAgICogQHJldHVybiBhIGRlLXJlZ2lzdHJhdGlvbiBmdW5jdGlvbiB1c2VkIHdoZW4gdGhlIHZpZXcgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5yZWdpc3RlclVJVmlldyA9IGZ1bmN0aW9uICh1aVZpZXcpIHtcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlVUlWaWV3RXZlbnQoJy0+IFJlZ2lzdGVyaW5nJywgdWlWaWV3KTtcbiAgICAgICAgdmFyIHVpVmlld3MgPSB0aGlzLl91aVZpZXdzO1xuICAgICAgICB2YXIgZnFuQW5kVHlwZU1hdGNoZXMgPSBmdW5jdGlvbiAodWl2KSB7IHJldHVybiB1aXYuZnFuID09PSB1aVZpZXcuZnFuICYmIHVpdi4kdHlwZSA9PT0gdWlWaWV3LiR0eXBlOyB9O1xuICAgICAgICBpZiAodWlWaWV3cy5maWx0ZXIoZnFuQW5kVHlwZU1hdGNoZXMpLmxlbmd0aClcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZVVJVmlld0V2ZW50KCchISEhIGR1cGxpY2F0ZSB1aVZpZXcgbmFtZWQ6JywgdWlWaWV3KTtcbiAgICAgICAgdWlWaWV3cy5wdXNoKHVpVmlldyk7XG4gICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHVpVmlld3MuaW5kZXhPZih1aVZpZXcpO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudCgnVHJpZWQgcmVtb3Zpbmcgbm9uLXJlZ2lzdGVyZWQgdWlWaWV3JywgdWlWaWV3KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudCgnPC0gRGVyZWdpc3RlcmluZycsIHVpVmlldyk7XG4gICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKHVpVmlld3MpKHVpVmlldyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZpZXdzIGN1cnJlbnRseSBhdmFpbGFibGUgb24gdGhlIHBhZ2UsIGJ5IGZ1bGx5LXF1YWxpZmllZCBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgZnVsbHktcXVhbGlmaWVkIHZpZXcgbmFtZXMuXG4gICAgICovXG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLmF2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpVmlld3MubWFwKGhvZl8xLnByb3AoJ2ZxbicpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygdmlld3Mgb24gdGhlIHBhZ2UgY29udGFpbmluZyBsb2FkZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGZ1bGx5LXF1YWxpZmllZCB2aWV3IG5hbWVzLlxuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91aVZpZXdzLmZpbHRlcihob2ZfMS5wcm9wKCckY29uZmlnJykpLm1hcChob2ZfMS5wcm9wKCduYW1lJykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSB1aS12aWV3IGFuZCBhIFZpZXdDb25maWcsIGRldGVybWluZXMgaWYgdGhleSBcIm1hdGNoXCIuXG4gICAgICpcbiAgICAgKiBBIHVpLXZpZXcgaGFzIGEgZnVsbHkgcXVhbGlmaWVkIG5hbWUgKGZxbikgYW5kIGEgY29udGV4dCBvYmplY3QuICBUaGUgZnFuIGlzIGJ1aWx0IGZyb20gaXRzIG92ZXJhbGwgbG9jYXRpb24gaW5cbiAgICAgKiB0aGUgRE9NLCBkZXNjcmliaW5nIGl0cyBuZXN0aW5nIHJlbGF0aW9uc2hpcCB0byBhbnkgcGFyZW50IHVpLXZpZXcgdGFncyBpdCBpcyBuZXN0ZWQgaW5zaWRlIG9mLlxuICAgICAqXG4gICAgICogQSBWaWV3Q29uZmlnIGhhcyBhIHRhcmdldCB1aS12aWV3IG5hbWUgYW5kIGEgY29udGV4dCBhbmNob3IuICBUaGUgdWktdmlldyBuYW1lIGNhbiBiZSBhIHNpbXBsZSBuYW1lLCBvclxuICAgICAqIGNhbiBiZSBhIHNlZ21lbnRlZCB1aS12aWV3IHBhdGgsIGRlc2NyaWJpbmcgYSBwb3J0aW9uIG9mIGEgdWktdmlldyBmcW4uXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciBmb3IgYSB1aS12aWV3IHRvIG1hdGNoIFZpZXdDb25maWcsIHVpLXZpZXcncyAkdHlwZSBtdXN0IG1hdGNoIHRoZSBWaWV3Q29uZmlnJ3MgJHR5cGVcbiAgICAgKlxuICAgICAqIElmIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IHVpLXZpZXcgbmFtZSBpcyBhIHNpbXBsZSBuYW1lIChubyBkb3RzKSwgdGhlbiBhIHVpLXZpZXcgbWF0Y2hlcyBpZjpcbiAgICAgKiAtIHRoZSB1aS12aWV3J3MgbmFtZSBtYXRjaGVzIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWVcbiAgICAgKiAtIHRoZSB1aS12aWV3J3MgY29udGV4dCBtYXRjaGVzIHRoZSBWaWV3Q29uZmlnJ3MgYW5jaG9yXG4gICAgICpcbiAgICAgKiBJZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCB1aS12aWV3IG5hbWUgaXMgYSBzZWdtZW50ZWQgbmFtZSAod2l0aCBkb3RzKSwgdGhlbiBhIHVpLXZpZXcgbWF0Y2hlcyBpZjpcbiAgICAgKiAtIFRoZXJlIGV4aXN0cyBhIHBhcmVudCB1aS12aWV3IHdoZXJlOlxuICAgICAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgbmFtZSBtYXRjaGVzIHRoZSBmaXJzdCBzZWdtZW50IChpbmRleCAwKSBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXG4gICAgICogICAgLSB0aGUgcGFyZW50IHVpLXZpZXcncyBjb250ZXh0IG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyBhbmNob3JcbiAgICAgKiAtIEFuZCB0aGUgcmVtYWluaW5nIHNlZ21lbnRzIChpbmRleCAxLi5uKSBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lIG1hdGNoIHRoZSB0YWlsIG9mIHRoZSB1aS12aWV3J3MgZnFuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogRE9NOlxuICAgICAqIDx1aS12aWV3PiAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgcm9vdCBjb250ZXh0IChuYW1lOiBcIlwiKSAtLT5cbiAgICAgKiAgIDx1aS12aWV3IG5hbWU9XCJmb29cIj4gICAgICAgICAgICAgICAgPCEtLSBjcmVhdGVkIGluIHRoZSBjb250ZXh0IG5hbWVkOiBcIkFcIiAgICAgIC0tPlxuICAgICAqICAgICA8dWktdmlldz4gICAgICAgICAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgY29udGV4dCBuYW1lZDogXCJBLkJcIiAgICAtLT5cbiAgICAgKiAgICAgICA8dWktdmlldyBuYW1lPVwiYmFyXCI+ICAgICAgICAgICAgPCEtLSBjcmVhdGVkIGluIHRoZSBjb250ZXh0IG5hbWVkOiBcIkEuQi5DXCIgIC0tPlxuICAgICAqICAgICAgIDwvdWktdmlldz5cbiAgICAgKiAgICAgPC91aS12aWV3PlxuICAgICAqICAgPC91aS12aWV3PlxuICAgICAqIDwvdWktdmlldz5cbiAgICAgKlxuICAgICAqIHVpVmlld3M6IFtcbiAgICAgKiAgeyBmcW46IFwiJGRlZmF1bHRcIiwgICAgICAgICAgICAgICAgICBjcmVhdGlvbkNvbnRleHQ6IHsgbmFtZTogXCJcIiB9IH0sXG4gICAgICogIHsgZnFuOiBcIiRkZWZhdWx0LmZvb1wiLCAgICAgICAgICAgICAgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiQVwiIH0gfSxcbiAgICAgKiAgeyBmcW46IFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0XCIsICAgICBjcmVhdGlvbkNvbnRleHQ6IHsgbmFtZTogXCJBLkJcIiB9IH1cbiAgICAgKiAgeyBmcW46IFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiLCBjcmVhdGlvbkNvbnRleHQ6IHsgbmFtZTogXCJBLkIuQ1wiIH0gfVxuICAgICAqIF1cbiAgICAgKlxuICAgICAqIFRoZXNlIGZvdXIgdmlldyBjb25maWdzIGFsbCBtYXRjaCB0aGUgdWktdmlldyB3aXRoIHRoZSBmcW46IFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiOlxuICAgICAqXG4gICAgICogLSBWaWV3Q29uZmlnMTogeyB1aVZpZXdOYW1lOiBcImJhclwiLCAgICAgICAgICAgICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvcjogXCJBLkIuQ1wiIH1cbiAgICAgKiAtIFZpZXdDb25maWcyOiB7IHVpVmlld05hbWU6IFwiJGRlZmF1bHQuYmFyXCIsICAgICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIkEuQlwiIH1cbiAgICAgKiAtIFZpZXdDb25maWczOiB7IHVpVmlld05hbWU6IFwiZm9vLiRkZWZhdWx0LmJhclwiLCAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIkFcIiB9XG4gICAgICogLSBWaWV3Q29uZmlnNDogeyB1aVZpZXdOYW1lOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdC5iYXJcIiwgdWlWaWV3Q29udGV4dEFuY2hvcjogXCJcIiB9XG4gICAgICpcbiAgICAgKiBVc2luZyBWaWV3Q29uZmlnMyBhcyBhbiBleGFtcGxlLCBpdCBtYXRjaGVzIHRoZSB1aS12aWV3IHdpdGggZnFuIFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiIGJlY2F1c2U6XG4gICAgICogLSBUaGUgVmlld0NvbmZpZydzIHNlZ21lbnRlZCB0YXJnZXQgbmFtZSBpczogWyBcImZvb1wiLCBcIiRkZWZhdWx0XCIsIFwiYmFyXCIgXVxuICAgICAqIC0gVGhlcmUgZXhpc3RzIGEgcGFyZW50IHVpLXZpZXcgKHdoaWNoIGhhcyBmcW46IFwiJGRlZmF1bHQuZm9vXCIpIHdoZXJlOlxuICAgICAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgbmFtZSBcImZvb1wiIG1hdGNoZXMgdGhlIGZpcnN0IHNlZ21lbnQgXCJmb29cIiBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXG4gICAgICogICAgLSB0aGUgcGFyZW50IHVpLXZpZXcncyBjb250ZXh0IFwiQVwiIG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyBhbmNob3IgY29udGV4dCBcIkFcIlxuICAgICAqIC0gQW5kIHRoZSByZW1haW5pbmcgc2VnbWVudHMgWyBcIiRkZWZhdWx0XCIsIFwiYmFyXCIgXS5qb2luKFwiLlwiXyBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lIG1hdGNoXG4gICAgICogICB0aGUgdGFpbCBvZiB0aGUgdWktdmlldydzIGZxbiBcImRlZmF1bHQuYmFyXCJcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLm1hdGNoZXMgPSBmdW5jdGlvbiAodWlWaWV3c0J5RnFuLCB1aVZpZXcpIHsgcmV0dXJuIGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7XG4gICAgICAgIC8vIERvbid0IHN1cHBseSBhbiBuZzEgdWktdmlldyB3aXRoIGFuIG5nMiBWaWV3Q29uZmlnLCBldGNcbiAgICAgICAgaWYgKHVpVmlldy4kdHlwZSAhPT0gdmlld0NvbmZpZy52aWV3RGVjbC4kdHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gU3BsaXQgbmFtZXMgYXBhcnQgZnJvbSBib3RoIHZpZXdDb25maWcgYW5kIHVpVmlldyBpbnRvIHNlZ21lbnRzXG4gICAgICAgIHZhciB2YyA9IHZpZXdDb25maWcudmlld0RlY2w7XG4gICAgICAgIHZhciB2Y1NlZ21lbnRzID0gdmMuJHVpVmlld05hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIHVpdlNlZ21lbnRzID0gdWlWaWV3LmZxbi5zcGxpdCgnLicpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdGFpbHMgb2YgdGhlIHNlZ21lbnQgYXJyYXlzIG1hdGNoLiBleCwgdGhlc2UgYXJyYXlzJyB0YWlscyBtYXRjaDpcbiAgICAgICAgLy8gdmM6IFtcImZvb1wiLCBcImJhclwiXSwgdWl2IGZxbjogW1wiJGRlZmF1bHRcIiwgXCJmb29cIiwgXCJiYXJcIl1cbiAgICAgICAgaWYgKCFjb21tb25fMS5lcXVhbHModmNTZWdtZW50cywgdWl2U2VnbWVudHMuc2xpY2UoMCAtIHZjU2VnbWVudHMubGVuZ3RoKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIE5vdyBjaGVjayBpZiB0aGUgZnFuIGVuZGluZyBhdCB0aGUgZmlyc3Qgc2VnbWVudCBvZiB0aGUgdmlld0NvbmZpZyBtYXRjaGVzIHRoZSBjb250ZXh0OlxuICAgICAgICAvLyBbXCIkZGVmYXVsdFwiLCBcImZvb1wiXS5qb2luKFwiLlwiKSA9PSBcIiRkZWZhdWx0LmZvb1wiLCBkb2VzIHRoZSB1aS12aWV3ICRkZWZhdWx0LmZvbyBjb250ZXh0IG1hdGNoP1xuICAgICAgICB2YXIgbmVnT2Zmc2V0ID0gMSAtIHZjU2VnbWVudHMubGVuZ3RoIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGZxblRvRmlyc3RTZWdtZW50ID0gdWl2U2VnbWVudHMuc2xpY2UoMCwgbmVnT2Zmc2V0KS5qb2luKCcuJyk7XG4gICAgICAgIHZhciB1aVZpZXdDb250ZXh0ID0gdWlWaWV3c0J5RnFuW2ZxblRvRmlyc3RTZWdtZW50XS5jcmVhdGlvbkNvbnRleHQ7XG4gICAgICAgIHJldHVybiB2Yy4kdWlWaWV3Q29udGV4dEFuY2hvciA9PT0gKHVpVmlld0NvbnRleHQgJiYgdWlWaWV3Q29udGV4dC5uYW1lKTtcbiAgICB9OyB9O1xuICAgIHJldHVybiBWaWV3U2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlZpZXdTZXJ2aWNlID0gVmlld1NlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhckpTIHYxLjYuMTBcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikgeyd1c2Ugc3RyaWN0JztcblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgIEFueSBjb21taXRzIHRvIHRoaXMgZmlsZSBzaG91bGQgYmUgcmV2aWV3ZWQgd2l0aCBzZWN1cml0eSBpbiBtaW5kLiAgKlxuICogICBDaGFuZ2VzIHRvIHRoaXMgZmlsZSBjYW4gcG90ZW50aWFsbHkgY3JlYXRlIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcy4gKlxuICogICAgICAgICAgQW4gYXBwcm92YWwgZnJvbSAyIENvcmUgbWVtYmVycyB3aXRoIGhpc3Rvcnkgb2YgbW9kaWZ5aW5nICAgICAgKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBmaWxlIGlzIHJlcXVpcmVkLiAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogIERvZXMgdGhlIGNoYW5nZSBzb21laG93IGFsbG93IGZvciBhcmJpdHJhcnkgamF2YXNjcmlwdCB0byBiZSBleGVjdXRlZD8gKlxuICogICAgT3IgYWxsb3dzIGZvciBzb21lb25lIHRvIGNoYW5nZSB0aGUgcHJvdG90eXBlIG9mIGJ1aWx0LWluIG9iamVjdHM/ICAgKlxuICogICAgIE9yIGdpdmVzIHVuZGVzaXJlZCBhY2Nlc3MgdG8gdmFyaWFibGVzIGxpa2VzIGRvY3VtZW50IG9yIHdpbmRvdz8gICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxudmFyICRzYW5pdGl6ZU1pbkVyciA9IGFuZ3VsYXIuJCRtaW5FcnIoJyRzYW5pdGl6ZScpO1xudmFyIGJpbmQ7XG52YXIgZXh0ZW5kO1xudmFyIGZvckVhY2g7XG52YXIgaXNBcnJheTtcbnZhciBpc0RlZmluZWQ7XG52YXIgbG93ZXJjYXNlO1xudmFyIG5vb3A7XG52YXIgbm9kZUNvbnRhaW5zO1xudmFyIGh0bWxQYXJzZXI7XG52YXIgaHRtbFNhbml0aXplV3JpdGVyO1xuXG4vKipcbiAqIEBuZ2RvYyBtb2R1bGVcbiAqIEBuYW1lIG5nU2FuaXRpemVcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFRoZSBgbmdTYW5pdGl6ZWAgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gc2FuaXRpemUgSFRNTC5cbiAqXG4gKiBTZWUge0BsaW5rIG5nU2FuaXRpemUuJHNhbml0aXplIGAkc2FuaXRpemVgfSBmb3IgdXNhZ2UuXG4gKi9cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJHNhbml0aXplXG4gKiBAa2luZCBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogICBTYW5pdGl6ZXMgYW4gaHRtbCBzdHJpbmcgYnkgc3RyaXBwaW5nIGFsbCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgdG9rZW5zLlxuICpcbiAqICAgVGhlIGlucHV0IGlzIHNhbml0aXplZCBieSBwYXJzaW5nIHRoZSBIVE1MIGludG8gdG9rZW5zLiBBbGwgc2FmZSB0b2tlbnMgKGZyb20gYSB3aGl0ZWxpc3QpIGFyZVxuICogICB0aGVuIHNlcmlhbGl6ZWQgYmFjayB0byBwcm9wZXJseSBlc2NhcGVkIGh0bWwgc3RyaW5nLiBUaGlzIG1lYW5zIHRoYXQgbm8gdW5zYWZlIGlucHV0IGNhbiBtYWtlXG4gKiAgIGl0IGludG8gdGhlIHJldHVybmVkIHN0cmluZy5cbiAqXG4gKiAgIFRoZSB3aGl0ZWxpc3QgZm9yIFVSTCBzYW5pdGl6YXRpb24gb2YgYXR0cmlidXRlIHZhbHVlcyBpcyBjb25maWd1cmVkIHVzaW5nIHRoZSBmdW5jdGlvbnNcbiAqICAgYGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0YCBhbmQgYGltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdGAgb2Yge0BsaW5rIG5nLiRjb21waWxlUHJvdmlkZXJcbiAqICAgYCRjb21waWxlUHJvdmlkZXJgfS5cbiAqXG4gKiAgIFRoZSBpbnB1dCBtYXkgYWxzbyBjb250YWluIFNWRyBtYXJrdXAgaWYgdGhpcyBpcyBlbmFibGVkIHZpYSB7QGxpbmsgJHNhbml0aXplUHJvdmlkZXJ9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIEhUTUwgaW5wdXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTYW5pdGl6ZWQgSFRNTC5cbiAqXG4gKiBAZXhhbXBsZVxuICAgPGV4YW1wbGUgbW9kdWxlPVwic2FuaXRpemVFeGFtcGxlXCIgZGVwcz1cImFuZ3VsYXItc2FuaXRpemUuanNcIiBuYW1lPVwic2FuaXRpemUtc2VydmljZVwiPlxuICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgPHNjcmlwdD5cbiAgICAgICAgIGFuZ3VsYXIubW9kdWxlKCdzYW5pdGl6ZUV4YW1wbGUnLCBbJ25nU2FuaXRpemUnXSlcbiAgICAgICAgICAgLmNvbnRyb2xsZXIoJ0V4YW1wbGVDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJHNjZScsIGZ1bmN0aW9uKCRzY29wZSwgJHNjZSkge1xuICAgICAgICAgICAgICRzY29wZS5zbmlwcGV0ID1cbiAgICAgICAgICAgICAgICc8cCBzdHlsZT1cImNvbG9yOmJsdWVcIj5hbiBodG1sXFxuJyArXG4gICAgICAgICAgICAgICAnPGVtIG9ubW91c2VvdmVyPVwidGhpcy50ZXh0Q29udGVudD1cXCdQV04zRCFcXCdcIj5jbGljayBoZXJlPC9lbT5cXG4nICtcbiAgICAgICAgICAgICAgICdzbmlwcGV0PC9wPic7XG4gICAgICAgICAgICAgJHNjb3BlLmRlbGliZXJhdGVseVRydXN0RGFuZ2Vyb3VzU25pcHBldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc0h0bWwoJHNjb3BlLnNuaXBwZXQpO1xuICAgICAgICAgICAgIH07XG4gICAgICAgICAgIH1dKTtcbiAgICAgPC9zY3JpcHQ+XG4gICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkV4YW1wbGVDb250cm9sbGVyXCI+XG4gICAgICAgIFNuaXBwZXQ6IDx0ZXh0YXJlYSBuZy1tb2RlbD1cInNuaXBwZXRcIiBjb2xzPVwiNjBcIiByb3dzPVwiM1wiPjwvdGV4dGFyZWE+XG4gICAgICAgPHRhYmxlPlxuICAgICAgICAgPHRyPlxuICAgICAgICAgICA8dGQ+RGlyZWN0aXZlPC90ZD5cbiAgICAgICAgICAgPHRkPkhvdzwvdGQ+XG4gICAgICAgICAgIDx0ZD5Tb3VyY2U8L3RkPlxuICAgICAgICAgICA8dGQ+UmVuZGVyZWQ8L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImJpbmQtaHRtbC13aXRoLXNhbml0aXplXCI+XG4gICAgICAgICAgIDx0ZD5uZy1iaW5kLWh0bWw8L3RkPlxuICAgICAgICAgICA8dGQ+QXV0b21hdGljYWxseSB1c2VzICRzYW5pdGl6ZTwvdGQ+XG4gICAgICAgICAgIDx0ZD48cHJlPiZsdDtkaXYgbmctYmluZC1odG1sPVwic25pcHBldFwiJmd0Ozxici8+Jmx0Oy9kaXYmZ3Q7PC9wcmU+PC90ZD5cbiAgICAgICAgICAgPHRkPjxkaXYgbmctYmluZC1odG1sPVwic25pcHBldFwiPjwvZGl2PjwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwiYmluZC1odG1sLXdpdGgtdHJ1c3RcIj5cbiAgICAgICAgICAgPHRkPm5nLWJpbmQtaHRtbDwvdGQ+XG4gICAgICAgICAgIDx0ZD5CeXBhc3MgJHNhbml0aXplIGJ5IGV4cGxpY2l0bHkgdHJ1c3RpbmcgdGhlIGRhbmdlcm91cyB2YWx1ZTwvdGQ+XG4gICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgPHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cImRlbGliZXJhdGVseVRydXN0RGFuZ2Vyb3VzU25pcHBldCgpXCImZ3Q7XG4mbHQ7L2RpdiZndDs8L3ByZT5cbiAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgPHRkPjxkaXYgbmctYmluZC1odG1sPVwiZGVsaWJlcmF0ZWx5VHJ1c3REYW5nZXJvdXNTbmlwcGV0KClcIj48L2Rpdj48L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImJpbmQtZGVmYXVsdFwiPlxuICAgICAgICAgICA8dGQ+bmctYmluZDwvdGQ+XG4gICAgICAgICAgIDx0ZD5BdXRvbWF0aWNhbGx5IGVzY2FwZXM8L3RkPlxuICAgICAgICAgICA8dGQ+PHByZT4mbHQ7ZGl2IG5nLWJpbmQ9XCJzbmlwcGV0XCImZ3Q7PGJyLz4mbHQ7L2RpdiZndDs8L3ByZT48L3RkPlxuICAgICAgICAgICA8dGQ+PGRpdiBuZy1iaW5kPVwic25pcHBldFwiPjwvZGl2PjwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgIDwvdGFibGU+XG4gICAgICAgPC9kaXY+XG4gICA8L2ZpbGU+XG4gICA8ZmlsZSBuYW1lPVwicHJvdHJhY3Rvci5qc1wiIHR5cGU9XCJwcm90cmFjdG9yXCI+XG4gICAgIGl0KCdzaG91bGQgc2FuaXRpemUgdGhlIGh0bWwgc25pcHBldCBieSBkZWZhdWx0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1odG1sLXdpdGgtc2FuaXRpemUgZGl2JykpLmdldEF0dHJpYnV0ZSgnaW5uZXJIVE1MJykpLlxuICAgICAgICAgdG9CZSgnPHA+YW4gaHRtbFxcbjxlbT5jbGljayBoZXJlPC9lbT5cXG5zbmlwcGV0PC9wPicpO1xuICAgICB9KTtcblxuICAgICBpdCgnc2hvdWxkIGlubGluZSByYXcgc25pcHBldCBpZiBib3VuZCB0byBhIHRydXN0ZWQgdmFsdWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC10cnVzdCBkaXYnKSkuZ2V0QXR0cmlidXRlKCdpbm5lckhUTUwnKSkuXG4gICAgICAgICB0b0JlKFwiPHAgc3R5bGU9XFxcImNvbG9yOmJsdWVcXFwiPmFuIGh0bWxcXG5cIiArXG4gICAgICAgICAgICAgIFwiPGVtIG9ubW91c2VvdmVyPVxcXCJ0aGlzLnRleHRDb250ZW50PSdQV04zRCEnXFxcIj5jbGljayBoZXJlPC9lbT5cXG5cIiArXG4gICAgICAgICAgICAgIFwic25pcHBldDwvcD5cIik7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgZXNjYXBlIHNuaXBwZXQgd2l0aG91dCBhbnkgZmlsdGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1kZWZhdWx0IGRpdicpKS5nZXRBdHRyaWJ1dGUoJ2lubmVySFRNTCcpKS5cbiAgICAgICAgIHRvQmUoXCImbHQ7cCBzdHlsZT1cXFwiY29sb3I6Ymx1ZVxcXCImZ3Q7YW4gaHRtbFxcblwiICtcbiAgICAgICAgICAgICAgXCImbHQ7ZW0gb25tb3VzZW92ZXI9XFxcInRoaXMudGV4dENvbnRlbnQ9J1BXTjNEISdcXFwiJmd0O2NsaWNrIGhlcmUmbHQ7L2VtJmd0O1xcblwiICtcbiAgICAgICAgICAgICAgXCJzbmlwcGV0Jmx0Oy9wJmd0O1wiKTtcbiAgICAgfSk7XG5cbiAgICAgaXQoJ3Nob3VsZCB1cGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICBlbGVtZW50KGJ5Lm1vZGVsKCdzbmlwcGV0JykpLmNsZWFyKCk7XG4gICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5zZW5kS2V5cygnbmV3IDxiIG9uY2xpY2s9XCJhbGVydCgxKVwiPnRleHQ8L2I+Jyk7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1odG1sLXdpdGgtc2FuaXRpemUgZGl2JykpLmdldEF0dHJpYnV0ZSgnaW5uZXJIVE1MJykpLlxuICAgICAgICAgdG9CZSgnbmV3IDxiPnRleHQ8L2I+Jyk7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1odG1sLXdpdGgtdHJ1c3QgZGl2JykpLmdldEF0dHJpYnV0ZSgnaW5uZXJIVE1MJykpLnRvQmUoXG4gICAgICAgICAnbmV3IDxiIG9uY2xpY2s9XCJhbGVydCgxKVwiPnRleHQ8L2I+Jyk7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1kZWZhdWx0IGRpdicpKS5nZXRBdHRyaWJ1dGUoJ2lubmVySFRNTCcpKS50b0JlKFxuICAgICAgICAgXCJuZXcgJmx0O2Igb25jbGljaz1cXFwiYWxlcnQoMSlcXFwiJmd0O3RleHQmbHQ7L2ImZ3Q7XCIpO1xuICAgICB9KTtcbiAgIDwvZmlsZT5cbiAgIDwvZXhhbXBsZT5cbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIHByb3ZpZGVyXG4gKiBAbmFtZSAkc2FuaXRpemVQcm92aWRlclxuICogQHRoaXNcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYW5kIGNvbmZpZ3VyZXMge0BsaW5rICRzYW5pdGl6ZX0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uICRTYW5pdGl6ZVByb3ZpZGVyKCkge1xuICB2YXIgaGFzQmVlbkluc3RhbnRpYXRlZCA9IGZhbHNlO1xuICB2YXIgc3ZnRW5hYmxlZCA9IGZhbHNlO1xuXG4gIHRoaXMuJGdldCA9IFsnJCRzYW5pdGl6ZVVyaScsIGZ1bmN0aW9uKCQkc2FuaXRpemVVcmkpIHtcbiAgICBoYXNCZWVuSW5zdGFudGlhdGVkID0gdHJ1ZTtcbiAgICBpZiAoc3ZnRW5hYmxlZCkge1xuICAgICAgZXh0ZW5kKHZhbGlkRWxlbWVudHMsIHN2Z0VsZW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgIHZhciBidWYgPSBbXTtcbiAgICAgIGh0bWxQYXJzZXIoaHRtbCwgaHRtbFNhbml0aXplV3JpdGVyKGJ1ZiwgZnVuY3Rpb24odXJpLCBpc0ltYWdlKSB7XG4gICAgICAgIHJldHVybiAhL151bnNhZmU6Ly50ZXN0KCQkc2FuaXRpemVVcmkodXJpLCBpc0ltYWdlKSk7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gYnVmLmpvaW4oJycpO1xuICAgIH07XG4gIH1dO1xuXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBtZXRob2RcbiAgICogQG5hbWUgJHNhbml0aXplUHJvdmlkZXIjZW5hYmxlU3ZnXG4gICAqIEBraW5kIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBFbmFibGVzIGEgc3Vic2V0IG9mIHN2ZyB0byBiZSBzdXBwb3J0ZWQgYnkgdGhlIHNhbml0aXplci5cbiAgICpcbiAgICogPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LXdhcm5pbmdcIj5cbiAgICogICA8cD5CeSBlbmFibGluZyB0aGlzIHNldHRpbmcgd2l0aG91dCB0YWtpbmcgb3RoZXIgcHJlY2F1dGlvbnMsIHlvdSBtaWdodCBleHBvc2UgeW91clxuICAgKiAgIGFwcGxpY2F0aW9uIHRvIGNsaWNrLWhpamFja2luZyBhdHRhY2tzLiBJbiB0aGVzZSBhdHRhY2tzLCBzYW5pdGl6ZWQgc3ZnIGVsZW1lbnRzIGNvdWxkIGJlIHBvc2l0aW9uZWRcbiAgICogICBvdXRzaWRlIG9mIHRoZSBjb250YWluaW5nIGVsZW1lbnQgYW5kIGJlIHJlbmRlcmVkIG92ZXIgb3RoZXIgZWxlbWVudHMgb24gdGhlIHBhZ2UgKGUuZy4gYSBsb2dpblxuICAgKiAgIGxpbmspLiBTdWNoIGJlaGF2aW9yIGNhbiB0aGVuIHJlc3VsdCBpbiBwaGlzaGluZyBpbmNpZGVudHMuPC9wPlxuICAgKlxuICAgKiAgIDxwPlRvIHByb3RlY3QgYWdhaW5zdCB0aGVzZSwgZXhwbGljaXRseSBzZXR1cCBgb3ZlcmZsb3c6IGhpZGRlbmAgY3NzIHJ1bGUgZm9yIGFsbCBwb3RlbnRpYWwgc3ZnXG4gICAqICAgdGFncyB3aXRoaW4gdGhlIHNhbml0aXplZCBjb250ZW50OjwvcD5cbiAgICpcbiAgICogICA8YnI+XG4gICAqXG4gICAqICAgPHByZT48Y29kZT5cbiAgICogICAucm9vdE9mVGhlSW5jbHVkZWRDb250ZW50IHN2ZyB7XG4gICAqICAgICBvdmVyZmxvdzogaGlkZGVuICFpbXBvcnRhbnQ7XG4gICAqICAgfVxuICAgKiAgIDwvY29kZT48L3ByZT5cbiAgICogPC9kaXY+XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZsYWcgRW5hYmxlIG9yIGRpc2FibGUgU1ZHIHN1cHBvcnQgaW4gdGhlIHNhbml0aXplci5cbiAgICogQHJldHVybnMge2Jvb2xlYW58JHNhbml0aXplUHJvdmlkZXJ9IFJldHVybnMgdGhlIGN1cnJlbnRseSBjb25maWd1cmVkIHZhbHVlIGlmIGNhbGxlZFxuICAgKiAgICB3aXRob3V0IGFuIGFyZ3VtZW50IG9yIHNlbGYgZm9yIGNoYWluaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIHRoaXMuZW5hYmxlU3ZnID0gZnVuY3Rpb24oZW5hYmxlU3ZnKSB7XG4gICAgaWYgKGlzRGVmaW5lZChlbmFibGVTdmcpKSB7XG4gICAgICBzdmdFbmFibGVkID0gZW5hYmxlU3ZnO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdmdFbmFibGVkO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAbmdkb2MgbWV0aG9kXG4gICAqIEBuYW1lICRzYW5pdGl6ZVByb3ZpZGVyI2FkZFZhbGlkRWxlbWVudHNcbiAgICogQGtpbmQgZnVuY3Rpb25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEV4dGVuZHMgdGhlIGJ1aWx0LWluIGxpc3RzIG9mIHZhbGlkIEhUTUwvU1ZHIGVsZW1lbnRzLCBpLmUuIGVsZW1lbnRzIHRoYXQgYXJlIGNvbnNpZGVyZWQgc2FmZVxuICAgKiBhbmQgYXJlIG5vdCBzdHJpcHBlZCBvZmYgZHVyaW5nIHNhbml0aXphdGlvbi4gWW91IGNhbiBleHRlbmQgdGhlIGZvbGxvd2luZyBsaXN0cyBvZiBlbGVtZW50czpcbiAgICpcbiAgICogLSBgaHRtbEVsZW1lbnRzYDogQSBsaXN0IG9mIGVsZW1lbnRzICh0YWcgbmFtZXMpIHRvIGV4dGVuZCB0aGUgY3VycmVudCBsaXN0IG9mIHNhZmUgSFRNTFxuICAgKiAgIGVsZW1lbnRzLiBIVE1MIGVsZW1lbnRzIGNvbnNpZGVyZWQgc2FmZSB3aWxsIG5vdCBiZSByZW1vdmVkIGR1cmluZyBzYW5pdGl6YXRpb24uIEFsbCBvdGhlclxuICAgKiAgIGVsZW1lbnRzIHdpbGwgYmUgc3RyaXBwZWQgb2ZmLlxuICAgKlxuICAgKiAtIGBodG1sVm9pZEVsZW1lbnRzYDogVGhpcyBpcyBzaW1pbGFyIHRvIGBodG1sRWxlbWVudHNgLCBidXQgbWFya3MgdGhlIGVsZW1lbnRzIGFzXG4gICAqICAgXCJ2b2lkIGVsZW1lbnRzXCIgKHNpbWlsYXIgdG8gSFRNTFxuICAgKiAgIFt2b2lkIGVsZW1lbnRzXShodHRwczovL3Jhd2dpdC5jb20vdzNjL2h0bWwvaHRtbDUuMS0yL3NpbmdsZS1wYWdlLmh0bWwjdm9pZC1lbGVtZW50cykpLiBUaGVzZVxuICAgKiAgIGVsZW1lbnRzIGhhdmUgbm8gZW5kIHRhZyBhbmQgY2Fubm90IGhhdmUgY29udGVudC5cbiAgICpcbiAgICogLSBgc3ZnRWxlbWVudHNgOiBUaGlzIGlzIHNpbWlsYXIgdG8gYGh0bWxFbGVtZW50c2AsIGJ1dCBmb3IgU1ZHIGVsZW1lbnRzLiBUaGlzIGxpc3QgaXMgb25seVxuICAgKiAgIHRha2VuIGludG8gYWNjb3VudCBpZiBTVkcgaXMge0BsaW5rIG5nU2FuaXRpemUuJHNhbml0aXplUHJvdmlkZXIjZW5hYmxlU3ZnIGVuYWJsZWR9IGZvclxuICAgKiAgIGAkc2FuaXRpemVgLlxuICAgKlxuICAgKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtaW5mb1wiPlxuICAgKiAgIFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGR1cmluZyB0aGUge0BsaW5rIGFuZ3VsYXIuTW9kdWxlI2NvbmZpZyBjb25maWd9IHBoYXNlLiBPbmNlIHRoZVxuICAgKiAgIGAkc2FuaXRpemVgIHNlcnZpY2UgaGFzIGJlZW4gaW5zdGFudGlhdGVkLCB0aGlzIG1ldGhvZCBoYXMgbm8gZWZmZWN0LlxuICAgKiA8L2Rpdj5cbiAgICpcbiAgICogPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LXdhcm5pbmdcIj5cbiAgICogICBLZWVwIGluIG1pbmQgdGhhdCBleHRlbmRpbmcgdGhlIGJ1aWx0LWluIGxpc3RzIG9mIGVsZW1lbnRzIG1heSBleHBvc2UgeW91ciBhcHAgdG8gWFNTIG9yXG4gICAqICAgb3RoZXIgdnVsbmVyYWJpbGl0aWVzLiBCZSB2ZXJ5IG1pbmRmdWwgb2YgdGhlIGVsZW1lbnRzIHlvdSBhZGQuXG4gICAqIDwvZGl2PlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz58T2JqZWN0fSBlbGVtZW50cyAtIEEgbGlzdCBvZiB2YWxpZCBIVE1MIGVsZW1lbnRzIG9yIGFuIG9iamVjdCB3aXRoIG9uZSBvclxuICAgKiAgIG1vcmUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIC0gKipodG1sRWxlbWVudHMqKiAtIGB7QXJyYXk8U3RyaW5nPn1gIC0gQSBsaXN0IG9mIGVsZW1lbnRzIHRvIGV4dGVuZCB0aGUgY3VycmVudCBsaXN0IG9mXG4gICAqICAgICBIVE1MIGVsZW1lbnRzLlxuICAgKiAgIC0gKipodG1sVm9pZEVsZW1lbnRzKiogLSBge0FycmF5PFN0cmluZz59YCAtIEEgbGlzdCBvZiBlbGVtZW50cyB0byBleHRlbmQgdGhlIGN1cnJlbnQgbGlzdCBvZlxuICAgKiAgICAgdm9pZCBIVE1MIGVsZW1lbnRzOyBpLmUuIGVsZW1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYW4gZW5kIHRhZy5cbiAgICogICAtICoqc3ZnRWxlbWVudHMqKiAtIGB7QXJyYXk8U3RyaW5nPn1gIC0gQSBsaXN0IG9mIGVsZW1lbnRzIHRvIGV4dGVuZCB0aGUgY3VycmVudCBsaXN0IG9mIFNWR1xuICAgKiAgICAgZWxlbWVudHMuIFRoZSBsaXN0IG9mIFNWRyBlbGVtZW50cyBpcyBvbmx5IHRha2VuIGludG8gYWNjb3VudCBpZiBTVkcgaXNcbiAgICogICAgIHtAbGluayBuZ1Nhbml0aXplLiRzYW5pdGl6ZVByb3ZpZGVyI2VuYWJsZVN2ZyBlbmFibGVkfSBmb3IgYCRzYW5pdGl6ZWAuXG4gICAqXG4gICAqIFBhc3NpbmcgYW4gYXJyYXkgKGBbLi4uXWApIGlzIGVxdWl2YWxlbnQgdG8gcGFzc2luZyBge2h0bWxFbGVtZW50czogWy4uLl19YC5cbiAgICpcbiAgICogQHJldHVybiB7JHNhbml0aXplUHJvdmlkZXJ9IFJldHVybnMgc2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICB0aGlzLmFkZFZhbGlkRWxlbWVudHMgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgIGlmICghaGFzQmVlbkluc3RhbnRpYXRlZCkge1xuICAgICAgaWYgKGlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgIGVsZW1lbnRzID0ge2h0bWxFbGVtZW50czogZWxlbWVudHN9O1xuICAgICAgfVxuXG4gICAgICBhZGRFbGVtZW50c1RvKHN2Z0VsZW1lbnRzLCBlbGVtZW50cy5zdmdFbGVtZW50cyk7XG4gICAgICBhZGRFbGVtZW50c1RvKHZvaWRFbGVtZW50cywgZWxlbWVudHMuaHRtbFZvaWRFbGVtZW50cyk7XG4gICAgICBhZGRFbGVtZW50c1RvKHZhbGlkRWxlbWVudHMsIGVsZW1lbnRzLmh0bWxWb2lkRWxlbWVudHMpO1xuICAgICAgYWRkRWxlbWVudHNUbyh2YWxpZEVsZW1lbnRzLCBlbGVtZW50cy5odG1sRWxlbWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBtZXRob2RcbiAgICogQG5hbWUgJHNhbml0aXplUHJvdmlkZXIjYWRkVmFsaWRBdHRyc1xuICAgKiBAa2luZCBmdW5jdGlvblxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRXh0ZW5kcyB0aGUgYnVpbHQtaW4gbGlzdCBvZiB2YWxpZCBhdHRyaWJ1dGVzLCBpLmUuIGF0dHJpYnV0ZXMgdGhhdCBhcmUgY29uc2lkZXJlZCBzYWZlIGFuZCBhcmVcbiAgICogbm90IHN0cmlwcGVkIG9mZiBkdXJpbmcgc2FuaXRpemF0aW9uLlxuICAgKlxuICAgKiAqKk5vdGUqKjpcbiAgICogVGhlIG5ldyBhdHRyaWJ1dGVzIHdpbGwgbm90IGJlIHRyZWF0ZWQgYXMgVVJJIGF0dHJpYnV0ZXMsIHdoaWNoIG1lYW5zIHRoZWlyIHZhbHVlcyB3aWxsIG5vdCBiZVxuICAgKiBzYW5pdGl6ZWQgYXMgVVJJcyB1c2luZyBgJGNvbXBpbGVQcm92aWRlcmAnc1xuICAgKiB7QGxpbmsgbmcuJGNvbXBpbGVQcm92aWRlciNhSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdCBhSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdH0gYW5kXG4gICAqIHtAbGluayBuZy4kY29tcGlsZVByb3ZpZGVyI2ltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdCBpbWdTcmNTYW5pdGl6YXRpb25XaGl0ZWxpc3R9LlxuICAgKlxuICAgKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtaW5mb1wiPlxuICAgKiAgIFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGR1cmluZyB0aGUge0BsaW5rIGFuZ3VsYXIuTW9kdWxlI2NvbmZpZyBjb25maWd9IHBoYXNlLiBPbmNlIHRoZVxuICAgKiAgIGAkc2FuaXRpemVgIHNlcnZpY2UgaGFzIGJlZW4gaW5zdGFudGlhdGVkLCB0aGlzIG1ldGhvZCBoYXMgbm8gZWZmZWN0LlxuICAgKiA8L2Rpdj5cbiAgICpcbiAgICogPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LXdhcm5pbmdcIj5cbiAgICogICBLZWVwIGluIG1pbmQgdGhhdCBleHRlbmRpbmcgdGhlIGJ1aWx0LWluIGxpc3Qgb2YgYXR0cmlidXRlcyBtYXkgZXhwb3NlIHlvdXIgYXBwIHRvIFhTUyBvclxuICAgKiAgIG90aGVyIHZ1bG5lcmFiaWxpdGllcy4gQmUgdmVyeSBtaW5kZnVsIG9mIHRoZSBhdHRyaWJ1dGVzIHlvdSBhZGQuXG4gICAqIDwvZGl2PlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IGF0dHJzIC0gQSBsaXN0IG9mIHZhbGlkIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHskc2FuaXRpemVQcm92aWRlcn0gUmV0dXJucyBzZWxmIGZvciBjaGFpbmluZy5cbiAgICovXG4gIHRoaXMuYWRkVmFsaWRBdHRycyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgaWYgKCFoYXNCZWVuSW5zdGFudGlhdGVkKSB7XG4gICAgICBleHRlbmQodmFsaWRBdHRycywgYXJyYXlUb01hcChhdHRycywgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBQcml2YXRlIHN0dWZmXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgYmluZCA9IGFuZ3VsYXIuYmluZDtcbiAgZXh0ZW5kID0gYW5ndWxhci5leHRlbmQ7XG4gIGZvckVhY2ggPSBhbmd1bGFyLmZvckVhY2g7XG4gIGlzQXJyYXkgPSBhbmd1bGFyLmlzQXJyYXk7XG4gIGlzRGVmaW5lZCA9IGFuZ3VsYXIuaXNEZWZpbmVkO1xuICBsb3dlcmNhc2UgPSBhbmd1bGFyLmxvd2VyY2FzZTtcbiAgbm9vcCA9IGFuZ3VsYXIubm9vcDtcblxuICBodG1sUGFyc2VyID0gaHRtbFBhcnNlckltcGw7XG4gIGh0bWxTYW5pdGl6ZVdyaXRlciA9IGh0bWxTYW5pdGl6ZVdyaXRlckltcGw7XG5cbiAgbm9kZUNvbnRhaW5zID0gd2luZG93Lk5vZGUucHJvdG90eXBlLmNvbnRhaW5zIHx8IC8qKiBAdGhpcyAqLyBmdW5jdGlvbihhcmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIHJldHVybiAhISh0aGlzLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGFyZykgJiAxNik7XG4gIH07XG5cbiAgLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG4gIHZhciBTVVJST0dBVEVfUEFJUl9SRUdFWFAgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLFxuICAgIC8vIE1hdGNoIGV2ZXJ5dGhpbmcgb3V0c2lkZSBvZiBub3JtYWwgY2hhcnMgYW5kIFwiIChxdW90ZSBjaGFyYWN0ZXIpXG4gICAgTk9OX0FMUEhBTlVNRVJJQ19SRUdFWFAgPSAvKFteIy1+IHwhXSkvZztcblxuXG4gIC8vIEdvb2Qgc291cmNlIG9mIGluZm8gYWJvdXQgZWxlbWVudHMgYW5kIGF0dHJpYnV0ZXNcbiAgLy8gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy9PdmVydmlldy5odG1sI3NlbWFudGljc1xuICAvLyBodHRwOi8vc2ltb24uaHRtbDUub3JnL2h0bWwtZWxlbWVudHNcblxuICAvLyBTYWZlIFZvaWQgRWxlbWVudHMgLSBIVE1MNVxuICAvLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjdm9pZC1lbGVtZW50c1xuICB2YXIgdm9pZEVsZW1lbnRzID0gc3RyaW5nVG9NYXAoJ2FyZWEsYnIsY29sLGhyLGltZyx3YnInKTtcblxuICAvLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW4gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuICAvLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjb3B0aW9uYWwtdGFnc1xuICB2YXIgb3B0aW9uYWxFbmRUYWdCbG9ja0VsZW1lbnRzID0gc3RyaW5nVG9NYXAoJ2NvbGdyb3VwLGRkLGR0LGxpLHAsdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsdHInKSxcbiAgICAgIG9wdGlvbmFsRW5kVGFnSW5saW5lRWxlbWVudHMgPSBzdHJpbmdUb01hcCgncnAscnQnKSxcbiAgICAgIG9wdGlvbmFsRW5kVGFnRWxlbWVudHMgPSBleHRlbmQoe30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdJbmxpbmVFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbEVuZFRhZ0Jsb2NrRWxlbWVudHMpO1xuXG4gIC8vIFNhZmUgQmxvY2sgRWxlbWVudHMgLSBIVE1MNVxuICB2YXIgYmxvY2tFbGVtZW50cyA9IGV4dGVuZCh7fSwgb3B0aW9uYWxFbmRUYWdCbG9ja0VsZW1lbnRzLCBzdHJpbmdUb01hcCgnYWRkcmVzcyxhcnRpY2xlLCcgK1xuICAgICAgICAgICdhc2lkZSxibG9ja3F1b3RlLGNhcHRpb24sY2VudGVyLGRlbCxkaXIsZGl2LGRsLGZpZ3VyZSxmaWdjYXB0aW9uLGZvb3RlcixoMSxoMixoMyxoNCxoNSwnICtcbiAgICAgICAgICAnaDYsaGVhZGVyLGhncm91cCxocixpbnMsbWFwLG1lbnUsbmF2LG9sLHByZSxzZWN0aW9uLHRhYmxlLHVsJykpO1xuXG4gIC8vIElubGluZSBFbGVtZW50cyAtIEhUTUw1XG4gIHZhciBpbmxpbmVFbGVtZW50cyA9IGV4dGVuZCh7fSwgb3B0aW9uYWxFbmRUYWdJbmxpbmVFbGVtZW50cywgc3RyaW5nVG9NYXAoJ2EsYWJicixhY3JvbnltLGIsJyArXG4gICAgICAgICAgJ2JkaSxiZG8sYmlnLGJyLGNpdGUsY29kZSxkZWwsZGZuLGVtLGZvbnQsaSxpbWcsaW5zLGtiZCxsYWJlbCxtYXAsbWFyayxxLHJ1YnkscnAscnQscywnICtcbiAgICAgICAgICAnc2FtcCxzbWFsbCxzcGFuLHN0cmlrZSxzdHJvbmcsc3ViLHN1cCx0aW1lLHR0LHUsdmFyJykpO1xuXG4gIC8vIFNWRyBFbGVtZW50c1xuICAvLyBodHRwczovL3dpa2kud2hhdHdnLm9yZy93aWtpL1Nhbml0aXphdGlvbl9ydWxlcyNzdmdfRWxlbWVudHNcbiAgLy8gTm90ZTogdGhlIGVsZW1lbnRzIGFuaW1hdGUsYW5pbWF0ZUNvbG9yLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxzZXQgYXJlIGludGVudGlvbmFsbHkgb21pdHRlZC5cbiAgLy8gVGhleSBjYW4gcG90ZW50aWFsbHkgYWxsb3cgZm9yIGFyYml0cmFyeSBqYXZhc2NyaXB0IHRvIGJlIGV4ZWN1dGVkLiBTZWUgIzExMjkwXG4gIHZhciBzdmdFbGVtZW50cyA9IHN0cmluZ1RvTWFwKCdjaXJjbGUsZGVmcyxkZXNjLGVsbGlwc2UsZm9udC1mYWNlLGZvbnQtZmFjZS1uYW1lLGZvbnQtZmFjZS1zcmMsZyxnbHlwaCwnICtcbiAgICAgICAgICAnaGtlcm4saW1hZ2UsbGluZWFyR3JhZGllbnQsbGluZSxtYXJrZXIsbWV0YWRhdGEsbWlzc2luZy1nbHlwaCxtcGF0aCxwYXRoLHBvbHlnb24scG9seWxpbmUsJyArXG4gICAgICAgICAgJ3JhZGlhbEdyYWRpZW50LHJlY3Qsc3RvcCxzdmcsc3dpdGNoLHRleHQsdGl0bGUsdHNwYW4nKTtcblxuICAvLyBCbG9ja2VkIEVsZW1lbnRzICh3aWxsIGJlIHN0cmlwcGVkKVxuICB2YXIgYmxvY2tlZEVsZW1lbnRzID0gc3RyaW5nVG9NYXAoJ3NjcmlwdCxzdHlsZScpO1xuXG4gIHZhciB2YWxpZEVsZW1lbnRzID0gZXh0ZW5kKHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWRFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0VsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubGluZUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsRW5kVGFnRWxlbWVudHMpO1xuXG4gIC8vQXR0cmlidXRlcyB0aGF0IGhhdmUgaHJlZiBhbmQgaGVuY2UgbmVlZCB0byBiZSBzYW5pdGl6ZWRcbiAgdmFyIHVyaUF0dHJzID0gc3RyaW5nVG9NYXAoJ2JhY2tncm91bmQsY2l0ZSxocmVmLGxvbmdkZXNjLHNyYyx4bGluazpocmVmLHhtbDpiYXNlJyk7XG5cbiAgdmFyIGh0bWxBdHRycyA9IHN0cmluZ1RvTWFwKCdhYmJyLGFsaWduLGFsdCxheGlzLGJnY29sb3IsYm9yZGVyLGNlbGxwYWRkaW5nLGNlbGxzcGFjaW5nLGNsYXNzLGNsZWFyLCcgK1xuICAgICAgJ2NvbG9yLGNvbHMsY29sc3Bhbixjb21wYWN0LGNvb3JkcyxkaXIsZmFjZSxoZWFkZXJzLGhlaWdodCxocmVmbGFuZyxoc3BhY2UsJyArXG4gICAgICAnaXNtYXAsbGFuZyxsYW5ndWFnZSxub2hyZWYsbm93cmFwLHJlbCxyZXYscm93cyxyb3dzcGFuLHJ1bGVzLCcgK1xuICAgICAgJ3Njb3BlLHNjcm9sbGluZyxzaGFwZSxzaXplLHNwYW4sc3RhcnQsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHlwZSwnICtcbiAgICAgICd2YWxpZ24sdmFsdWUsdnNwYWNlLHdpZHRoJyk7XG5cbiAgLy8gU1ZHIGF0dHJpYnV0ZXMgKHdpdGhvdXQgXCJpZFwiIGFuZCBcIm5hbWVcIiBhdHRyaWJ1dGVzKVxuICAvLyBodHRwczovL3dpa2kud2hhdHdnLm9yZy93aWtpL1Nhbml0aXphdGlvbl9ydWxlcyNzdmdfQXR0cmlidXRlc1xuICB2YXIgc3ZnQXR0cnMgPSBzdHJpbmdUb01hcCgnYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFscGhhYmV0aWMsYXJhYmljLWZvcm0sYXNjZW50LCcgK1xuICAgICAgJ2Jhc2VQcm9maWxlLGJib3gsYmVnaW4sYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxjb2xvcixjb2xvci1yZW5kZXJpbmcsY29udGVudCwnICtcbiAgICAgICdjeCxjeSxkLGR4LGR5LGRlc2NlbnQsZGlzcGxheSxkdXIsZW5kLGZpbGwsZmlsbC1ydWxlLGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXN0cmV0Y2gsJyArXG4gICAgICAnZm9udC1zdHlsZSxmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZnJvbSxmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGdyYWRpZW50VW5pdHMsaGFuZ2luZywnICtcbiAgICAgICdoZWlnaHQsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWRlb2dyYXBoaWMsayxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxsYW5nLCcgK1xuICAgICAgJ21hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hdGhlbWF0aWNhbCwnICtcbiAgICAgICdtYXgsbWluLG9mZnNldCxvcGFjaXR5LG9yaWVudCxvcmlnaW4sb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLCcgK1xuICAgICAgJ3BhdGgscGF0aExlbmd0aCxwb2ludHMscHJlc2VydmVBc3BlY3RSYXRpbyxyLHJlZlgscmVmWSxyZXBlYXRDb3VudCxyZXBlYXREdXIsJyArXG4gICAgICAncmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyb3RhdGUscngscnksc2xvcGUsc3RlbWgsc3RlbXYsc3RvcC1jb2xvciwnICtcbiAgICAgICdzdG9wLW9wYWNpdHksc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJva2Usc3Ryb2tlLWRhc2hhcnJheSwnICtcbiAgICAgICdzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksJyArXG4gICAgICAnc3Ryb2tlLXdpZHRoLHN5c3RlbUxhbmd1YWdlLHRhcmdldCx0ZXh0LWFuY2hvcix0byx0cmFuc2Zvcm0sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sJyArXG4gICAgICAndW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHZhbHVlcyx2ZXJzaW9uLHZpZXdCb3gsdmlzaWJpbGl0eSwnICtcbiAgICAgICd3aWR0aCx3aWR0aHMseCx4LWhlaWdodCx4MSx4Mix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLCcgK1xuICAgICAgJ3hsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHhtbG5zLHhtbG5zOnhsaW5rLHkseTEseTIsem9vbUFuZFBhbicsIHRydWUpO1xuXG4gIHZhciB2YWxpZEF0dHJzID0gZXh0ZW5kKHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVyaUF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Z0F0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxBdHRycyk7XG5cbiAgZnVuY3Rpb24gc3RyaW5nVG9NYXAoc3RyLCBsb3dlcmNhc2VLZXlzKSB7XG4gICAgcmV0dXJuIGFycmF5VG9NYXAoc3RyLnNwbGl0KCcsJyksIGxvd2VyY2FzZUtleXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlUb01hcChpdGVtcywgbG93ZXJjYXNlS2V5cykge1xuICAgIHZhciBvYmogPSB7fSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9ialtsb3dlcmNhc2VLZXlzID8gbG93ZXJjYXNlKGl0ZW1zW2ldKSA6IGl0ZW1zW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFbGVtZW50c1RvKGVsZW1lbnRzTWFwLCBuZXdFbGVtZW50cykge1xuICAgIGlmIChuZXdFbGVtZW50cyAmJiBuZXdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIGV4dGVuZChlbGVtZW50c01hcCwgYXJyYXlUb01hcChuZXdFbGVtZW50cykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5lcnQgZG9jdW1lbnQgdGhhdCBjb250YWlucyB0aGUgZGlydHkgSFRNTCB0aGF0IG5lZWRzIHNhbml0aXppbmdcbiAgICogRGVwZW5kaW5nIHVwb24gYnJvd3NlciBzdXBwb3J0IHdlIHVzZSBvbmUgb2YgdGhyZWUgc3RyYXRlZ2llcyBmb3IgZG9pbmcgdGhpcy5cbiAgICogU3VwcG9ydDogU2FmYXJpIDEwLnggLT4gWEhSIHN0cmF0ZWd5XG4gICAqIFN1cHBvcnQ6IEZpcmVmb3ggLT4gRG9tUGFyc2VyIHN0cmF0ZWd5XG4gICAqL1xuICB2YXIgZ2V0SW5lcnRCb2R5RWxlbWVudCAvKiBmdW5jdGlvbihodG1sOiBzdHJpbmcpOiBIVE1MQm9keUVsZW1lbnQgKi8gPSAoZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCkge1xuICAgIHZhciBpbmVydERvY3VtZW50O1xuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgaW5lcnREb2N1bWVudCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnaW5lcnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJHNhbml0aXplTWluRXJyKCdub2luZXJ0JywgJ0NhblxcJ3QgY3JlYXRlIGFuIGluZXJ0IGh0bWwgZG9jdW1lbnQnKTtcbiAgICB9XG4gICAgdmFyIGluZXJ0Qm9keUVsZW1lbnQgPSAoaW5lcnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgaW5lcnREb2N1bWVudC5nZXREb2N1bWVudEVsZW1lbnQoKSkucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBTYWZhcmkgMTAuMSBidWcgLSB3aGljaCBhbGxvd3MgSlMgdG8gcnVuIGluc2lkZSB0aGUgU1ZHIEcgZWxlbWVudFxuICAgIGluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MID0gJzxzdmc+PGcgb25sb2FkPVwidGhpcy5wYXJlbnROb2RlLnJlbW92ZSgpXCI+PC9nPjwvc3ZnPic7XG4gICAgaWYgKCFpbmVydEJvZHlFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpKSB7XG4gICAgICByZXR1cm4gZ2V0SW5lcnRCb2R5RWxlbWVudF9YSFI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENoZWNrIGZvciB0aGUgRmlyZWZveCBidWcgLSB3aGljaCBwcmV2ZW50cyB0aGUgaW5uZXIgaW1nIEpTIGZyb20gYmVpbmcgc2FuaXRpemVkXG4gICAgICBpbmVydEJvZHlFbGVtZW50LmlubmVySFRNTCA9ICc8c3ZnPjxwPjxzdHlsZT48aW1nIHNyYz1cIjwvc3R5bGU+PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpLy9cIj4nO1xuICAgICAgaWYgKGluZXJ0Qm9keUVsZW1lbnQucXVlcnlTZWxlY3Rvcignc3ZnIGltZycpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbmVydEJvZHlFbGVtZW50X0RPTVBhcnNlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRJbmVydEJvZHlFbGVtZW50X0luZXJ0RG9jdW1lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW5lcnRCb2R5RWxlbWVudF9YSFIoaHRtbCkge1xuICAgICAgLy8gV2UgYWRkIHRoaXMgZHVtbXkgZWxlbWVudCB0byBlbnN1cmUgdGhhdCB0aGUgcmVzdCBvZiB0aGUgY29udGVudCBpcyBwYXJzZWQgYXMgZXhwZWN0ZWRcbiAgICAgIC8vIGUuZy4gbGVhZGluZyB3aGl0ZXNwYWNlIGlzIG1haW50YWluZWQgYW5kIHRhZ3MgbGlrZSBgPG1ldGE+YCBkbyBub3QgZ2V0IGhvaXN0ZWQgdG8gdGhlIGA8aGVhZD5gIHRhZy5cbiAgICAgIGh0bWwgPSAnPHJlbW92ZT48L3JlbW92ZT4nICsgaHRtbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGh0bWwgPSBlbmNvZGVVUkkoaHRtbCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgeGhyID0gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdkb2N1bWVudCc7XG4gICAgICB4aHIub3BlbignR0VUJywgJ2RhdGE6dGV4dC9odG1sO2NoYXJzZXQ9dXRmLTgsJyArIGh0bWwsIGZhbHNlKTtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgdmFyIGJvZHkgPSB4aHIucmVzcG9uc2UuYm9keTtcbiAgICAgIGJvZHkuZmlyc3RDaGlsZC5yZW1vdmUoKTtcbiAgICAgIHJldHVybiBib2R5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEluZXJ0Qm9keUVsZW1lbnRfRE9NUGFyc2VyKGh0bWwpIHtcbiAgICAgIC8vIFdlIGFkZCB0aGlzIGR1bW15IGVsZW1lbnQgdG8gZW5zdXJlIHRoYXQgdGhlIHJlc3Qgb2YgdGhlIGNvbnRlbnQgaXMgcGFyc2VkIGFzIGV4cGVjdGVkXG4gICAgICAvLyBlLmcuIGxlYWRpbmcgd2hpdGVzcGFjZSBpcyBtYWludGFpbmVkIGFuZCB0YWdzIGxpa2UgYDxtZXRhPmAgZG8gbm90IGdldCBob2lzdGVkIHRvIHRoZSBgPGhlYWQ+YCB0YWcuXG4gICAgICBodG1sID0gJzxyZW1vdmU+PC9yZW1vdmU+JyArIGh0bWw7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgYm9keSA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGh0bWwsICd0ZXh0L2h0bWwnKS5ib2R5O1xuICAgICAgICBib2R5LmZpcnN0Q2hpbGQucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEluZXJ0Qm9keUVsZW1lbnRfSW5lcnREb2N1bWVudChodG1sKSB7XG4gICAgICBpbmVydEJvZHlFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IElFIDktMTEgb25seVxuICAgICAgLy8gc3RyaXAgY3VzdG9tLW5hbWVzcGFjZWQgYXR0cmlidXRlcyBvbiBJRTw9MTFcbiAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudE1vZGUpIHtcbiAgICAgICAgc3RyaXBDdXN0b21Oc0F0dHJzKGluZXJ0Qm9keUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5lcnRCb2R5RWxlbWVudDtcbiAgICB9XG4gIH0pKHdpbmRvdywgd2luZG93LmRvY3VtZW50KTtcblxuICAvKipcbiAgICogQGV4YW1wbGVcbiAgICogaHRtbFBhcnNlcihodG1sU3RyaW5nLCB7XG4gICAqICAgICBzdGFydDogZnVuY3Rpb24odGFnLCBhdHRycykge30sXG4gICAqICAgICBlbmQ6IGZ1bmN0aW9uKHRhZykge30sXG4gICAqICAgICBjaGFyczogZnVuY3Rpb24odGV4dCkge30sXG4gICAqICAgICBjb21tZW50OiBmdW5jdGlvbih0ZXh0KSB7fVxuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgc3RyaW5nXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBodG1sUGFyc2VySW1wbChodG1sLCBoYW5kbGVyKSB7XG4gICAgaWYgKGh0bWwgPT09IG51bGwgfHwgaHRtbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBodG1sID0gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaHRtbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGh0bWwgPSAnJyArIGh0bWw7XG4gICAgfVxuXG4gICAgdmFyIGluZXJ0Qm9keUVsZW1lbnQgPSBnZXRJbmVydEJvZHlFbGVtZW50KGh0bWwpO1xuICAgIGlmICghaW5lcnRCb2R5RWxlbWVudCkgcmV0dXJuICcnO1xuXG4gICAgLy9tWFNTIHByb3RlY3Rpb25cbiAgICB2YXIgbVhTU0F0dGVtcHRzID0gNTtcbiAgICBkbyB7XG4gICAgICBpZiAobVhTU0F0dGVtcHRzID09PSAwKSB7XG4gICAgICAgIHRocm93ICRzYW5pdGl6ZU1pbkVycigndWlucHV0JywgJ0ZhaWxlZCB0byBzYW5pdGl6ZSBodG1sIGJlY2F1c2UgdGhlIGlucHV0IGlzIHVuc3RhYmxlJyk7XG4gICAgICB9XG4gICAgICBtWFNTQXR0ZW1wdHMtLTtcblxuICAgICAgLy8gdHJpZ2dlciBtWFNTIGlmIGl0IGlzIGdvaW5nIHRvIGhhcHBlbiBieSByZWFkaW5nIGFuZCB3cml0aW5nIHRoZSBpbm5lckhUTUxcbiAgICAgIGh0bWwgPSBpbmVydEJvZHlFbGVtZW50LmlubmVySFRNTDtcbiAgICAgIGluZXJ0Qm9keUVsZW1lbnQgPSBnZXRJbmVydEJvZHlFbGVtZW50KGh0bWwpO1xuICAgIH0gd2hpbGUgKGh0bWwgIT09IGluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MKTtcblxuICAgIHZhciBub2RlID0gaW5lcnRCb2R5RWxlbWVudC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSAxOiAvLyBFTEVNRU5UX05PREVcbiAgICAgICAgICBoYW5kbGVyLnN0YXJ0KG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgYXR0clRvTWFwKG5vZGUuYXR0cmlidXRlcykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6IC8vIFRFWFQgTk9ERVxuICAgICAgICAgIGhhbmRsZXIuY2hhcnMobm9kZS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0Tm9kZTtcbiAgICAgIGlmICghKG5leHROb2RlID0gbm9kZS5maXJzdENoaWxkKSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIGhhbmRsZXIuZW5kKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dE5vZGUgPSBnZXROb25EZXNjZW5kYW50KCduZXh0U2libGluZycsIG5vZGUpO1xuICAgICAgICBpZiAoIW5leHROb2RlKSB7XG4gICAgICAgICAgd2hpbGUgKG5leHROb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUgPSBnZXROb25EZXNjZW5kYW50KCdwYXJlbnROb2RlJywgbm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gaW5lcnRCb2R5RWxlbWVudCkgYnJlYWs7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGdldE5vbkRlc2NlbmRhbnQoJ25leHRTaWJsaW5nJywgbm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICBoYW5kbGVyLmVuZChub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZSA9IG5leHROb2RlO1xuICAgIH1cblxuICAgIHdoaWxlICgobm9kZSA9IGluZXJ0Qm9keUVsZW1lbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgIGluZXJ0Qm9keUVsZW1lbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0clRvTWFwKGF0dHJzKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGF0dHJzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgICBtYXBbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIGFsbCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY2hhcmFjdGVycywgc28gdGhhdCB0aGVcbiAgICogcmVzdWx0aW5nIHN0cmluZyBjYW4gYmUgc2FmZWx5IGluc2VydGVkIGludG8gYXR0cmlidXRlIG9yXG4gICAqIGVsZW1lbnQgdGV4dC5cbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgdGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gZW5jb2RlRW50aXRpZXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuXG4gICAgICByZXBsYWNlKC8mL2csICcmYW1wOycpLlxuICAgICAgcmVwbGFjZShTVVJST0dBVEVfUEFJUl9SRUdFWFAsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBoaSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHZhciBsb3cgPSB2YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgICByZXR1cm4gJyYjJyArICgoKGhpIC0gMHhEODAwKSAqIDB4NDAwKSArIChsb3cgLSAweERDMDApICsgMHgxMDAwMCkgKyAnOyc7XG4gICAgICB9KS5cbiAgICAgIHJlcGxhY2UoTk9OX0FMUEhBTlVNRVJJQ19SRUdFWFAsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnJiMnICsgdmFsdWUuY2hhckNvZGVBdCgwKSArICc7JztcbiAgICAgIH0pLlxuICAgICAgcmVwbGFjZSgvPC9nLCAnJmx0OycpLlxuICAgICAgcmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhbiBIVE1ML1hNTCB3cml0ZXIgd2hpY2ggd3JpdGVzIHRvIGJ1ZmZlclxuICAgKiBAcGFyYW0ge0FycmF5fSBidWYgdXNlIGJ1Zi5qb2luKCcnKSB0byBnZXQgb3V0IHNhbml0aXplZCBodG1sIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBpbiB0aGUgZm9ybSBvZiB7XG4gICAqICAgICBzdGFydDogZnVuY3Rpb24odGFnLCBhdHRycykge30sXG4gICAqICAgICBlbmQ6IGZ1bmN0aW9uKHRhZykge30sXG4gICAqICAgICBjaGFyczogZnVuY3Rpb24odGV4dCkge30sXG4gICAqICAgICBjb21tZW50OiBmdW5jdGlvbih0ZXh0KSB7fVxuICAgKiB9XG4gICAqL1xuICBmdW5jdGlvbiBodG1sU2FuaXRpemVXcml0ZXJJbXBsKGJ1ZiwgdXJpVmFsaWRhdG9yKSB7XG4gICAgdmFyIGlnbm9yZUN1cnJlbnRFbGVtZW50ID0gZmFsc2U7XG4gICAgdmFyIG91dCA9IGJpbmQoYnVmLCBidWYucHVzaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzKSB7XG4gICAgICAgIHRhZyA9IGxvd2VyY2FzZSh0YWcpO1xuICAgICAgICBpZiAoIWlnbm9yZUN1cnJlbnRFbGVtZW50ICYmIGJsb2NrZWRFbGVtZW50c1t0YWddKSB7XG4gICAgICAgICAgaWdub3JlQ3VycmVudEVsZW1lbnQgPSB0YWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpZ25vcmVDdXJyZW50RWxlbWVudCAmJiB2YWxpZEVsZW1lbnRzW3RhZ10gPT09IHRydWUpIHtcbiAgICAgICAgICBvdXQoJzwnKTtcbiAgICAgICAgICBvdXQodGFnKTtcbiAgICAgICAgICBmb3JFYWNoKGF0dHJzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgbGtleSA9IGxvd2VyY2FzZShrZXkpO1xuICAgICAgICAgICAgdmFyIGlzSW1hZ2UgPSAodGFnID09PSAnaW1nJyAmJiBsa2V5ID09PSAnc3JjJykgfHwgKGxrZXkgPT09ICdiYWNrZ3JvdW5kJyk7XG4gICAgICAgICAgICBpZiAodmFsaWRBdHRyc1tsa2V5XSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAodXJpQXR0cnNbbGtleV0gIT09IHRydWUgfHwgdXJpVmFsaWRhdG9yKHZhbHVlLCBpc0ltYWdlKSkpIHtcbiAgICAgICAgICAgICAgb3V0KCcgJyk7XG4gICAgICAgICAgICAgIG91dChrZXkpO1xuICAgICAgICAgICAgICBvdXQoJz1cIicpO1xuICAgICAgICAgICAgICBvdXQoZW5jb2RlRW50aXRpZXModmFsdWUpKTtcbiAgICAgICAgICAgICAgb3V0KCdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG91dCgnPicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5kOiBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgdGFnID0gbG93ZXJjYXNlKHRhZyk7XG4gICAgICAgIGlmICghaWdub3JlQ3VycmVudEVsZW1lbnQgJiYgdmFsaWRFbGVtZW50c1t0YWddID09PSB0cnVlICYmIHZvaWRFbGVtZW50c1t0YWddICE9PSB0cnVlKSB7XG4gICAgICAgICAgb3V0KCc8LycpO1xuICAgICAgICAgIG91dCh0YWcpO1xuICAgICAgICAgIG91dCgnPicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgaWYgKHRhZyA9PSBpZ25vcmVDdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIGlnbm9yZUN1cnJlbnRFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjaGFyczogZnVuY3Rpb24oY2hhcnMpIHtcbiAgICAgICAgaWYgKCFpZ25vcmVDdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIG91dChlbmNvZGVFbnRpdGllcyhjaGFycykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdoZW4gSUU5LTExIGNvbWVzIGFjcm9zcyBhbiB1bmtub3duIG5hbWVzcGFjZWQgYXR0cmlidXRlIGUuZy4gJ3hsaW5rOmZvbycgaXQgYWRkcyAneG1sbnM6bnMxJyBhdHRyaWJ1dGUgdG8gZGVjbGFyZVxuICAgKiBuczEgbmFtZXNwYWNlIGFuZCBwcmVmaXhlcyB0aGUgYXR0cmlidXRlIHdpdGggJ25zMScgKGUuZy4gJ25zMTp4bGluazpmb28nKS4gVGhpcyBpcyB1bmRlc2lyYWJsZSBzaW5jZSB3ZSBkb24ndCB3YW50XG4gICAqIHRvIGFsbG93IGFueSBvZiB0aGVzZSBjdXN0b20gYXR0cmlidXRlcy4gVGhpcyBtZXRob2Qgc3RyaXBzIHRoZW0gYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSBSb290IGVsZW1lbnQgdG8gcHJvY2Vzc1xuICAgKi9cbiAgZnVuY3Rpb24gc3RyaXBDdXN0b21Oc0F0dHJzKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IHdpbmRvdy5Ob2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGF0dHJOb2RlID0gYXR0cnNbaV07XG4gICAgICAgICAgdmFyIGF0dHJOYW1lID0gYXR0ck5vZGUubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ3htbG5zOm5zMScgfHwgYXR0ck5hbWUubGFzdEluZGV4T2YoJ25zMTonLCAwKSA9PT0gMCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOb2RlKGF0dHJOb2RlKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGwtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5leHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgaWYgKG5leHROb2RlKSB7XG4gICAgICAgIHN0cmlwQ3VzdG9tTnNBdHRycyhuZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBnZXROb25EZXNjZW5kYW50KCduZXh0U2libGluZycsIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vbkRlc2NlbmRhbnQocHJvcE5hbWUsIG5vZGUpIHtcbiAgICAvLyBBbiBlbGVtZW50IGlzIGNsb2JiZXJlZCBpZiBpdHMgYHByb3BOYW1lYCBwcm9wZXJ0eSBwb2ludHMgdG8gb25lIG9mIGl0cyBkZXNjZW5kYW50c1xuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGVbcHJvcE5hbWVdO1xuICAgIGlmIChuZXh0Tm9kZSAmJiBub2RlQ29udGFpbnMuY2FsbChub2RlLCBuZXh0Tm9kZSkpIHtcbiAgICAgIHRocm93ICRzYW5pdGl6ZU1pbkVycignZWxjbG9iJywgJ0ZhaWxlZCB0byBzYW5pdGl6ZSBodG1sIGJlY2F1c2UgdGhlIGVsZW1lbnQgaXMgY2xvYmJlcmVkOiB7MH0nLCBub2RlLm91dGVySFRNTCB8fCBub2RlLm91dGVyVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZVRleHQoY2hhcnMpIHtcbiAgdmFyIGJ1ZiA9IFtdO1xuICB2YXIgd3JpdGVyID0gaHRtbFNhbml0aXplV3JpdGVyKGJ1Ziwgbm9vcCk7XG4gIHdyaXRlci5jaGFycyhjaGFycyk7XG4gIHJldHVybiBidWYuam9pbignJyk7XG59XG5cblxuLy8gZGVmaW5lIG5nU2FuaXRpemUgbW9kdWxlIGFuZCByZWdpc3RlciAkc2FuaXRpemUgc2VydmljZVxuYW5ndWxhci5tb2R1bGUoJ25nU2FuaXRpemUnLCBbXSlcbiAgLnByb3ZpZGVyKCckc2FuaXRpemUnLCAkU2FuaXRpemVQcm92aWRlcilcbiAgLmluZm8oeyBhbmd1bGFyVmVyc2lvbjogJzEuNi4xMCcgfSk7XG5cbi8qKlxuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgbGlua3lcbiAqIEBraW5kIGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBGaW5kcyBsaW5rcyBpbiB0ZXh0IGlucHV0IGFuZCB0dXJucyB0aGVtIGludG8gaHRtbCBsaW5rcy4gU3VwcG9ydHMgYGh0dHAvaHR0cHMvZnRwL3NmdHAvbWFpbHRvYCBhbmRcbiAqIHBsYWluIGVtYWlsIGFkZHJlc3MgbGlua3MuXG4gKlxuICogUmVxdWlyZXMgdGhlIHtAbGluayBuZ1Nhbml0aXplIGBuZ1Nhbml0aXplYH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBJbnB1dCB0ZXh0LlxuICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFdpbmRvdyAoYF9ibGFua3xfc2VsZnxfcGFyZW50fF90b3BgKSBvciBuYW1lZCBmcmFtZSB0byBvcGVuIGxpbmtzIGluLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb24odXJsKX0gW2F0dHJpYnV0ZXNdIEFkZCBjdXN0b20gYXR0cmlidXRlcyB0byB0aGUgbGluayBlbGVtZW50LlxuICpcbiAqICAgIENhbiBiZSBvbmUgb2Y6XG4gKlxuICogICAgLSBgb2JqZWN0YDogQSBtYXAgb2YgYXR0cmlidXRlc1xuICogICAgLSBgZnVuY3Rpb25gOiBUYWtlcyB0aGUgdXJsIGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGEgbWFwIG9mIGF0dHJpYnV0ZXNcbiAqXG4gKiAgICBJZiB0aGUgbWFwIG9mIGF0dHJpYnV0ZXMgY29udGFpbnMgYSB2YWx1ZSBmb3IgYHRhcmdldGAsIGl0IG92ZXJyaWRlcyB0aGUgdmFsdWUgb2ZcbiAqICAgIHRoZSB0YXJnZXQgcGFyYW1ldGVyLlxuICpcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIdG1sLWxpbmtpZmllZCBhbmQge0BsaW5rICRzYW5pdGl6ZSBzYW5pdGl6ZWR9IHRleHQuXG4gKlxuICogQHVzYWdlXG4gICA8c3BhbiBuZy1iaW5kLWh0bWw9XCJsaW5reV9leHByZXNzaW9uIHwgbGlua3lcIj48L3NwYW4+XG4gKlxuICogQGV4YW1wbGVcbiAgIDxleGFtcGxlIG1vZHVsZT1cImxpbmt5RXhhbXBsZVwiIGRlcHM9XCJhbmd1bGFyLXNhbml0aXplLmpzXCIgbmFtZT1cImxpbmt5LWZpbHRlclwiPlxuICAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkV4YW1wbGVDb250cm9sbGVyXCI+XG4gICAgICAgU25pcHBldDogPHRleHRhcmVhIG5nLW1vZGVsPVwic25pcHBldFwiIGNvbHM9XCI2MFwiIHJvd3M9XCIzXCI+PC90ZXh0YXJlYT5cbiAgICAgICA8dGFibGU+XG4gICAgICAgICA8dHI+XG4gICAgICAgICAgIDx0aD5GaWx0ZXI8L3RoPlxuICAgICAgICAgICA8dGg+U291cmNlPC90aD5cbiAgICAgICAgICAgPHRoPlJlbmRlcmVkPC90aD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJsaW5reS1maWx0ZXJcIj5cbiAgICAgICAgICAgPHRkPmxpbmt5IGZpbHRlcjwvdGQ+XG4gICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICA8cHJlPiZsdDtkaXYgbmctYmluZC1odG1sPVwic25pcHBldCB8IGxpbmt5XCImZ3Q7PGJyPiZsdDsvZGl2Jmd0OzwvcHJlPlxuICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgPGRpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0IHwgbGlua3lcIj48L2Rpdj5cbiAgICAgICAgICAgPC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJsaW5reS10YXJnZXRcIj5cbiAgICAgICAgICA8dGQ+bGlua3kgdGFyZ2V0PC90ZD5cbiAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICA8cHJlPiZsdDtkaXYgbmctYmluZC1odG1sPVwic25pcHBldFdpdGhTaW5nbGVVUkwgfCBsaW5reTonX2JsYW5rJ1wiJmd0Ozxicj4mbHQ7L2RpdiZndDs8L3ByZT5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgIDxkaXYgbmctYmluZC1odG1sPVwic25pcHBldFdpdGhTaW5nbGVVUkwgfCBsaW5reTonX2JsYW5rJ1wiPjwvZGl2PlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwibGlua3ktY3VzdG9tLWF0dHJpYnV0ZXNcIj5cbiAgICAgICAgICA8dGQ+bGlua3kgY3VzdG9tIGF0dHJpYnV0ZXM8L3RkPlxuICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgIDxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5Oidfc2VsZic6e3JlbDogJ25vZm9sbG93J31cIiZndDs8YnI+Jmx0Oy9kaXYmZ3Q7PC9wcmU+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICA8ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRXaXRoU2luZ2xlVVJMIHwgbGlua3k6J19zZWxmJzp7cmVsOiAnbm9mb2xsb3cnfVwiPjwvZGl2PlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwiZXNjYXBlZC1odG1sXCI+XG4gICAgICAgICAgIDx0ZD5ubyBmaWx0ZXI8L3RkPlxuICAgICAgICAgICA8dGQ+PHByZT4mbHQ7ZGl2IG5nLWJpbmQ9XCJzbmlwcGV0XCImZ3Q7PGJyPiZsdDsvZGl2Jmd0OzwvcHJlPjwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQ9XCJzbmlwcGV0XCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgPC90YWJsZT5cbiAgICAgPC9maWxlPlxuICAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gICAgICAgYW5ndWxhci5tb2R1bGUoJ2xpbmt5RXhhbXBsZScsIFsnbmdTYW5pdGl6ZSddKVxuICAgICAgICAgLmNvbnRyb2xsZXIoJ0V4YW1wbGVDb250cm9sbGVyJywgWyckc2NvcGUnLCBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgJHNjb3BlLnNuaXBwZXQgPVxuICAgICAgICAgICAgICdQcmV0dHkgdGV4dCB3aXRoIHNvbWUgbGlua3M6XFxuJyArXG4gICAgICAgICAgICAgJ2h0dHA6Ly9hbmd1bGFyanMub3JnLyxcXG4nICtcbiAgICAgICAgICAgICAnbWFpbHRvOnVzQHNvbWV3aGVyZS5vcmcsXFxuJyArXG4gICAgICAgICAgICAgJ2Fub3RoZXJAc29tZXdoZXJlLm9yZyxcXG4nICtcbiAgICAgICAgICAgICAnYW5kIG9uZSBtb3JlOiBmdHA6Ly8xMjcuMC4wLjEvLic7XG4gICAgICAgICAgICRzY29wZS5zbmlwcGV0V2l0aFNpbmdsZVVSTCA9ICdodHRwOi8vYW5ndWxhcmpzLm9yZy8nO1xuICAgICAgICAgfV0pO1xuICAgICA8L2ZpbGU+XG4gICAgIDxmaWxlIG5hbWU9XCJwcm90cmFjdG9yLmpzXCIgdHlwZT1cInByb3RyYWN0b3JcIj5cbiAgICAgICBpdCgnc2hvdWxkIGxpbmtpZnkgdGhlIHNuaXBwZXQgd2l0aCB1cmxzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoZWxlbWVudChieS5pZCgnbGlua3ktZmlsdGVyJykpLmVsZW1lbnQoYnkuYmluZGluZygnc25pcHBldCB8IGxpbmt5JykpLmdldFRleHQoKSkuXG4gICAgICAgICAgICAgdG9CZSgnUHJldHR5IHRleHQgd2l0aCBzb21lIGxpbmtzOiBodHRwOi8vYW5ndWxhcmpzLm9yZy8sIHVzQHNvbWV3aGVyZS5vcmcsICcgK1xuICAgICAgICAgICAgICAgICAgJ2Fub3RoZXJAc29tZXdoZXJlLm9yZywgYW5kIG9uZSBtb3JlOiBmdHA6Ly8xMjcuMC4wLjEvLicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQuYWxsKGJ5LmNzcygnI2xpbmt5LWZpbHRlciBhJykpLmNvdW50KCkpLnRvRXF1YWwoNCk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIG5vdCBsaW5raWZ5IHNuaXBwZXQgd2l0aG91dCB0aGUgbGlua3kgZmlsdGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoZWxlbWVudChieS5pZCgnZXNjYXBlZC1odG1sJykpLmVsZW1lbnQoYnkuYmluZGluZygnc25pcHBldCcpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgIHRvQmUoJ1ByZXR0eSB0ZXh0IHdpdGggc29tZSBsaW5rczogaHR0cDovL2FuZ3VsYXJqcy5vcmcvLCBtYWlsdG86dXNAc29tZXdoZXJlLm9yZywgJyArXG4gICAgICAgICAgICAgICAgICAnYW5vdGhlckBzb21ld2hlcmUub3JnLCBhbmQgb25lIG1vcmU6IGZ0cDovLzEyNy4wLjAuMS8uJyk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudC5hbGwoYnkuY3NzKCcjZXNjYXBlZC1odG1sIGEnKSkuY291bnQoKSkudG9FcXVhbCgwKTtcbiAgICAgICB9KTtcblxuICAgICAgIGl0KCdzaG91bGQgdXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBlbGVtZW50KGJ5Lm1vZGVsKCdzbmlwcGV0JykpLmNsZWFyKCk7XG4gICAgICAgICBlbGVtZW50KGJ5Lm1vZGVsKCdzbmlwcGV0JykpLnNlbmRLZXlzKCduZXcgaHR0cDovL2xpbmsuJyk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudChieS5pZCgnbGlua3ktZmlsdGVyJykpLmVsZW1lbnQoYnkuYmluZGluZygnc25pcHBldCB8IGxpbmt5JykpLmdldFRleHQoKSkuXG4gICAgICAgICAgICAgdG9CZSgnbmV3IGh0dHA6Ly9saW5rLicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQuYWxsKGJ5LmNzcygnI2xpbmt5LWZpbHRlciBhJykpLmNvdW50KCkpLnRvRXF1YWwoMSk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudChieS5pZCgnZXNjYXBlZC1odG1sJykpLmVsZW1lbnQoYnkuYmluZGluZygnc25pcHBldCcpKS5nZXRUZXh0KCkpXG4gICAgICAgICAgICAgLnRvQmUoJ25ldyBodHRwOi8vbGluay4nKTtcbiAgICAgICB9KTtcblxuICAgICAgIGl0KCdzaG91bGQgd29yayB3aXRoIHRoZSB0YXJnZXQgcHJvcGVydHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2xpbmt5LXRhcmdldCcpKS5cbiAgICAgICAgICAgIGVsZW1lbnQoYnkuYmluZGluZyhcInNuaXBwZXRXaXRoU2luZ2xlVVJMIHwgbGlua3k6J19ibGFuaydcIikpLmdldFRleHQoKSkuXG4gICAgICAgICAgICB0b0JlKCdodHRwOi8vYW5ndWxhcmpzLm9yZy8nKTtcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjbGlua3ktdGFyZ2V0IGEnKSkuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSkudG9FcXVhbCgnX2JsYW5rJyk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIG9wdGlvbmFsbHkgYWRkIGN1c3RvbSBhdHRyaWJ1dGVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdsaW5reS1jdXN0b20tYXR0cmlidXRlcycpKS5cbiAgICAgICAgICAgIGVsZW1lbnQoYnkuYmluZGluZyhcInNuaXBwZXRXaXRoU2luZ2xlVVJMIHwgbGlua3k6J19zZWxmJzp7cmVsOiAnbm9mb2xsb3cnfVwiKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgIHRvQmUoJ2h0dHA6Ly9hbmd1bGFyanMub3JnLycpO1xuICAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNsaW5reS1jdXN0b20tYXR0cmlidXRlcyBhJykpLmdldEF0dHJpYnV0ZSgncmVsJykpLnRvRXF1YWwoJ25vZm9sbG93Jyk7XG4gICAgICAgfSk7XG4gICAgIDwvZmlsZT5cbiAgIDwvZXhhbXBsZT5cbiAqL1xuYW5ndWxhci5tb2R1bGUoJ25nU2FuaXRpemUnKS5maWx0ZXIoJ2xpbmt5JywgWyckc2FuaXRpemUnLCBmdW5jdGlvbigkc2FuaXRpemUpIHtcbiAgdmFyIExJTktZX1VSTF9SRUdFWFAgPVxuICAgICAgICAvKChzP2Z0cHxodHRwcz8pOlxcL1xcL3wod3d3XFwuKXwobWFpbHRvOik/W0EtWmEtejAtOS5fJSstXStAKVxcUypbXlxccy47LCgpe308PlwiXFx1MjAxZFxcdTIwMTldL2ksXG4gICAgICBNQUlMVE9fUkVHRVhQID0gL15tYWlsdG86L2k7XG5cbiAgdmFyIGxpbmt5TWluRXJyID0gYW5ndWxhci4kJG1pbkVycignbGlua3knKTtcbiAgdmFyIGlzRGVmaW5lZCA9IGFuZ3VsYXIuaXNEZWZpbmVkO1xuICB2YXIgaXNGdW5jdGlvbiA9IGFuZ3VsYXIuaXNGdW5jdGlvbjtcbiAgdmFyIGlzT2JqZWN0ID0gYW5ndWxhci5pc09iamVjdDtcbiAgdmFyIGlzU3RyaW5nID0gYW5ndWxhci5pc1N0cmluZztcblxuICByZXR1cm4gZnVuY3Rpb24odGV4dCwgdGFyZ2V0LCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHRleHQgPT0gbnVsbCB8fCB0ZXh0ID09PSAnJykgcmV0dXJuIHRleHQ7XG4gICAgaWYgKCFpc1N0cmluZyh0ZXh0KSkgdGhyb3cgbGlua3lNaW5FcnIoJ25vdHN0cmluZycsICdFeHBlY3RlZCBzdHJpbmcgYnV0IHJlY2VpdmVkOiB7MH0nLCB0ZXh0KTtcblxuICAgIHZhciBhdHRyaWJ1dGVzRm4gPVxuICAgICAgaXNGdW5jdGlvbihhdHRyaWJ1dGVzKSA/IGF0dHJpYnV0ZXMgOlxuICAgICAgaXNPYmplY3QoYXR0cmlidXRlcykgPyBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzT2JqZWN0KCkge3JldHVybiBhdHRyaWJ1dGVzO30gOlxuICAgICAgZnVuY3Rpb24gZ2V0RW1wdHlBdHRyaWJ1dGVzT2JqZWN0KCkge3JldHVybiB7fTt9O1xuXG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciByYXcgPSB0ZXh0O1xuICAgIHZhciBodG1sID0gW107XG4gICAgdmFyIHVybDtcbiAgICB2YXIgaTtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmF3Lm1hdGNoKExJTktZX1VSTF9SRUdFWFApKSkge1xuICAgICAgLy8gV2UgY2FuIG5vdCBlbmQgaW4gdGhlc2UgYXMgdGhleSBhcmUgc29tZXRpbWVzIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIHNlbnRlbmNlXG4gICAgICB1cmwgPSBtYXRjaFswXTtcbiAgICAgIC8vIGlmIHdlIGRpZCBub3QgbWF0Y2ggZnRwL2h0dHAvd3d3L21haWx0byB0aGVuIGFzc3VtZSBtYWlsdG9cbiAgICAgIGlmICghbWF0Y2hbMl0gJiYgIW1hdGNoWzRdKSB7XG4gICAgICAgIHVybCA9IChtYXRjaFszXSA/ICdodHRwOi8vJyA6ICdtYWlsdG86JykgKyB1cmw7XG4gICAgICB9XG4gICAgICBpID0gbWF0Y2guaW5kZXg7XG4gICAgICBhZGRUZXh0KHJhdy5zdWJzdHIoMCwgaSkpO1xuICAgICAgYWRkTGluayh1cmwsIG1hdGNoWzBdLnJlcGxhY2UoTUFJTFRPX1JFR0VYUCwgJycpKTtcbiAgICAgIHJhdyA9IHJhdy5zdWJzdHJpbmcoaSArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgfVxuICAgIGFkZFRleHQocmF3KTtcbiAgICByZXR1cm4gJHNhbml0aXplKGh0bWwuam9pbignJykpO1xuXG4gICAgZnVuY3Rpb24gYWRkVGV4dCh0ZXh0KSB7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaHRtbC5wdXNoKHNhbml0aXplVGV4dCh0ZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGluayh1cmwsIHRleHQpIHtcbiAgICAgIHZhciBrZXksIGxpbmtBdHRyaWJ1dGVzID0gYXR0cmlidXRlc0ZuKHVybCk7XG4gICAgICBodG1sLnB1c2goJzxhICcpO1xuXG4gICAgICBmb3IgKGtleSBpbiBsaW5rQXR0cmlidXRlcykge1xuICAgICAgICBodG1sLnB1c2goa2V5ICsgJz1cIicgKyBsaW5rQXR0cmlidXRlc1trZXldICsgJ1wiICcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWZpbmVkKHRhcmdldCkgJiYgISgndGFyZ2V0JyBpbiBsaW5rQXR0cmlidXRlcykpIHtcbiAgICAgICAgaHRtbC5wdXNoKCd0YXJnZXQ9XCInLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgJ1wiICcpO1xuICAgICAgfVxuICAgICAgaHRtbC5wdXNoKCdocmVmPVwiJyxcbiAgICAgICAgICAgICAgICB1cmwucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLFxuICAgICAgICAgICAgICAgICdcIj4nKTtcbiAgICAgIGFkZFRleHQodGV4dCk7XG4gICAgICBodG1sLnB1c2goJzwvYT4nKTtcbiAgICB9XG4gIH07XG59XSk7XG5cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCJyZXF1aXJlKCcuL2FuZ3VsYXItc2FuaXRpemUnKTtcbm1vZHVsZS5leHBvcnRzID0gJ25nU2FuaXRpemUnO1xuIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaCAoZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG4iLCIvLyBzdHlsZXNcclxucmVxdWlyZSgnLi9hcHAuc3Bvay13ZWF0aGVyLnN0eWxlLnNjc3MnKTtcclxuXHJcbi8vIG1haW5cclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB1aXJvdXRlciA9IHJlcXVpcmUoJ0B1aXJvdXRlci9hbmd1bGFyanMnKS5kZWZhdWx0O1xyXG52YXIgbmdTYW5pdGl6ZSA9IHJlcXVpcmUoJ2FuZ3VsYXItc2FuaXRpemUnKTtcclxuXHJcbnJvdXRpbmdDb25maWcuJGluamVjdCA9IFsnJHN0YXRlUHJvdmlkZXInLCAnJGxvY2F0aW9uUHJvdmlkZXInLCAnJHVybFJvdXRlclByb3ZpZGVyJ107XHJcbmZ1bmN0aW9uIHJvdXRpbmdDb25maWcoJHN0YXRlUHJvdmlkZXIsICRsb2NhdGlvblByb3ZpZGVyLCAkdXJsUm91dGVyUHJvdmlkZXIpIHtcclxuXHJcbiAgICAvLyBSZW1vdmUgIyBmcm9tIHVybFxyXG4gICAgJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKHRydWUpO1xyXG5cclxuICAgIC8vIFJlZGlyZWN0c1xyXG4gICAgJHVybFJvdXRlclByb3ZpZGVyLndoZW4oJy8nLCAnL3Nwb2svd2VhdGhlcicpO1xyXG5cclxuICAgIHZhciBzdGF0ZXMgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnYXBwJyxcclxuICAgICAgICAgICAgdXJsOiAnL3Nwb2snLFxyXG4gICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnYXBwLndlYXRoZXInLFxyXG4gICAgICAgICAgICB1cmw6ICcvd2VhdGhlcicsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogJ2FwcFdlYXRoZXJTZWFyY2gnLFxyXG4gICAgICAgICAgICBwYXJhbXM6IHtcclxuICAgICAgICAgICAgICAgIHNlYXJjaDogJydcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzb2x2ZToge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2FwcC53ZWF0aGVyLmZvcmVjYXN0JyxcclxuICAgICAgICAgICAgdXJsOiAnL3tzZWFyY2h9L2ZvcmVjYXN0JyxcclxuICAgICAgICAgICAgY29tcG9uZW50OiAnYXBwV2VhdGhlckZvcmVjYXN0JyxcclxuICAgICAgICAgICAgcmVzb2x2ZToge1xyXG4gICAgICAgICAgICAgICAgZm9yZWNhc3RSZXN1bHRzOiBbJyRzdGF0ZVBhcmFtcycsJ2FwcFdlYXRoZXJTZXJ2aWNlJywgZnVuY3Rpb24oJHN0YXRlUGFyYW1zLCBhcHBXZWF0aGVyU2VydmljZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBXZWF0aGVyU2VydmljZS5zZWFyY2goJHN0YXRlUGFyYW1zLnNlYXJjaCk7XHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgXTtcclxuICAgIHN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICRzdGF0ZVByb3ZpZGVyLnN0YXRlKHN0YXRlKVxyXG4gICAgfSlcclxufVxyXG5cclxudmFyIGRlcGVuZGVuY2llcyA9IFt1aXJvdXRlciwgJ25nU2FuaXRpemUnXTtcclxudmFyIHdlYXRoZXJBcHAgPSBhbmd1bGFyXHJcbiAgICAubW9kdWxlKCdzcG9rLXdlYXRoZXInLCBkZXBlbmRlbmNpZXMpXHJcbiAgICAuY29uZmlnKHJvdXRpbmdDb25maWcpXHJcbiAgICAuc2VydmljZShcImFwcFdlYXRoZXJTZXJ2aWNlXCIsIHJlcXVpcmUoJy4vc2VydmljZXMvd2VhdGhlci1zZWFyY2guc2VydmljZScpKVxyXG4gICAgLmNvbXBvbmVudChcImFwcFdlYXRoZXJTZWFyY2hcIiwgcmVxdWlyZSgnLi93ZWF0aGVyLXNlYXJjaC93ZWF0aGVyLXNlYXJjaC5jb21wb25lbnQnKSlcclxuICAgIC5jb21wb25lbnQoXCJhcHBXZWF0aGVyRm9yZWNhc3RcIiwgcmVxdWlyZSgnLi93ZWF0aGVyLWZvcmVjYXN0L3dlYXRoZXItZm9yZWNhc3QuY29tcG9uZW50JykpXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHdlYXRoZXJBcHAubmFtZSIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luIiwic2VydmljZS4kaW5qZWN0ID0gWyckaHR0cCddO1xyXG5cclxuZnVuY3Rpb24gc2VydmljZSgkaHR0cCkge1xyXG4gICAgdmFyIGFwaSA9ICdodHRwczovL3F1ZXJ5LnlhaG9vYXBpcy5jb20vdjEvcHVibGljL3lxbD9xPXt5cWx9JmZvcm1hdD1qc29uJmVudj1zdG9yZSUzQSUyRiUyRmRhdGF0YWJsZXMub3JnJTJGYWxsdGFibGVzd2l0aGtleXMnXHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHNlYXJjaChsb2NhdGlvbikge1xyXG4gICAgICAgIHZhciB5cWwgPSBgc2VsZWN0JTIwKiUyMGZyb20lMjB3ZWF0aGVyLmZvcmVjYXN0JTIwd2hlcmUlMjB3b2VpZCUyMGluJTIwKHNlbGVjdCUyMHdvZWlkJTIwZnJvbSUyMGdlby5wbGFjZXMoMSklMjB3aGVyZSUyMHRleHQlM0QlMjIke2xvY2F0aW9ufSUyMilgXHJcbiAgICAgICAgdmFyIHVybCA9IGFwaS5yZXBsYWNlKCd7eXFsfScsIHlxbCk7XHJcbiAgICAgICAgcmV0dXJuICRodHRwLmdldCh1cmwpXHJcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEucXVlcnkucmVzdWx0cy5jaGFubmVsLml0ZW07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VhcmNoOiBzZWFyY2hcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzZXJ2aWNlOyIsInZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vd2VhdGhlci1mb3JlY2FzdC50ZW1wbGF0ZS5odG1sJylcclxudmFyIGNvbnRyb2xsZXIgPSByZXF1aXJlKCcuL3dlYXRoZXItZm9yZWNhc3QuY29udHJvbGxlci5qcycpXHJcblxyXG52YXIgY29tcG9uZW50ID0ge1xyXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxyXG4gICAgY29udHJvbGxlcjogY29udHJvbGxlcixcclxuICAgIGNvbnRyb2xsZXJBczogJyR3ZWF0aGVyRm9yZWNhc3QnLFxyXG4gICAgYmluZGluZ3M6IHtcclxuICAgICAgICBmb3JlY2FzdFJlc3VsdHM6ICc8J1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBvbmVudDsiLCJjb250cm9sbGVyLiRpbmplY3QgPSBbXTtcclxuXHJcbmZ1bmN0aW9uIGNvbnRyb2xsZXIoKSB7XHJcbiAgICAkd2VhdGhlckZvcmVjYXN0ID0gdGhpcztcclxuICAgIFxyXG4gICAgJHdlYXRoZXJGb3JlY2FzdC4kb25Jbml0ID0gKCkgPT4ge1xyXG4gICAgICAgICR3ZWF0aGVyRm9yZWNhc3QuZm9yZWNhc3QgPSAkd2VhdGhlckZvcmVjYXN0LmZvcmVjYXN0UmVzdWx0cy5kZXNjcmlwdGlvblxyXG4gICAgICAgICAgICAucmVwbGFjZSgvKD86PCFcXFtDREFUQVxcWyl8KD86XFxdXFxdPikvZywgXCJcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29udHJvbGxlcjsiLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxyXFxuPGRpdiBjbGFzcz1cXFwid2VhdGhlci1mb3JlY2FzdFxcXCI+XFxyXFxuICA8ZGl2IG5nLWJpbmQtaHRtbD1cXFwiJHdlYXRoZXJGb3JlY2FzdC5mb3JlY2FzdFxcXCI+PC9kaXY+XFxyXFxuPC9kaXY+XCIiLCJ2YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3dlYXRoZXItc2VhcmNoLnRlbXBsYXRlLmh0bWwnKVxyXG52YXIgY29udHJvbGxlciA9IHJlcXVpcmUoJy4vd2VhdGhlci1zZWFyY2guY29udHJvbGxlci5qcycpXHJcblxyXG52YXIgY29tcG9uZW50ID0ge1xyXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxyXG4gICAgY29udHJvbGxlcjogY29udHJvbGxlcixcclxuICAgIGNvbnRyb2xsZXJBczogJyR3ZWF0aGVyU2VhcmNoJyxcclxuICAgIGJpbmRpbmdzOiB7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29tcG9uZW50OyIsImNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHN0YXRlJywgJyRzdGF0ZVBhcmFtcyddO1xyXG5cclxuZnVuY3Rpb24gY29udHJvbGxlcigkc3RhdGUsICRzdGF0ZVBhcmFtcykge1xyXG4gICAgdmFyICR3ZWF0aGVyU2VhcmNoID0gdGhpcztcclxuXHJcbiAgICAkd2VhdGhlclNlYXJjaC5zZWFyY2ggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAkc3RhdGUuZ28oJ2FwcC53ZWF0aGVyLmZvcmVjYXN0Jywge3NlYXJjaDogJHdlYXRoZXJTZWFyY2guc2VhcmNoVGV4dH0pO1xyXG4gICAgfVxyXG5cclxuICAgICR3ZWF0aGVyU2VhcmNoLiRvbkluaXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBpbml0IHN0dWZmXHJcbiAgICAgICAgJHdlYXRoZXJTZWFyY2guc2VhcmNoVGV4dCA9ICRzdGF0ZVBhcmFtcy5zZWFyY2g7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29udHJvbGxlcjsiLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxyXFxuPGRpdiBjbGFzcz1cXFwianVtYm90cm9uIHdlYXRoZXItc2VhcmNoXFxcIj5cXHJcXG4gICAgICAgIDxoMSBjbGFzcz1cXFwiZGlzcGxheS00XFxcIj5Gb3JlY2FzdCBTZWFyY2g8L2gxPlxcclxcbiAgICAgICAgPHAgY2xhc3M9XFxcImxlYWRcXFwiPlNlYXJjaCBTcG9rIGZvciB5b3VyIGxvY2FsIGZvcmVjYXN0ITwvcD5cXHJcXG4gICAgICAgIDxociBjbGFzcz1cXFwibXktNFxcXCI+XFxyXFxuICAgICAgICA8cD5UeXBlIGluIHlvdXIgY2l0eSBhbmQgc3RhdGUgaW4gdGhlIGJveCBiZWxvdzwvcD5cXHJcXG4gICAgICAgIDxwIGNsYXNzPVxcXCJsZWFkXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAgbWItM1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cC1wcmVwZW5kXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nLWNsaWNrPVxcXCIkd2VhdGhlclNlYXJjaC5zZWFyY2goKVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZy1kaXNhYmxlZD1cXFwiJHdlYXRoZXJTZWFyY2guc2VhcmNoVGV4dCA9PSAnJ1xcXCI+U2VhcmNoPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwiJHdlYXRoZXJTZWFyY2guc2VhcmNoVGV4dFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcIndlYXRoZXJTZWFyY2hcXFwiIHBsYWNlaG9sZGVyPVxcXCJNaW5uZWFwb2xpcywgTU5cXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvcD5cXHJcXG4gICAgICAgIFxcclxcbiAgICAgICAgPHVpLXZpZXc+PC91aS12aWV3PlxcclxcbjwvZGl2PlwiIiwibW9kdWxlLmV4cG9ydHMgPSBhbmd1bGFyOyJdLCJzb3VyY2VSb290IjoiIn0=